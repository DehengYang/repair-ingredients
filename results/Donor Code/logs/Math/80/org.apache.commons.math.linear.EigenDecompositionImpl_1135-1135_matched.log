---patch code ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1135, 1135>
int j = 4 * (n - 1);

---fix ingredient(SameMethod)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1135, 1135>
int j = 4 * n - 1;

---patch code 0--- org.apache.commons.math.linear.EigenDecompositionImpl <1135, 1135>
int intVar = 4 * (intVar - 1);

---fix ingredient(SameMethod)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <1135, 1135>
int intVar = 4 * intVar - 1;

---patch code 1--- org.apache.commons.math.linear.EigenDecompositionImpl <1135, 1135>
int j = 4 * (n - 1);

---fix ingredient(SameMethod)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1135, 1135>
int j = 4 * n - 1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.LaguerreSolver <309, 309>
Complex N1 = new Complex(n - 1, 0.0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.solvers.LaguerreSolver <309, 309>
Complex Complex = new Complex(intVar - 1, 0.0);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.solvers.LaguerreSolver <309, 309>
Complex Complex = new Complex(n - 1, 0.0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <225, 225>
final int n = degree() + 1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <225, 225>
final int intVar = degree() + 1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <225, 225>
final int n = degree() + 1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <147, 150>
throw MathRuntimeException.createIllegalArgumentException(
                    "{0} points Legendre-Gauss integrator not supported, " +
                    "number of points must be in the {1}-{2} range",
                    n, 2, 5);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <147, 150>
throw MathRuntimeException.createIllegalArgumentException(
                    "{0} points Legendre-Gauss integrator not supported, " +
                    "number of points must be in the {1}-{2} range",
                    intVar, 2, 5);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <147, 150>
throw MathRuntimeException.createIllegalArgumentException(
                    "{0} points Legendre-Gauss integrator not supported, " +
                    "number of points must be in the {1}-{2} range",
                    n, 2, 5);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <339, 339>
final double d = 1.0 / (j - 3);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <339, 339>
final double doubleVar = 1.0 / (intVar - 3);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <339, 339>
final double d = 1.0 / (j - 3);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.complex.Complex <974, 974>
final double slice = 2 * Math.PI / n;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.complex.Complex <974, 974>
final double doubleVar = 2 * Math.PI / intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.complex.Complex <974, 974>
final double slice = 2 * Math.PI / n;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastCosineTransformer <169, 169>
double scaling_coefficient = 2.0 / (n - 1);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastCosineTransformer <169, 169>
double doubleVar = 2.0 / (intVar - 1);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastCosineTransformer <169, 169>
double scaling_coefficient = 2.0 / (n - 1);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.ranking.NaturalRanking <262, 262>
int j = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.ranking.NaturalRanking <262, 262>
int intVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.ranking.NaturalRanking <262, 262>
int j = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <414, 414>
return getSumSquaredErrors() / (n - 2);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.SimpleRegression <414, 414>
return getSumSquaredErrors() / (longVar - 2);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.SimpleRegression <414, 414>
return getSumSquaredErrors() / (n - 2);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.special.Gamma <175, 175>
double n = 0.0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.special.Gamma <175, 175>
double doubleVar = 0.0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.special.Gamma <175, 175>
double n = 0.0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <349, 349>
long n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.RandomDataImpl <349, 349>
long longVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.RandomDataImpl <349, 349>
long n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.MersenneTwister <166, 166>
int j = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.MersenneTwister <166, 166>
int intVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.MersenneTwister <166, 166>
int j = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.SaddlePointExpansion <153, 153>
int j = 1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.SaddlePointExpansion <153, 153>
int intVar = 1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.distribution.SaddlePointExpansion <153, 153>
int j = 1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.Fraction <198, 198>
int n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.fraction.Fraction <198, 198>
int intVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.fraction.Fraction <198, 198>
int n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.BigFraction <299, 299>
int n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.fraction.BigFraction <299, 299>
int intVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.fraction.BigFraction <299, 299>
int n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <174, 174>
int n = 2;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <174, 174>
int intVar = 2;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <174, 174>
int n = 2;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.ContinuedFraction <133, 133>
int n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.ContinuedFraction <133, 133>
int intVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.ContinuedFraction <133, 133>
int n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastCosineTransformer <127, 127>
double scaling_coefficient = Math.sqrt(2.0 / (n-1));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastCosineTransformer <127, 127>
double doubleVar = Math.sqrt(2.0 / (intVar-1));

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastCosineTransformer <127, 127>
double scaling_coefficient = Math.sqrt(2.0 / (n-1));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.integration.RombergIntegrator <91, 91>
final double r = (1L << (2 * j)) - 1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.integration.RombergIntegrator <91, 91>
final double doubleVar = (1L << (2 * intVar)) - 1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.integration.RombergIntegrator <91, 91>
final double r = (1L << (2 * j)) - 1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <280, 280>
final double fac1 = 0.5 * j * (j - 1);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <280, 280>
final double doubleVar = 0.5 * intVar * (intVar - 1);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <280, 280>
final double fac1 = 0.5 * j * (j - 1);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <279, 279>
int i = j - 1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <279, 279>
int intVar = intVar - 1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <279, 279>
int i = j - 1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser <172, 172>
int i = j - 1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser <172, 172>
int intVar = intVar - 1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser <172, 172>
int i = j - 1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.NelderMead <97, 97>
final double scaling = 1.0 / n;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.NelderMead <97, 97>
final double doubleVar = 1.0 / intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.NelderMead <97, 97>
final double scaling = 1.0 / n;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <210, 210>
double scaling_coefficient = 1.0 / n;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <210, 210>
double doubleVar = 1.0 / intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <210, 210>
double scaling_coefficient = 1.0 / n;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastHadamardTransformer <158, 158>
final int halfN = n / 2;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastHadamardTransformer <158, 158>
final int intVar = intVar / 2;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastHadamardTransformer <158, 158>
final int halfN = n / 2;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastHadamardTransformer <209, 209>
final int halfN = n / 2;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastHadamardTransformer <209, 209>
final int intVar = intVar / 2;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastHadamardTransformer <209, 209>
final int halfN = n / 2;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastSineTransformer <166, 166>
double scaling_coefficient = 2.0 / n;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastSineTransformer <166, 166>
double doubleVar = 2.0 / intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastSineTransformer <166, 166>
double scaling_coefficient = 2.0 / n;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.integration.TrapezoidIntegrator <84, 84>
final long np = 1L << (n-1);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.integration.TrapezoidIntegrator <84, 84>
final long longVar = 1L << (intVar-1);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.integration.TrapezoidIntegrator <84, 84>
final long np = 1L << (n-1);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.OpenMapRealVector <388, 388>
checkIndex(index + n - 1);

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.OpenMapRealVector <388, 388>
checkIndex(intVar + intVar - 1);

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.OpenMapRealVector <388, 388>
checkIndex(index + n - 1);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <1198, 1198>
checkIndex(index + n - 1);

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <1198, 1198>
checkIndex(intVar + intVar - 1);

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.ArrayRealVector <1198, 1198>
checkIndex(index + n - 1);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <633, 633>
checkIndex(index + n - 1);

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayFieldVector <633, 633>
checkIndex(intVar + intVar - 1);

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.ArrayFieldVector <633, 633>
checkIndex(index + n - 1);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SparseFieldVector <320, 320>
checkIndex(index + n - 1);

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.SparseFieldVector <320, 320>
checkIndex(intVar + intVar - 1);

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.SparseFieldVector <320, 320>
checkIndex(index + n - 1);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.rank.Percentile <211, 211>
double pos = p * (n + 1) / 100;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.rank.Percentile <211, 211>
double doubleVar = doubleVar * (doubleVar + 1) / 100;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.rank.Percentile <211, 211>
double pos = p * (n + 1) / 100;

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <954, 954>
final int j = i - 2 * pingPong - 1;

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <954, 954>
final int intVar = intVar - 2 * intVar - 1;

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <954, 954>
final int j = i - 2 * pingPong - 1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <486, 489>
if (2 * j == n) {
        // save the point at the middle of the step
        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);
      }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <486, 489>
if (2 * intVar == intVar) {
        // save the point at the middle of the step
        System.arraycopy(double[]Var, 0, double[]Var, 0, double[]Var.length);
      }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <486, 489>
if (2 * j == n) {
        // save the point at the middle of the step
        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <389, 389>
final double n = nextGaussian(0d, 1d);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.RandomDataImpl <389, 389>
final double longVar = nextGaussian(0d, 1d);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.RandomDataImpl <389, 389>
final double n = nextGaussian(0d, 1d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.LaguerreSolver <308, 308>
Complex N  = new Complex(n,     0.0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.solvers.LaguerreSolver <308, 308>
Complex Complex  = new Complex(intVar,     0.0);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.solvers.LaguerreSolver <308, 308>
Complex Complex  = new Complex(n,     0.0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <139, 139>
distribution.setDegreesOfFreedom(n - 2);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.SimpleRegression <139, 139>
TDistribution.setDegreesOfFreedom(longVar - 2);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.SimpleRegression <139, 139>
TDistribution.setDegreesOfFreedom(n - 2);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <171, 171>
distribution.setDegreesOfFreedom(n - 2);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.SimpleRegression <171, 171>
TDistribution.setDegreesOfFreedom(longVar - 2);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.SimpleRegression <171, 171>
TDistribution.setDegreesOfFreedom(n - 2);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <618, 618>
distribution.setDegreesOfFreedom(n - 2);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.SimpleRegression <618, 618>
TDistribution.setDegreesOfFreedom(longVar - 2);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.SimpleRegression <618, 618>
TDistribution.setDegreesOfFreedom(n - 2);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.TTestImpl <959, 959>
distribution.setDegreesOfFreedom(n - 1);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.inference.TTestImpl <959, 959>
TDistribution.setDegreesOfFreedom(doubleVar - 1);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.inference.TTestImpl <959, 959>
TDistribution.setDegreesOfFreedom(n - 1);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.special.Gamma <180, 180>
n = n + 1.0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.special.Gamma <180, 180>
doubleVar = doubleVar + 1.0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.special.Gamma <180, 180>
n = n + 1.0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.LaguerreSolver <260, 260>
Complex c[] = new Complex[n+1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.solvers.LaguerreSolver <260, 260>
Complex Complex[] = new Complex[intVar+1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.solvers.LaguerreSolver <260, 260>
Complex Complex[] = new Complex[n+1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <206, 206>
double out[] = new double[n + 1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <206, 206>
double doubleVar[] = new double[intVar + 1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <206, 206>
double out[] = new double[n + 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <239, 239>
double[] result = new double[n - 1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <239, 239>
double[] double[]Var = new double[intVar - 1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <239, 239>
double[] result = new double[n - 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <232, 232>
final double[] c = new double[n+1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <232, 232>
final double[] double[]Var = new double[intVar+1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <232, 232>
final double[] c = new double[n+1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <87, 87>
double z[] = new double[n + 1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <87, 87>
double doubleVar[] = new double[intVar + 1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <87, 87>
double z[] = new double[n + 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <100, 100>
double c[] = new double[n + 1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <100, 100>
double doubleVar[] = new double[intVar + 1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <100, 100>
double c[] = new double[n + 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <171, 171>
final int n = referenceSimplex.length - 1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <171, 171>
final int intVar = double[][]Var.length - 1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <171, 171>
final int n = referenceSimplex.length - 1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <411, 411>
int n = simplex.length - 1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <411, 411>
int intVar = RealPointValuePair[]Var.length - 1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <411, 411>
int n = simplex.length - 1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.NelderMead <80, 80>
final int n = simplex.length - 1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.NelderMead <80, 80>
final int intVar = RealPointValuePair[]Var.length - 1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.NelderMead <80, 80>
final int n = simplex.length - 1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.LaguerreSolver <254, 254>
int n = coefficients.length - 1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.solvers.LaguerreSolver <254, 254>
int intVar = Complex.length - 1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.solvers.LaguerreSolver <254, 254>
int n = Complex.length - 1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.LaguerreSolver <303, 303>
int n = coefficients.length - 1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.solvers.LaguerreSolver <303, 303>
int intVar = Complex.length - 1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.solvers.LaguerreSolver <303, 303>
int n = Complex.length - 1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <70, 70>
int n = x.length - 1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <70, 70>
int intVar = doubleVar.length - 1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <70, 70>
int n = x.length - 1;

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <677, 677>
int j = realEigenvalues.length - 1;

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <677, 677>
int intVar = double[]Var.length - 1;

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <677, 677>
int j = realEigenvalues.length - 1;

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <959, 959>
work[j + 2] = 0.0;

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <959, 959>
double[]Var[intVar + 2] = 0.0;

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <959, 959>
work[j + 2] = 0.0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastCosineTransformer <223, 223>
final int n = f.length - 1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastCosineTransformer <223, 223>
final int intVar = doubleVar.length - 1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastCosineTransformer <223, 223>
final int n = f.length - 1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <151, 151>
double scaling_coefficient = 1.0 / Math.sqrt(n);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <151, 151>
double doubleVar = 1.0 / Math.sqrt(intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <151, 151>
double scaling_coefficient = 1.0 / Math.sqrt(n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <269, 269>
double scaling_coefficient = 1.0 / Math.sqrt(n);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <269, 269>
double doubleVar = 1.0 / Math.sqrt(intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <269, 269>
double scaling_coefficient = 1.0 / Math.sqrt(n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastSineTransformer <126, 126>
double scaling_coefficient = Math.sqrt(2.0 / n);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastSineTransformer <126, 126>
double doubleVar = Math.sqrt(2.0 / intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastSineTransformer <126, 126>
double scaling_coefficient = Math.sqrt(2.0 / n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Variance <172, 172>
return moment.m2 / (moment.n - 1d);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Variance <172, 172>
return FirstMoment.m2 / (FirstMoment.n - 1d);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.Variance <172, 172>
return FirstMoment.m2 / (FirstMoment.n - 1d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <228, 233>
throw new MathException(
                    "the bandwidth must be large enough to " +
                    "accomodate at least 2 points. There are {0} " +
                    " data points, and bandwidth must be at least {1} " +
                    " but it is only {2}",
                    n, 2.0 / n, bandwidth);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <228, 233>
throw new MathException(
                    "the bandwidth must be large enough to " +
                    "accomodate at least 2 points. There are {0} " +
                    " data points, and bandwidth must be at least {1} " +
                    " but it is only {2}",
                    intVar, 2.0 / intVar, doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <228, 233>
throw new MathException(
                    "the bandwidth must be large enough to " +
                    "accomodate at least 2 points. There are {0} " +
                    " data points, and bandwidth must be at least {1} " +
                    " but it is only {2}",
                    n, 2.0 / n, bandwidth);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <113, 113>
this.n = knots.length -1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <113, 113>
PolynomialSplineFunction.intVar = doubleVar.length -1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <113, 113>
PolynomialSplineFunction.n = knots.length -1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics <344, 344>
this.n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics <344, 344>
MultivariateSummaryStatistics.longVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics <344, 344>
MultivariateSummaryStatistics.n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.summary.SumOfSquares <53, 53>
n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.summary.SumOfSquares <53, 53>
longVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.summary.SumOfSquares <53, 53>
n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.summary.SumOfSquares <101, 101>
n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.summary.SumOfSquares <101, 101>
longVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.summary.SumOfSquares <101, 101>
n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.summary.SumOfLogs <62, 62>
n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.summary.SumOfLogs <62, 62>
intVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.summary.SumOfLogs <62, 62>
n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.summary.SumOfLogs <109, 109>
n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.summary.SumOfLogs <109, 109>
intVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.summary.SumOfLogs <109, 109>
n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.summary.Sum <53, 53>
n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.summary.Sum <53, 53>
longVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.summary.Sum <53, 53>
n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.summary.Sum <101, 101>
n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.summary.Sum <101, 101>
longVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.summary.Sum <101, 101>
n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.summary.Product <53, 53>
n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.summary.Product <53, 53>
longVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.summary.Product <53, 53>
n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.summary.Product <101, 101>
n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.summary.Product <101, 101>
longVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.summary.Product <101, 101>
n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.rank.Max <55, 55>
n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.rank.Max <55, 55>
longVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.rank.Max <55, 55>
n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.rank.Max <86, 86>
n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.rank.Max <86, 86>
longVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.rank.Max <86, 86>
n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.rank.Min <55, 55>
n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.rank.Min <55, 55>
longVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.rank.Min <55, 55>
n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.rank.Min <86, 86>
n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.rank.Min <86, 86>
longVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.rank.Min <86, 86>
n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.SummaryStatistics <331, 331>
this.n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.SummaryStatistics <331, 331>
SummaryStatistics.longVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.SummaryStatistics <331, 331>
SummaryStatistics.n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.FirstMoment <77, 77>
n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.FirstMoment <77, 77>
longVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.FirstMoment <77, 77>
n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.FirstMoment <115, 115>
n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.FirstMoment <115, 115>
longVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.FirstMoment <115, 115>
n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <56, 56>
n            = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <56, 56>
longVar            = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <56, 56>
n            = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <116, 116>
n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <116, 116>
longVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <116, 116>
n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <227, 227>
n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.SimpleRegression <227, 227>
longVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.SimpleRegression <227, 227>
n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.correlation.Covariance <62, 62>
n = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.correlation.Covariance <62, 62>
intVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.correlation.Covariance <62, 62>
n = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <172, 175>
if (n < 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "simplex must contain at least one point");
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <172, 175>
if (intVar < 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "simplex must contain at least one point");
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <172, 175>
if (n < 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "simplex must contain at least one point");
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.MersenneTwister <179, 179>
j = 0;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.MersenneTwister <179, 179>
intVar = 0;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.MersenneTwister <179, 179>
j = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <124, 126>
if (n < 1) {
            throw MathRuntimeException.createIllegalArgumentException("empty polynomials coefficients array");
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <124, 126>
if (intVar < 1) {
            throw MathRuntimeException.createIllegalArgumentException("empty polynomials coefficients array");
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <124, 126>
if (n < 1) {
            throw MathRuntimeException.createIllegalArgumentException("empty polynomials coefficients array");
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <233, 235>
if (n < 1) {
            throw MathRuntimeException.createIllegalArgumentException("empty polynomials coefficients array");
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <233, 235>
if (intVar < 1) {
            throw MathRuntimeException.createIllegalArgumentException("empty polynomials coefficients array");
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <233, 235>
if (n < 1) {
            throw MathRuntimeException.createIllegalArgumentException("empty polynomials coefficients array");
        }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <840, 840>
flipIfWarranted(n, 2);

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <840, 840>
flipIfWarranted(intVar, 2);

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <840, 840>
flipIfWarranted(n, 2);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <838, 841>
if (n == 0) {
          throw MathRuntimeException.createIllegalArgumentException(
                  "cannot compute 0-th root of unity, indefinite result");
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <838, 841>
if (intVar == 0) {
          throw MathRuntimeException.createIllegalArgumentException(
                  "cannot compute 0-th root of unity, indefinite result");
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <838, 841>
if (n == 0) {
          throw MathRuntimeException.createIllegalArgumentException(
                  "cannot compute 0-th root of unity, indefinite result");
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.SaddlePointExpansion <195, 195>
double f = (MathUtils.TWO_PI * x * (n - x)) / n;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.SaddlePointExpansion <195, 195>
double doubleVar = (MathUtils.TWO_PI * intVar * (intVar - intVar)) / intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.distribution.SaddlePointExpansion <195, 195>
double f = (MathUtils.TWO_PI * x * (n - x)) / n;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <208, 208>
int i = n - k + 1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <208, 208>
int intVar = intVar - intVar + 1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <208, 208>
int i = n - k + 1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <216, 216>
int i = n - k + 1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <216, 216>
int intVar = intVar - intVar + 1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <216, 216>
int i = n - k + 1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <232, 232>
int i = n - k + 1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <232, 232>
int intVar = intVar - intVar + 1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <232, 232>
int i = n - k + 1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.MultiDirectional <128, 128>
simplex = new RealPointValuePair[n + 1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.MultiDirectional <128, 128>
RealPointValuePair[]Var = new RealPointValuePair[intVar + 1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.MultiDirectional <128, 128>
simplex = new RealPointValuePair[n + 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <368, 368>
simplex = new RealPointValuePair[n + 1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <368, 368>
RealPointValuePair[]Var = new RealPointValuePair[intVar + 1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <368, 368>
simplex = new RealPointValuePair[n + 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <114, 114>
this.knots = new double[n + 1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <114, 114>
PolynomialSplineFunction.doubleVar = new double[intVar + 1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <114, 114>
PolynomialSplineFunction.knots = new double[n + 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm <179, 179>
coefficients = new double[n+1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm <179, 179>
doubleVar = new double[intVar+1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm <179, 179>
coefficients = new double[n+1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.OpenIntToDoubleHashMap <325, 325>
return (j << 2) + j + perturb + 1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.OpenIntToDoubleHashMap <325, 325>
return (intVar << 2) + intVar + intVar + 1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.OpenIntToDoubleHashMap <325, 325>
return (j << 2) + j + perturb + 1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.OpenIntToFieldHashMap <337, 337>
return (j << 2) + j + perturb + 1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.OpenIntToFieldHashMap <337, 337>
return (intVar << 2) + intVar + intVar + 1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.OpenIntToFieldHashMap <337, 337>
return (j << 2) + j + perturb + 1;

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SingularValueDecompositionImpl <274, 280>
getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {
            /** {@inheritDoc} */
            @Override
            public void visit(final int row, final int column, final double value) {
                data[row][column] = value / singularValues[row];
            }
        }, 0, dimension - 1, 0, n - 1);

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.SingularValueDecompositionImpl <274, 280>
getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {
            /** {@inheritDoc} */
            @Override
            public void visit(final int row, final int column, final double value) {
                data[row][column] = value / singularValues[row];
            }
        }, 0, intVar - 1, 0, intVar - 1);

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.SingularValueDecompositionImpl <274, 280>
getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {
            /** {@inheritDoc} */
            @Override
            public void visit(final int row, final int column, final double value) {
                data[row][column] = value / singularValues[row];
            }
        }, 0, dimension - 1, 0, n - 1);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastHadamardTransformer <61, 61>
return FastFourierTransformer.scaleArray(unscaled, 1.0 / n);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastHadamardTransformer <61, 61>
return FastFourierTransformer.scaleArray(double[]Var, 1.0 / intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastHadamardTransformer <61, 61>
return FastFourierTransformer.scaleArray(unscaled, 1.0 / n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.AggregateSummaryStatistics <338, 338>
variance = m2 / (n - 1);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.AggregateSummaryStatistics <338, 338>
doubleVar = doubleVar / (longVar - 1);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.AggregateSummaryStatistics <338, 338>
variance = m2 / (n - 1);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.SecondMoment <81, 81>
m2 += ((double) n - 1) * dev * nDev;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.SecondMoment <81, 81>
doubleVar += ((double) longVar - 1) * doubleVar * doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.SecondMoment <81, 81>
m2 += ((double) n - 1) * dev * nDev;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <131, 131>
xbar += dx / (n + 1.0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.SimpleRegression <131, 131>
doubleVar += doubleVar / (longVar + 1.0);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.SimpleRegression <131, 131>
xbar += dx / (n + 1.0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <132, 132>
ybar += dy / (n + 1.0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.SimpleRegression <132, 132>
doubleVar += doubleVar / (longVar + 1.0);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.SimpleRegression <132, 132>
ybar += dy / (n + 1.0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <164, 164>
xbar -= dx / (n - 1.0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.SimpleRegression <164, 164>
doubleVar -= doubleVar / (longVar - 1.0);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.SimpleRegression <164, 164>
xbar -= dx / (n - 1.0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <165, 165>
ybar -= dy / (n - 1.0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.SimpleRegression <165, 165>
doubleVar -= doubleVar / (longVar - 1.0);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.SimpleRegression <165, 165>
ybar -= dy / (n - 1.0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.LaguerreSolver <268, 268>
Complex subarray[] = new Complex[n-i+1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.solvers.LaguerreSolver <268, 268>
Complex Complex[] = new Complex[intVar-intVar+1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.solvers.LaguerreSolver <268, 268>
Complex Complex[] = new Complex[n-i+1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <152, 152>
System.arraycopy(steps, 0, vertexI, 0, j + 1);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <152, 152>
System.arraycopy(double[]Var, 0, double[]Var, 0, intVar + 1);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <152, 152>
System.arraycopy(steps, 0, vertexI, 0, j + 1);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <115, 115>
System.arraycopy(knots, 0, this.knots, 0, n + 1);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <115, 115>
System.arraycopy(doubleVar, 0, PolynomialSplineFunction.doubleVar, 0, intVar + 1);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <115, 115>
System.arraycopy(knots, 0, PolynomialSplineFunction.knots, 0, n + 1);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <207, 207>
System.arraycopy(knots, 0, out, 0, n + 1);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <207, 207>
System.arraycopy(doubleVar, 0, doubleVar, 0, intVar + 1);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <207, 207>
System.arraycopy(knots, 0, out, 0, n + 1);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.SaddlePointExpansion <157, 157>
s1 = s + ej / ((j * 2) + 1);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.SaddlePointExpansion <157, 157>
doubleVar = doubleVar + doubleVar / ((intVar * 2) + 1);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.distribution.SaddlePointExpansion <157, 157>
s1 = s + ej / ((j * 2) + 1);

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <941, 941>
double d = work[4 * (n - 1) + pingPong];

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <941, 941>
double doubleVar = double[]Var[4 * (intVar - 1) + intVar];

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <941, 941>
double d = work[4 * (n - 1) + pingPong];

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <971, 971>
work[4 * n - 3 - pingPong] = d;

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <971, 971>
double[]Var[4 * intVar - 3 - intVar] = doubleVar;

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <971, 971>
work[4 * n - 3 - pingPong] = d;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.HypergeometricDistributionImpl <149, 149>
return Math.max(0, m - (n - k));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.HypergeometricDistributionImpl <149, 149>
return Math.max(0, intVar - (intVar - intVar));

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.distribution.HypergeometricDistributionImpl <149, 149>
return Math.max(0, m - (n - k));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.complex.Complex <970, 970>
final double nthRootOfAbs = Math.pow(abs(), 1.0 / n);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.complex.Complex <970, 970>
final double doubleVar = Math.pow(abs(), 1.0 / intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.complex.Complex <970, 970>
final double nthRootOfAbs = Math.pow(abs(), 1.0 / n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Skewness <106, 106>
double variance = moment.m2 / (moment.n - 1);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Skewness <106, 106>
double doubleVar = SecondMoment.m2 / (SecondMoment.n - 1);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.Skewness <106, 106>
double variance = SecondMoment.m2 / (SecondMoment.n - 1);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Kurtosis <109, 109>
double variance = moment.m2 / (moment.n - 1);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Kurtosis <109, 109>
double doubleVar = ThirdMoment.m2 / (ThirdMoment.n - 1);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.Kurtosis <109, 109>
double variance = ThirdMoment.m2 / (ThirdMoment.n - 1);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator <140, 140>
final int n = (currentState == null) ? -1 : currentState.length;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator <140, 140>
final int intVar = (double[]Var == null) ? -1 : double[]Var.length;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator <140, 140>
final int n = (currentState == null) ? -1 : currentState.length;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator <162, 162>
final int n = (currentState == null) ? -1 : currentState.length;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator <162, 162>
final int intVar = (double[]Var == null) ? -1 : double[]Var.length;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator <162, 162>
final int n = (currentState == null) ? -1 : currentState.length;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <229, 229>
final int n = (currentState == null) ? -1 : currentState.length;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <229, 229>
final int intVar = (double[]Var == null) ? -1 : double[]Var.length;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <229, 229>
final int n = (currentState == null) ? -1 : currentState.length;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <262, 262>
final int n = (currentState == null) ? -1 : currentState.length;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <262, 262>
final int intVar = (double[]Var == null) ? -1 : double[]Var.length;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <262, 262>
final int n = (currentState == null) ? -1 : currentState.length;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.NelderMead <84, 84>
final RealPointValuePair secondBest = simplex[n-1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.NelderMead <84, 84>
final RealPointValuePair RealPointValuePair = RealPointValuePair[]Var[intVar-1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.NelderMead <84, 84>
final RealPointValuePair RealPointValuePair = simplex[n-1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.integration.RombergIntegrator <92, 92>
final double tIJm1 = currentRow[j - 1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.integration.RombergIntegrator <92, 92>
final double doubleVar = doubleVar[intVar - 1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.integration.RombergIntegrator <92, 92>
final double tIJm1 = currentRow[j - 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <127, 127>
double result = coefficients[n - 1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <127, 127>
double doubleVar = double[]Var[intVar - 1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <127, 127>
double result = coefficients[n - 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <329, 329>
final double medianResidual = sortedResiduals[n / 2];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <329, 329>
final double doubleVar = double[]Var[intVar / 2];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <329, 329>
final double medianResidual = sortedResiduals[n / 2];

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.QRDecompositionImpl <417, 417>
final double   factor = 1.0 / rDiag[j];

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.QRDecompositionImpl <417, 417>
final double   doubleVar = 1.0 / double[]Var[intVar];

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.QRDecompositionImpl <417, 417>
final double   factor = 1.0 / rDiag[j];

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SingularValueDecompositionImpl <147, 147>
final double lastMain = mainBidiagonal[n - 1];

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.SingularValueDecompositionImpl <147, 147>
final double doubleVar = double[]Var[intVar - 1];

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.SingularValueDecompositionImpl <147, 147>
final double lastMain = mainBidiagonal[n - 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <390, 390>
final int m = n / (i<<1);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <390, 390>
final int intVar = intVar / (intVar<<1);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <390, 390>
final int m = n / (i<<1);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <648, 648>
Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <648, 648>
Arrays.fill(double[]Var, intVar + 1, double[]Var.length, 0);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <648, 648>
Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <691, 691>
Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <691, 691>
Arrays.fill(double[]Var, intVar + 1, double[]Var.length, 0);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <691, 691>
Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <128, 128>
sumXX += dx * dx * (double) n / (n + 1d);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.SimpleRegression <128, 128>
doubleVar += doubleVar * doubleVar * (double) longVar / (longVar + 1d);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.SimpleRegression <128, 128>
sumXX += dx * dx * (double) n / (n + 1d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <129, 129>
sumYY += dy * dy * (double) n / (n + 1d);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.SimpleRegression <129, 129>
doubleVar += doubleVar * doubleVar * (double) longVar / (longVar + 1d);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.SimpleRegression <129, 129>
sumYY += dy * dy * (double) n / (n + 1d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <130, 130>
sumXY += dx * dy * (double) n / (n + 1d);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.SimpleRegression <130, 130>
doubleVar += doubleVar * doubleVar * (double) longVar / (longVar + 1d);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.SimpleRegression <130, 130>
sumXY += dx * dy * (double) n / (n + 1d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <161, 161>
sumXX -= dx * dx * (double) n / (n - 1d);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.SimpleRegression <161, 161>
doubleVar -= doubleVar * doubleVar * (double) longVar / (longVar - 1d);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.SimpleRegression <161, 161>
sumXX -= dx * dx * (double) n / (n - 1d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <162, 162>
sumYY -= dy * dy * (double) n / (n - 1d);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.SimpleRegression <162, 162>
doubleVar -= doubleVar * doubleVar * (double) longVar / (longVar - 1d);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.SimpleRegression <162, 162>
sumYY -= dy * dy * (double) n / (n - 1d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <163, 163>
sumXY -= dx * dy * (double) n / (n - 1d);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.SimpleRegression <163, 163>
doubleVar -= doubleVar * doubleVar * (double) longVar / (longVar - 1d);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.SimpleRegression <163, 163>
sumXY -= dx * dy * (double) n / (n - 1d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Kurtosis <114, 117>
kurtosis =
                        (n * (n + 1) * moment.m4 -
                                3 * moment.m2 * moment.m2 * (n - 1)) /
                                ((n - 1) * (n -2) * (n -3) * variance * variance);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Kurtosis <114, 117>
doubleVar =
                        (doubleVar * (doubleVar + 1) * ThirdMoment.m4 -
                                3 * ThirdMoment.m2 * ThirdMoment.m2 * (doubleVar - 1)) /
                                ((doubleVar - 1) * (doubleVar -2) * (doubleVar -3) * doubleVar * doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.Kurtosis <114, 117>
kurtosis =
                        (n * (n + 1) * ThirdMoment.m4 -
                                3 * ThirdMoment.m2 * ThirdMoment.m2 * (n - 1)) /
                                ((n - 1) * (n -2) * (n -3) * variance * variance);

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <860, 860>
sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <860, 860>
doubleVar    = (intVar == intVar) ? 0 : -double[]Var[4 * intVar - 2];

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <860, 860>
sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <89, 89>
double c = 1.0 / (n * (isBiasCorrected ? (n - 1) : n));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <89, 89>
double doubleVar = 1.0 / (longVar * (booleanVar ? (longVar - 1) : longVar));

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <89, 89>
double c = 1.0 / (n * (isBiasCorrected ? (n - 1) : n));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.AbstractRandomGenerator <160, 160>
int result = (int) (nextDouble() * n);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.AbstractRandomGenerator <160, 160>
int intVar = (int) (nextDouble() * intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.AbstractRandomGenerator <160, 160>
int result = (int) (nextDouble() * n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.complex.Complex <973, 973>
final double nthPhi = getArgument()/n;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.complex.Complex <973, 973>
final double doubleVar = getArgument()/intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.complex.Complex <973, 973>
final double nthPhi = getArgument()/n;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <366, 366>
int k = n >> 1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <366, 366>
int intVar = intVar >> 1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <366, 366>
int k = n >> 1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastCosineTransformer <239, 239>
double t1 = 0.5 * (f[0] - f[n]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastCosineTransformer <239, 239>
double doubleVar = 0.5 * (doubleVar[0] - doubleVar[intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastCosineTransformer <239, 239>
double t1 = 0.5 * (f[0] - f[n]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <471, 472>
return Math.sqrt(
            getMeanSquareError() * ((1d / (double) n) + (xbar * xbar) / sumXX));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.SimpleRegression <471, 472>
return Math.sqrt(
            getMeanSquareError() * ((1d / (double) longVar) + (doubleVar * doubleVar) / doubleVar));

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.SimpleRegression <471, 472>
return Math.sqrt(
            getMeanSquareError() * ((1d / (double) n) + (xbar * xbar) / sumXX));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics <614, 618>
if (n > 0) {
            throw MathRuntimeException.createIllegalStateException(
                    "{0} values have been added before statistic is configured",
                    n);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics <614, 618>
if (longVar > 0) {
            throw MathRuntimeException.createIllegalStateException(
                    "{0} values have been added before statistic is configured",
                    longVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics <614, 618>
if (n > 0) {
            throw MathRuntimeException.createIllegalStateException(
                    "{0} values have been added before statistic is configured",
                    n);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.SummaryStatistics <629, 633>
if (n > 0) {
            throw MathRuntimeException.createIllegalStateException(
                    "{0} values have been added before statistic is configured",
                    n);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.SummaryStatistics <629, 633>
if (longVar > 0) {
            throw MathRuntimeException.createIllegalStateException(
                    "{0} values have been added before statistic is configured",
                    longVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.SummaryStatistics <629, 633>
if (n > 0) {
            throw MathRuntimeException.createIllegalStateException(
                    "{0} values have been added before statistic is configured",
                    n);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.BitsStreamGenerator <124, 127>
if (n < 1) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "upper bound must be positive ({0})", n);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.BitsStreamGenerator <124, 127>
if (intVar < 1) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "upper bound must be positive ({0})", intVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.BitsStreamGenerator <124, 127>
if (n < 1) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "upper bound must be positive ({0})", n);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.AbstractRandomGenerator <156, 159>
if (n <= 0 ) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "upper bound must be positive ({0})", n);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.AbstractRandomGenerator <156, 159>
if (intVar <= 0 ) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "upper bound must be positive ({0})", intVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.AbstractRandomGenerator <156, 159>
if (n <= 0 ) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "upper bound must be positive ({0})", n);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.ZipfDistributionImpl <75, 79>
if (n <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "invalid number of elements {0} (must be positive)",
                    n);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.ZipfDistributionImpl <75, 79>
if (intVar <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "invalid number of elements {0} (must be positive)",
                    intVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.distribution.ZipfDistributionImpl <75, 79>
if (n <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "invalid number of elements {0} (must be positive)",
                    n);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.LaguerreSolver <256, 259>
if (n < 1) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "polynomial degree must be positive: degree={0}", n);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.solvers.LaguerreSolver <256, 259>
if (intVar < 1) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "polynomial degree must be positive: degree={0}", intVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.solvers.LaguerreSolver <256, 259>
if (n < 1) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "polynomial degree must be positive: degree={0}", n);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.LaguerreSolver <304, 307>
if (n < 1) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "polynomial degree must be positive: degree={0}", n);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.solvers.LaguerreSolver <304, 307>
if (intVar < 1) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "polynomial degree must be positive: degree={0}", intVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.solvers.LaguerreSolver <304, 307>
if (n < 1) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "polynomial degree must be positive: degree={0}", n);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <365, 369>
if (n < 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "must have n >= 0 for binomial coefficient (n,k), got n = {0}",
                  n);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <365, 369>
if (intVar < 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "must have n >= 0 for binomial coefficient (n,k), got n = {0}",
                  intVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <365, 369>
if (n < 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "must have n >= 0 for binomial coefficient (n,k), got n = {0}",
                  n);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <511, 515>
if (n < 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "must have n >= 0 for n!, got n = {0}",
                  n);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <511, 515>
if (intVar < 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "must have n >= 0 for n!, got n = {0}",
                  intVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <511, 515>
if (n < 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "must have n >= 0 for n!, got n = {0}",
                  n);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <544, 548>
if (n < 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "must have n >= 0 for n!, got n = {0}",
                  n);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <544, 548>
if (intVar < 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "must have n >= 0 for n!, got n = {0}",
                  intVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <544, 548>
if (n < 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "must have n >= 0 for n!, got n = {0}",
                  n);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <569, 573>
if (n < 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "must have n >= 0 for n!, got n = {0}",
                  n);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <569, 573>
if (intVar < 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "must have n >= 0 for n!, got n = {0}",
                  intVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <569, 573>
if (n < 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "must have n >= 0 for n!, got n = {0}",
                  n);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.complex.Complex <951, 955>
if (n <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "cannot compute nth root for null or negative n: {0}",
                    n);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.complex.Complex <951, 955>
if (intVar <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "cannot compute nth root for null or negative n: {0}",
                    intVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.complex.Complex <951, 955>
if (n <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "cannot compute nth root for null or negative n: {0}",
                    n);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <433, 437>
if (n <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "number of sample is not positive: {0}",
                    n);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <433, 437>
if (intVar <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "number of sample is not positive: {0}",
                    intVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <433, 437>
if (n <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "number of sample is not positive: {0}",
                    n);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <390, 390>
x = n * Math.sqrt(lambda + halfDelta) - 0.5d;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.RandomDataImpl <390, 390>
doubleVar = longVar * Math.sqrt(doubleVar + doubleVar) - 0.5d;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.RandomDataImpl <390, 390>
x = n * Math.sqrt(lambda + halfDelta) - 0.5d;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.FirstMoment <99, 101>
if (n == 0) {
            m1 = 0.0;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.FirstMoment <99, 101>
if (longVar == 0) {
            doubleVar = 0.0;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.FirstMoment <99, 101>
if (n == 0) {
            m1 = 0.0;
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <952, 954>
if (j > 0) {
                    res.append(",");
                }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractFieldMatrix <952, 954>
if (intVar > 0) {
                    StringBuffer.append(",");
                }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractFieldMatrix <952, 954>
if (j > 0) {
                    StringBuffer.append(",");
                }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1314, 1316>
if (j > 0) {
                        res.append(",");
                    }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <1314, 1316>
if (intVar > 0) {
                        StringBuffer.append(",");
                    }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <1314, 1316>
if (j > 0) {
                        StringBuffer.append(",");
                    }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <1004, 1006>
if (j > 0) {
                    res.append(",");
                }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <1004, 1006>
if (intVar > 0) {
                    StringBuffer.append(",");
                }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <1004, 1006>
if (j > 0) {
                    StringBuffer.append(",");
                }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <649, 649>
final boolean chooseLeft   = (oneFourthCount - 1) >= (n - threeFourthCount);

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <649, 649>
final boolean booleanVar   = (intVar - 1) >= (intVar - intVar);

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <649, 649>
final boolean chooseLeft   = (oneFourthCount - 1) >= (n - threeFourthCount);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <485, 485>
return (n > 0) && ((n & (n - 1)) == 0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <485, 485>
return (longVar > 0) && ((longVar & (longVar - 1)) == 0);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <485, 485>
return (n > 0) && ((n & (n - 1)) == 0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Variance <174, 174>
return moment.m2 / (moment.n);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Variance <174, 174>
return FirstMoment.m2 / (FirstMoment.n);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.Variance <174, 174>
return FirstMoment.m2 / (FirstMoment.n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <216, 216>
errfac[i] *= e / (j + 1);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <216, 216>
double[]Var[intVar] *= doubleVar / (intVar + 1);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <216, 216>
errfac[i] *= e / (j + 1);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <128, 130>
for (int j = n -2; j >=0; j--) {
            result = argument * result + coefficients[j];
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <128, 130>
for (int intVar = intVar -2; intVar >=0; intVar--) {
            doubleVar = doubleVar * doubleVar + double[]Var[intVar];
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <128, 130>
for (int j = n -2; j >=0; j--) {
            result = argument * result + coefficients[j];
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <654, 655>
throw MathRuntimeException.createIllegalArgumentException(
                  "permutation k ({0}) exceeds n ({1})", k, n);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.RandomDataImpl <654, 655>
throw MathRuntimeException.createIllegalArgumentException(
                  "permutation k ({0}) exceeds n ({1})", intVar, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.RandomDataImpl <654, 655>
throw MathRuntimeException.createIllegalArgumentException(
                  "permutation k ({0}) exceeds n ({1})", k, n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <361, 363>
throw MathRuntimeException.createIllegalArgumentException(
                "must have n >= k for binomial coefficient (n,k), got n = {0}, k = {1}",
                n, k);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <361, 363>
throw MathRuntimeException.createIllegalArgumentException(
                "must have n >= k for binomial coefficient (n,k), got n = {0}, k = {1}",
                intVar, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <361, 363>
throw MathRuntimeException.createIllegalArgumentException(
                "must have n >= k for binomial coefficient (n,k), got n = {0}, k = {1}",
                n, k);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.StatUtils <622, 622>
return (sum1 - (sum2 * sum2 / n)) / (n - 1);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.StatUtils <622, 622>
return (doubleVar - (doubleVar * doubleVar / intVar)) / (intVar - 1);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.StatUtils <622, 622>
return (sum1 - (sum2 * sum2 / n)) / (n - 1);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <396, 396>
v = -e - (n * n / 2) + c1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.RandomDataImpl <396, 396>
doubleVar = -doubleVar - (longVar * longVar / 2) + doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.RandomDataImpl <396, 396>
v = -e - (n * n / 2) + c1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <265, 265>
coefficients[n-1] += t * tc[n-1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <265, 265>
doubleVar[intVar-1] += doubleVar * double[]Var[intVar-1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <265, 265>
coefficients[n-1] += t * tc[n-1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastCosineTransformer <237, 237>
x[0] = 0.5 * (f[0] + f[n]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastCosineTransformer <237, 237>
double[]Var[0] = 0.5 * (doubleVar[0] + doubleVar[intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastCosineTransformer <237, 237>
x[0] = 0.5 * (f[0] + f[n]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <194, 194>
n = Math.max((int) (ratio * n), n + 1);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <194, 194>
intVar = Math.max((int) (doubleVar * intVar), intVar + 1);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <194, 194>
n = Math.max((int) (ratio * n), n + 1);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <186, 188>
throw MathRuntimeException.createIllegalArgumentException(
                        "dimension mismatch {0} != {1}",
                        refI.length, n);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <186, 188>
throw MathRuntimeException.createIllegalArgumentException(
                        "dimension mismatch {0} != {1}",
                        double[]Var.length, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <186, 188>
throw MathRuntimeException.createIllegalArgumentException(
                        "dimension mismatch {0} != {1}",
                        refI.length, n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <362, 364>
throw MathRuntimeException.createIllegalArgumentException(
                    "dimension mismatch {0} != {1}",
                    n, startConfiguration.length);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <362, 364>
throw MathRuntimeException.createIllegalArgumentException(
                    "dimension mismatch {0} != {1}",
                    intVar, double[][]Var.length);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <362, 364>
throw MathRuntimeException.createIllegalArgumentException(
                    "dimension mismatch {0} != {1}",
                    n, startConfiguration.length);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <1288, 1290>
throw MathRuntimeException.createIllegalArgumentException(
                    "vector length mismatch: got {0} but expected {1}",
                    data.length, n);

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <1288, 1290>
throw MathRuntimeException.createIllegalArgumentException(
                    "vector length mismatch: got {0} but expected {1}",
                    doubleVar.length, intVar);

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.ArrayRealVector <1288, 1290>
throw MathRuntimeException.createIllegalArgumentException(
                    "vector length mismatch: got {0} but expected {1}",
                    data.length, n);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <717, 719>
throw MathRuntimeException.createIllegalArgumentException(
                    "vector length mismatch: got {0} but expected {1}",
                    data.length, n);

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayFieldVector <717, 719>
throw MathRuntimeException.createIllegalArgumentException(
                    "vector length mismatch: got {0} but expected {1}",
                    T[]Var.length, intVar);

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.ArrayFieldVector <717, 719>
throw MathRuntimeException.createIllegalArgumentException(
                    "vector length mismatch: got {0} but expected {1}",
                    data.length, n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer <245, 245>
pI[j] = new BigFraction(aj * (j + 2));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer <245, 245>
BigFraction[]Var[intVar] = new BigFraction(intVar * (intVar + 2));

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer <245, 245>
pI[j] = new BigFraction(aj * (j + 2));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <216, 216>
System.arraycopy(y0, 0, y, 0, n);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <216, 216>
System.arraycopy(double[]Var, 0, double[]Var, 0, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <216, 216>
System.arraycopy(y0, 0, y, 0, n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <318, 318>
System.arraycopy(yTmp, 0, y, 0, n);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <318, 318>
System.arraycopy(double[]Var, 0, double[]Var, 0, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <318, 318>
System.arraycopy(yTmp, 0, y, 0, n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <198, 198>
System.arraycopy(y0, 0, y, 0, n);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <198, 198>
System.arraycopy(double[]Var, 0, double[]Var, 0, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <198, 198>
System.arraycopy(y0, 0, y, 0, n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <300, 300>
System.arraycopy(yTmp, 0, y, 0, n);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <300, 300>
System.arraycopy(double[]Var, 0, double[]Var, 0, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <300, 300>
System.arraycopy(yTmp, 0, y, 0, n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.ranking.NaturalRanking <277, 277>
System.arraycopy(outRanks, 0, returnRanks, 0, j);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.ranking.NaturalRanking <277, 277>
System.arraycopy(IntDoublePair[]Var, 0, IntDoublePair[]Var, 0, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.ranking.NaturalRanking <277, 277>
System.arraycopy(outRanks, 0, returnRanks, 0, j);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <117, 117>
System.arraycopy(polynomials, 0, this.polynomials, 0, n);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <117, 117>
System.arraycopy(PolynomialFunction, 0, PolynomialSplineFunction.PolynomialFunction, 0, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <117, 117>
System.arraycopy(PolynomialFunction, 0, PolynomialSplineFunction.PolynomialFunction, 0, n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <193, 193>
System.arraycopy(polynomials, 0, p, 0, n);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <193, 193>
System.arraycopy(PolynomialFunction, 0, PolynomialFunction, 0, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <193, 193>
System.arraycopy(PolynomialFunction, 0, PolynomialFunction, 0, n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <327, 327>
System.arraycopy(residuals, 0, sortedResiduals, 0, n);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <327, 327>
System.arraycopy(double[]Var, 0, double[]Var, 0, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <327, 327>
System.arraycopy(residuals, 0, sortedResiduals, 0, n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <824, 824>
extrapolate(0, j, diagonal, yMidDots[0]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <824, 824>
extrapolate(0, intVar, double[][]Var, double[][]Var[0]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <824, 824>
extrapolate(0, j, diagonal, yMidDots[0]);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <93, 93>
final int diagOffset    = (m >= n) ? 0 : 1;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <93, 93>
final int intVar    = (intVar >= intVar) ? 0 : 1;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <93, 93>
final int diagOffset    = (m >= n) ? 0 : 1;

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <174, 174>
final int diagOffset    = (m >= n) ? 1 : 0;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <174, 174>
final int intVar    = (intVar >= intVar) ? 1 : 0;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <174, 174>
final int diagOffset    = (m >= n) ? 1 : 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.HighamHall54Integrator <112, 112>
double errSum = STATIC_E[0] * yDotK[0][j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.HighamHall54Integrator <112, 112>
double doubleVar = double[]Var[0] * double[][]Var[0][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.HighamHall54Integrator <112, 112>
double errSum = STATIC_E[0] * yDotK[0][j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <472, 472>
final double subStep  = step / n;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <472, 472>
final double doubleVar  = doubleVar / intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <472, 472>
final double subStep  = step / n;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.AbstractEstimator <221, 221>
final int max  = m * n;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.AbstractEstimator <221, 221>
final int intVar  = intVar * intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.AbstractEstimator <221, 221>
final int max  = m * n;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <225, 225>
int bandwidthInPoints = (int) (bandwidth * n);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <225, 225>
int intVar = (int) (doubleVar * intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <225, 225>
int bandwidthInPoints = (int) (bandwidth * n);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.OpenMapRealVector <390, 390>
int end = index + n;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.OpenMapRealVector <390, 390>
int intVar = intVar + intVar;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.OpenMapRealVector <390, 390>
int end = index + n;

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.QRDecompositionImpl <415, 415>
final int      jBlock = j / blockSize;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.QRDecompositionImpl <415, 415>
final int      intVar = intVar / intVar;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.QRDecompositionImpl <415, 415>
final int      jBlock = j / blockSize;

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SparseFieldVector <322, 322>
int end = index + n;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.SparseFieldVector <322, 322>
int intVar = intVar + intVar;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.SparseFieldVector <322, 322>
int end = index + n;

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <623, 623>
final int n = end - begin;

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <623, 623>
final int intVar = intVar - intVar;

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <623, 623>
final int n = end - begin;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.CompositeFormat <119, 119>
final int endIndex = startIndex + n;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.CompositeFormat <119, 119>
final int intVar = intVar + intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.CompositeFormat <119, 119>
final int endIndex = startIndex + n;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <595, 595>
return (sumY - slope * sumX) / n;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.SimpleRegression <595, 595>
return (doubleVar - doubleVar * doubleVar) / longVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.SimpleRegression <595, 595>
return (sumY - slope * sumX) / n;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <141, 141>
out[i][j] = Math.sqrt((1 - r * r) /(nObs - 2));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <141, 141>
double[][]Var[intVar][intVar] = Math.sqrt((1 - doubleVar * doubleVar) /(intVar - 2));

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <141, 141>
out[i][j] = Math.sqrt((1 - r * r) /(nObs - 2));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastSineTransformer <224, 227>
if (n == 1) {       // trivial case
            transformed[0] = 0.0;
            return transformed;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastSineTransformer <224, 227>
if (intVar == 1) {       // trivial case
            doubleVar[0] = 0.0;
            return doubleVar;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastSineTransformer <224, 227>
if (n == 1) {       // trivial case
            transformed[0] = 0.0;
            return transformed;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <171, 171>
out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <171, 171>
double[][]Var[intVar][intVar] = 2 * (1 - TDistribution.cumulativeProbability(doubleVar));

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <171, 171>
out[i][j] = 2 * (1 - TDistribution.cumulativeProbability(t));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.TTestImpl <907, 907>
return (m - mu) / Math.sqrt(v / n);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.inference.TTestImpl <907, 907>
return (doubleVar - doubleVar) / Math.sqrt(doubleVar / doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.inference.TTestImpl <907, 907>
return (m - mu) / Math.sqrt(v / n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastSineTransformer <232, 232>
x[n >> 1] = 2.0 * f[n >> 1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastSineTransformer <232, 232>
double[]Var[intVar >> 1] = 2.0 * doubleVar[intVar >> 1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastSineTransformer <232, 232>
x[n >> 1] = 2.0 * f[n >> 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.events.EventState <173, 173>
final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.events.EventState <173, 173>
final int    intVar  = Math.max(1, (int) Math.ceil(Math.abs(doubleVar - doubleVar) / doubleVar));

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.events.EventState <173, 173>
final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <498, 498>
computeDerivatives(t, yEnd, f[j+1]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <498, 498>
computeDerivatives(doubleVar, double[]Var, double[][]Var[intVar+1]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <498, 498>
computeDerivatives(t, yEnd, f[j+1]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.events.EventState <174, 174>
final double h  = (t1 - t0) / n;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.events.EventState <174, 174>
final double doubleVar  = (doubleVar - doubleVar) / intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.events.EventState <174, 174>
final double h  = (t1 - t0) / n;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <218, 218>
final double step     = (max - min) / n;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <218, 218>
final double doubleVar     = (doubleVar - doubleVar) / intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <218, 218>
final double step     = (max - min) / n;

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.QRDecompositionImpl <420, 420>
int index = (j - jStart) * kWidth;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.QRDecompositionImpl <420, 420>
int intVar = (intVar - intVar) * intVar;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.QRDecompositionImpl <420, 420>
int index = (j - jStart) * kWidth;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <441, 441>
double h = (max - min) / n;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <441, 441>
double doubleVar = (doubleVar - doubleVar) / intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <441, 441>
double h = (max - min) / n;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <843, 843>
middleIndex = fk[l2+j].length / 2;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <843, 843>
intVar = fk[l2 + j].length / 2;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <843, 843>
middleIndex = fk[l2 + j].length / 2;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <193, 195>
if ((k == 1) || (k == n - 1)) {
            return n;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <193, 195>
if ((intVar == 1) || (intVar == intVar - 1)) {
            return intVar;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <193, 195>
if ((k == 1) || (k == n - 1)) {
            return n;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <269, 271>
if ((k == 1) || (k == n - 1)) {
            return n;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <269, 271>
if ((intVar == 1) || (intVar == intVar - 1)) {
            return intVar;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <269, 271>
if ((k == 1) || (k == n - 1)) {
            return n;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.AggregateSummaryStatistics <329, 329>
mean = sum / n;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.AggregateSummaryStatistics <329, 329>
doubleVar = doubleVar / longVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.AggregateSummaryStatistics <329, 329>
mean = sum / n;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <663, 663>
shuffle(index, n - k);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.RandomDataImpl <663, 663>
shuffle(int[]Var, intVar - intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.RandomDataImpl <663, 663>
shuffle(index, n - k);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <91, 91>
final int n = householderVectors[0].length;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <91, 91>
final int intVar = householderVectors[0].length;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <91, 91>
final int n = householderVectors[0].length;

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <140, 140>
final int n = householderVectors[0].length;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <140, 140>
final int intVar = householderVectors[0].length;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <140, 140>
final int n = householderVectors[0].length;

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <172, 172>
final int n = householderVectors[0].length;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <172, 172>
final int intVar = householderVectors[0].length;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <172, 172>
final int n = householderVectors[0].length;

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <258, 258>
final int n = householderVectors[0].length;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <258, 258>
final int intVar = householderVectors[0].length;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <258, 258>
final int n = householderVectors[0].length;

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <322, 322>
final int n = householderVectors[0].length;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <322, 322>
final int intVar = householderVectors[0].length;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <322, 322>
final int n = householderVectors[0].length;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.AbstractRandomGenerator <161, 161>
return result < n ? result : n - 1;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.AbstractRandomGenerator <161, 161>
return intVar < intVar ? intVar : intVar - 1;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.AbstractRandomGenerator <161, 161>
return result < n ? result : n - 1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <210, 210>
result = result * i / j;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <210, 210>
longVar = longVar * intVar / intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <210, 210>
result = result * i / j;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <93, 93>
double e = c * (n * productsSums[k++] - sums[i] * sums[j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <93, 93>
double doubleVar = doubleVar * (longVar * double[]Var[intVar++] - double[]Var[intVar] * double[]Var[intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <93, 93>
double e = c * (n * productsSums[k++] - sums[i] * sums[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.FDistributionImpl <79, 81>
ret = Beta.regularizedBeta((n * x) / (m + n * x),
                0.5 * n,
                0.5 * m);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.FDistributionImpl <79, 81>
doubleVar = Beta.regularizedBeta((doubleVar * doubleVar) / (doubleVar + doubleVar * doubleVar),
                0.5 * doubleVar,
                0.5 * doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.distribution.FDistributionImpl <79, 81>
ret = Beta.regularizedBeta((n * x) / (m + n * x),
                0.5 * n,
                0.5 * m);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <310, 312>
if ((k == 1) || (k == n - 1)) {
            return Math.log(n);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <310, 312>
if ((intVar == 1) || (intVar == intVar - 1)) {
            return Math.log(intVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <310, 312>
if ((k == 1) || (k == n - 1)) {
            return Math.log(n);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <221, 223>
if (n == 2) {
            return new double[]{yval[0], yval[1]};
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <221, 223>
if (intVar == 2) {
            return new double[]{double[]Var[0], double[]Var[1]};
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <221, 223>
if (n == 2) {
            return new double[]{yval[0], yval[1]};
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <197, 198>
if (k > n / 2)
            return binomialCoefficient(n, n - k);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <197, 198>
if (intVar > intVar / 2)
            return binomialCoefficient(intVar, intVar - intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <197, 198>
if (k > n / 2)
            return binomialCoefficient(n, n - k);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <272, 274>
if (k > n/2) {
            return binomialCoefficientDouble(n, n - k);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <272, 274>
if (intVar > intVar/2) {
            return binomialCoefficientDouble(intVar, intVar - intVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <272, 274>
if (k > n/2) {
            return binomialCoefficientDouble(n, n - k);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <330, 332>
if (k > n / 2) {
            return binomialCoefficientLog(n, n - k);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <330, 332>
if (intVar > intVar / 2) {
            return binomialCoefficientLog(intVar, intVar - intVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <330, 332>
if (k > n / 2) {
            return binomialCoefficientLog(n, n - k);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.rank.Percentile <222, 224>
if (pos >= n) {
            return sorted[length - 1];
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.rank.Percentile <222, 224>
if (doubleVar >= doubleVar) {
            return double[]Var[intVar - 1];
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.rank.Percentile <222, 224>
if (pos >= n) {
            return sorted[length - 1];
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <150, 150>
double sum = a[k-1][0] * yDotK[0][j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <150, 150>
double doubleVar = double[][]Var[intVar-1][0] * double[][]Var[0][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <150, 150>
double sum = a[k-1][0] * yDotK[0][j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <265, 265>
double sum = a[k-1][0] * yDotK[0][j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <265, 265>
double doubleVar = double[][]Var[intVar-1][0] * double[][]Var[0][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <265, 265>
double sum = a[k-1][0] * yDotK[0][j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <163, 163>
double sum    = b[0] * yDotK[0][j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <163, 163>
double doubleVar    = double[]Var[0] * double[][]Var[0][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <163, 163>
double sum    = b[0] * yDotK[0][j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <278, 278>
double sum    = b[0] * yDotK[0][j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <278, 278>
double doubleVar    = double[]Var[0] * double[][]Var[0][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <278, 278>
double sum    = b[0] * yDotK[0][j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <842, 842>
factor = Math.pow(0.5 * sequence[j + l2], l);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <842, 842>
doubleVar = Math.pow(0.5 * int[]Var[intVar + intVar], intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <842, 842>
factor = Math.pow(0.5 * sequence[j + l2], l);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.QRDecompositionImpl <439, 439>
return new BlockRealMatrix(n, columns, xBlocks, false);

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.QRDecompositionImpl <439, 439>
return new BlockRealMatrix(intVar, intVar, double[][]Var, false);

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.QRDecompositionImpl <439, 439>
return new BlockRealMatrix(n, columns, xBlocks, false);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <198, 198>
final double w = (c[j+1] - d[j]) / divider;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <198, 198>
final double doubleVar = (double[]Var[intVar+1] - double[]Var[intVar]) / doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <198, 198>
final double w = (c[j+1] - d[j]) / divider;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastCosineTransformer <241, 241>
final double a = 0.5 * (f[i] + f[n-i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastCosineTransformer <241, 241>
final double doubleVar = 0.5 * (doubleVar[intVar] + doubleVar[intVar-intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastCosineTransformer <241, 241>
final double a = 0.5 * (f[i] + f[n-i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastSineTransformer <235, 235>
final double b = 0.5 * (f[i] - f[n-i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastSineTransformer <235, 235>
final double doubleVar = 0.5 * (doubleVar[intVar] - doubleVar[intVar-intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastSineTransformer <235, 235>
final double b = 0.5 * (f[i] - f[n-i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <127, 127>
result = prime * result + (int) (n ^ (n >>> 32));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <127, 127>
intVar = intVar * intVar + (int) (longVar ^ (longVar >>> 32));

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <127, 127>
result = prime * result + (int) (n ^ (n >>> 32));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.special.Gamma <181, 181>
an = an * (x / (a + n));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.special.Gamma <181, 181>
doubleVar = doubleVar * (doubleVar / (doubleVar + doubleVar));

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.special.Gamma <181, 181>
an = an * (x / (a + n));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <281, 281>
result *= (double)(n - k + i) / (double)i;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <281, 281>
doubleVar *= (double)(intVar - intVar + intVar) / (double)intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <281, 281>
result *= (double)(n - k + i) / (double)i;

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SingularValueDecompositionImpl <303, 303>
final double threshold = Math.max(m, n) * Math.ulp(singularValues[0]);

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.SingularValueDecompositionImpl <303, 303>
final double doubleVar = Math.max(intVar, intVar) * Math.ulp(double[]Var[0]);

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.SingularValueDecompositionImpl <303, 303>
final double threshold = Math.max(m, n) * Math.ulp(singularValues[0]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.SecondMoment <77, 79>
if (n < 1) {
            m1 = m2 = 0.0;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.SecondMoment <77, 79>
if (longVar < 1) {
            doubleVar = doubleVar = 0.0;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.SecondMoment <77, 79>
if (n < 1) {
            m1 = m2 = 0.0;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.SaddlePointExpansion <183, 183>
ret = n * Math.log(q);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.SaddlePointExpansion <183, 183>
doubleVar = intVar * Math.log(doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.distribution.SaddlePointExpansion <183, 183>
ret = n * Math.log(q);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <264, 264>
tc[n-1] = c[n];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <264, 264>
double[]Var[intVar-1] = double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <264, 264>
tc[n-1] = c[n];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastCosineTransformer <229, 233>
if (n == 1) {       // trivial case
            transformed[0] = 0.5 * (f[0] + f[1]);
            transformed[1] = 0.5 * (f[0] - f[1]);
            return transformed;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastCosineTransformer <229, 233>
if (intVar == 1) {       // trivial case
            doubleVar[0] = 0.5 * (doubleVar[0] + doubleVar[1]);
            doubleVar[1] = 0.5 * (doubleVar[0] - doubleVar[1]);
            return doubleVar;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastCosineTransformer <229, 233>
if (n == 1) {       // trivial case
            transformed[0] = 0.5 * (f[0] + f[1]);
            transformed[1] = 0.5 * (f[0] - f[1]);
            return transformed;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.integration.RombergIntegrator <93, 93>
currentRow[j] = tIJm1 + (tIJm1 - previousRow[j - 1]) / r;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.integration.RombergIntegrator <93, 93>
doubleVar[intVar] = doubleVar + (doubleVar - doubleVar[intVar - 1]) / doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.integration.RombergIntegrator <93, 93>
currentRow[j] = tIJm1 + (tIJm1 - previousRow[j - 1]) / r;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <225, 225>
result = (result / (j / d)) * (i / d);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <225, 225>
longVar = (longVar / (intVar / longVar)) * (intVar / longVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <225, 225>
result = (result / (j / d)) * (i / d);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <300, 302>
for (int j = k + 1; j < n; ++j) {
                            beta -= hI[j] * hK[j];
                        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <300, 302>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                            doubleVar -= double[]Var[intVar] * double[]Var[intVar];
                        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <300, 302>
for (int j = k + 1; j < n; ++j) {
                            beta -= hI[j] * hK[j];
                        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <304, 306>
for (int j = k + 1; j < n; ++j) {
                            hI[j] -= beta * hK[j];
                        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <304, 306>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                            double[]Var[intVar] -= doubleVar * double[]Var[intVar];
                        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <304, 306>
for (int j = k + 1; j < n; ++j) {
                            hI[j] -= beta * hK[j];
                        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <352, 355>
if (n == 1) {
            f[0] = data[0];
            return f;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <352, 355>
if (intVar == 1) {
            Complex[0] = Complex[0];
            return Complex;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <352, 355>
if (n == 1) {
            Complex[0] = Complex[0];
            return Complex;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <847, 847>
extrapolate(l2, j, diagonal, yMidDots[l+1]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <847, 847>
extrapolate(intVar, intVar, double[][]Var, double[][]Var[intVar+1]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <847, 847>
extrapolate(l2, j, diagonal, yMidDots[l+1]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.MersenneTwister <171, 171>
long l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1664525l)) + seed[j] + j;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.MersenneTwister <171, 171>
long longVar  = (longVar ^ ((longVar ^ (longVar >> 30)) * 1664525l)) + int[]Var[intVar] + intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.MersenneTwister <171, 171>
long l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1664525l)) + seed[j] + j;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.SaddlePointExpansion <181, 181>
ret = -getDeviancePart(n, n * q) - n * p;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.SaddlePointExpansion <181, 181>
doubleVar = -getDeviancePart(intVar, intVar * doubleVar) - intVar * doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.distribution.SaddlePointExpansion <181, 181>
ret = -getDeviancePart(n, n * q) - n * p;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.HypergeometricDistributionImpl <301, 301>
ret = innerCumulativeProbability(domain[1], x, -1, n, m, k);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.HypergeometricDistributionImpl <301, 301>
doubleVar = innerCumulativeProbability(int[]Var[1], intVar, -1, intVar, intVar, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.distribution.HypergeometricDistributionImpl <301, 301>
ret = innerCumulativeProbability(domain[1], x, -1, n, m, k);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SingularValueDecompositionImpl <148, 150>
for (int j = 0; j < n; ++j) {
                    ei1[j] *= lastMain / singularValues[j];
                }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.SingularValueDecompositionImpl <148, 150>
for (int intVar = 0; intVar < intVar; ++intVar) {
                    double[]Var[intVar] *= doubleVar / double[]Var[intVar];
                }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.SingularValueDecompositionImpl <148, 150>
for (int j = 0; j < n; ++j) {
                    ei1[j] *= lastMain / singularValues[j];
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator <166, 166>
yDotK[k] = (n < 0) ? null : new double[n];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator <166, 166>
double[][]Var[intVar] = (intVar < 0) ? null : new double[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator <166, 166>
yDotK[k] = (n < 0) ? null : new double[n];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <739, 739>
int index = j * cols + permutation[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <739, 739>
int intVar = intVar * intVar + int[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <739, 739>
int index = j * cols + permutation[j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <240, 242>
for (int i = n - 1; i  > 0; i--) {
            result[i - 1] = i * coefficients[i];
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <240, 242>
for (int intVar = intVar - 1; intVar  > 0; intVar--) {
            double[]Var[intVar - 1] = intVar * double[]Var[intVar];
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <240, 242>
for (int i = n - 1; i  > 0; i--) {
            result[i - 1] = i * coefficients[i];
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastCosineTransformer <242, 242>
final double b = Math.sin(i * Math.PI / n) * (f[i] - f[n-i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastCosineTransformer <242, 242>
final double doubleVar = Math.sin(intVar * Math.PI / intVar) * (doubleVar[intVar] - doubleVar[intVar-intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastCosineTransformer <242, 242>
final double b = Math.sin(i * Math.PI / n) * (f[i] - f[n-i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastCosineTransformer <243, 243>
final double c = Math.cos(i * Math.PI / n) * (f[i] - f[n-i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastCosineTransformer <243, 243>
final double doubleVar = Math.cos(intVar * Math.PI / intVar) * (doubleVar[intVar] - doubleVar[intVar-intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastCosineTransformer <243, 243>
final double c = Math.cos(i * Math.PI / n) * (f[i] - f[n-i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastSineTransformer <234, 234>
final double a = Math.sin(i * Math.PI / n) * (f[i] + f[n-i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastSineTransformer <234, 234>
final double doubleVar = Math.sin(intVar * Math.PI / intVar) * (doubleVar[intVar] + doubleVar[intVar-intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastSineTransformer <234, 234>
final double a = Math.sin(i * Math.PI / n) * (f[i] + f[n-i]);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <289, 292>
for (int j = k + 1; j < n; ++j) {
                    final double c = hK[j];
                    xNormSqr += c * c;
                }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <289, 292>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                    final double c = double[]Var[intVar];
                    doubleVar += c * c;
                }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <289, 292>
for (int j = k + 1; j < n; ++j) {
                    final double c = hK[j];
                    xNormSqr += c * c;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <202, 202>
final double d = nDataI[j] * power;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <202, 202>
final double doubleVar = double[]Var[intVar] * doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <202, 202>
final double d = nDataI[j] * power;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.LaguerreSolver <272, 272>
Complex newc = c[n-i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.solvers.LaguerreSolver <272, 272>
Complex Complex = Complex[intVar-intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.solvers.LaguerreSolver <272, 272>
Complex Complex = Complex[n-i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastSineTransformer <245, 248>
for (int i = 1; i < (n >> 1); i++) {
            transformed[2 * i]     = -y[i].getImaginary();
            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastSineTransformer <245, 248>
for (int intVar = 1; intVar < (intVar >> 1); intVar++) {
            doubleVar[2 * intVar]     = -Complex[intVar].getImaginary();
            doubleVar[2 * intVar + 1] = Complex[intVar].getReal() + doubleVar[2 * intVar - 1];
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastSineTransformer <245, 248>
for (int i = 1; i < (n >> 1); i++) {
            transformed[2 * i]     = -Complex[i].getImaginary();
            transformed[2 * i + 1] = Complex[i].getReal() + transformed[2 * i - 1];
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.ProperFractionFormat <217, 217>
return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.fraction.ProperFractionFormat <217, 217>
return new Fraction(((Math.abs(intVar) * intVar) + intVar) * MathUtils.sign(intVar), intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.fraction.ProperFractionFormat <217, 217>
return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastCosineTransformer <245, 245>
x[n-i] = a + b;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastCosineTransformer <245, 245>
double[]Var[intVar-intVar] = doubleVar + doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastCosineTransformer <245, 245>
x[n-i] = a + b;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastSineTransformer <237, 237>
x[n - i] = a - b;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastSineTransformer <237, 237>
double[]Var[intVar - intVar] = doubleVar - doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastSineTransformer <237, 237>
x[n - i] = a - b;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <235, 235>
result = mulAndCheck(result / (j / d), i / d);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <235, 235>
longVar = mulAndCheck(longVar / (intVar / longVar), intVar / longVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <235, 235>
result = mulAndCheck(result / (j / d), i / d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <267, 267>
tc[j] = c[j+1] + tc[j+1] * x[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <267, 267>
double[]Var[intVar] = double[]Var[intVar+1] + double[]Var[intVar+1] * doubleVar[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <267, 267>
tc[j] = c[j+1] + tc[j+1] * x[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <109, 109>
d[j] = (c[j + 1] - c[j]) / (3d * h[j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <109, 109>
doubleVar[intVar] = (doubleVar[intVar + 1] - doubleVar[intVar]) / (3d * doubleVar[intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <109, 109>
d[j] = (c[j + 1] - c[j]) / (3d * h[j]);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.QRDecompositionImpl <232, 234>
for (int j = 0; j < Math.min(i + 1, n); ++j) {
                    cachedH.setEntry(i, j, qrt[j][i] / -rDiag[j]);
                }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.QRDecompositionImpl <232, 234>
for (int intVar = 0; intVar < Math.min(intVar + 1, intVar); ++intVar) {
                    RealMatrix.setEntry(intVar, intVar, double[][]Var[intVar][intVar] / -double[]Var[intVar]);
                }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.QRDecompositionImpl <232, 234>
for (int j = 0; j < Math.min(i + 1, n); ++j) {
                    RealMatrix.setEntry(i, j, qrt[j][i] / -rDiag[j]);
                }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <828, 832>
for (int i = 0; i < n - 1; ++i) {
            final int fourI = 4 * i;
            final double ei = work[fourI + 2];
            sumOffDiag += ei;
        }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <828, 832>
for (int intVar = 0; intVar < intVar - 1; ++intVar) {
            final int fourI = 4 * intVar;
            final double ei = double[]Var[fourI + 2];
            doubleVar += ei;
        }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <828, 832>
for (int i = 0; i < n - 1; ++i) {
            final int fourI = 4 * i;
            final double ei = work[fourI + 2];
            sumOffDiag += ei;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastCosineTransformer <254, 257>
for (int i = 1; i < (n >> 1); i++) {
            transformed[2 * i]     = y[i].getReal();
            transformed[2 * i + 1] = transformed[2 * i - 1] - y[i].getImaginary();
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastCosineTransformer <254, 257>
for (int intVar = 1; intVar < (intVar >> 1); intVar++) {
            doubleVar[2 * intVar]     = Complex[intVar].getReal();
            doubleVar[2 * intVar + 1] = doubleVar[2 * intVar - 1] - Complex[intVar].getImaginary();
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastCosineTransformer <254, 257>
for (int i = 1; i < (n >> 1); i++) {
            transformed[2 * i]     = Complex[i].getReal();
            transformed[2 * i + 1] = transformed[2 * i - 1] - Complex[i].getImaginary();
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <675, 675>
sum += Math.abs(block[i * jWidth + j]);

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockRealMatrix <675, 675>
doubleVar += Math.abs(double[]Var[intVar * intVar + intVar]);

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BlockRealMatrix <675, 675>
sum += Math.abs(block[i * jWidth + j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <204, 204>
interpolatedDerivatives[j] += order * d;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <204, 204>
double[]Var[intVar] += intVar * doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <204, 204>
interpolatedDerivatives[j] += order * d;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.GaussNewtonEstimator <187, 187>
bDecrementData[j] = weight * residual * grad[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.GaussNewtonEstimator <187, 187>
double[]Var[intVar] = doubleVar * doubleVar * double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.GaussNewtonEstimator <187, 187>
bDecrementData[j] = weight * residual * grad[j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <199, 199>
c[j] = tc * w;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <199, 199>
double[]Var[intVar] = doubleVar * doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <199, 199>
c[j] = tc * w;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <200, 200>
d[j] = td * w;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <200, 200>
double[]Var[intVar] = doubleVar * doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <200, 200>
d[j] = td * w;

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1173, 1173>
final double margin = 2 * (tNorm * MathUtils.EPSILON * n + 2 * minPivot);

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <1173, 1173>
final double doubleVar = 2 * (doubleVar * MathUtils.EPSILON * intVar + 2 * doubleVar);

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1173, 1173>
final double margin = 2 * (tNorm * MathUtils.EPSILON * n + 2 * minPivot);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastHadamardTransformer <191, 191>
yCurrent[i] = yPrevious[twoI - n] - yPrevious[twoI - n + 1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastHadamardTransformer <191, 191>
double[]Var[intVar] = double[]Var[intVar - intVar] - double[]Var[intVar - intVar + 1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastHadamardTransformer <191, 191>
yCurrent[i] = yPrevious[twoI - n] - yPrevious[twoI - n + 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastHadamardTransformer <242, 242>
yCurrent[i] = yPrevious[twoI - n] - yPrevious[twoI - n + 1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastHadamardTransformer <242, 242>
int[]Var[intVar] = int[]Var[intVar - intVar] - int[]Var[intVar - intVar + 1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastHadamardTransformer <242, 242>
yCurrent[i] = yPrevious[twoI - n] - yPrevious[twoI - n + 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolator <110, 110>
divdiff[j] = (divdiff[j+1] - divdiff[j]) / denominator;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolator <110, 110>
double[]Var[intVar] = (double[]Var[intVar+1] - double[]Var[intVar]) / doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolator <110, 110>
divdiff[j] = (divdiff[j+1] - divdiff[j]) / denominator;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.FourthMoment <85, 90>
if (n < 1) {
            m4 = 0.0;
            m3 = 0.0;
            m2 = 0.0;
            m1 = 0.0;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.FourthMoment <85, 90>
if (longVar < 1) {
            doubleVar = 0.0;
            doubleVar = 0.0;
            doubleVar = 0.0;
            doubleVar = 0.0;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.FourthMoment <85, 90>
if (n < 1) {
            m4 = 0.0;
            m3 = 0.0;
            m2 = 0.0;
            m1 = 0.0;
        }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <942, 949>
for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) {
                if (work[i + 2] <= TOLERANCE_2 * d) {
                    work[i + 2] = -0.0;
                    d = work[i];
                } else {
                    d *= work[i] / (d + work[i + 2]);
                }
            }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <942, 949>
for (int intVar = 4 * (intVar - 2) + intVar; intVar >= 0; intVar -= 4) {
                if (double[]Var[intVar + 2] <= doubleVar * doubleVar) {
                    double[]Var[intVar + 2] = -0.0;
                    doubleVar = double[]Var[intVar];
                } else {
                    doubleVar *= double[]Var[intVar] / (doubleVar + double[]Var[intVar + 2]);
                }
            }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <942, 949>
for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) {
                if (work[i + 2] <= TOLERANCE_2 * d) {
                    work[i + 2] = -0.0;
                    d = work[i];
                } else {
                    d *= work[i] / (d + work[i + 2]);
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.summary.SumOfSquares <72, 76>
if (n == 0) {
            value = d * d;
        } else {
            value += d * d;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.summary.SumOfSquares <72, 76>
if (longVar == 0) {
            doubleVar = doubleVar * doubleVar;
        } else {
            doubleVar += doubleVar * doubleVar;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.summary.SumOfSquares <72, 76>
if (n == 0) {
            value = d * d;
        } else {
            value += d * d;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <108, 108>
b[j] = (y[j + 1] - y[j]) / h[j] - h[j] * (c[j + 1] + 2d * c[j]) / 3d;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <108, 108>
doubleVar[intVar] = (doubleVar[intVar + 1] - doubleVar[intVar]) / doubleVar[intVar] - doubleVar[intVar] * (doubleVar[intVar + 1] + 2d * doubleVar[intVar]) / 3d;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <108, 108>
b[j] = (y[j + 1] - y[j]) / h[j] - h[j] * (c[j + 1] + 2d * c[j]) / 3d;

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <196, 196>
cachedV.addToEntry(i, j, -beta * hK[i]);

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <196, 196>
RealMatrix.addToEntry(intVar, intVar, -doubleVar * double[]Var[intVar]);

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <196, 196>
RealMatrix.addToEntry(i, j, -beta * hK[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.MultiDirectional <133, 135>
for (int j = 0; j < n; ++j) {
                xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.MultiDirectional <133, 135>
for (int intVar = 0; intVar < intVar; ++intVar) {
                double[]Var[intVar] = double[]Var[intVar] + doubleVar * (double[]Var[intVar] - double[]Var[intVar]);
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.MultiDirectional <133, 135>
for (int j = 0; j < n; ++j) {
                xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.NelderMead <104, 106>
for (int j = 0; j < n; ++j) {
            xR[j] = centroid[j] + rho * (centroid[j] - xWorst[j]);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.NelderMead <104, 106>
for (int intVar = 0; intVar < intVar; ++intVar) {
            double[]Var[intVar] = double[]Var[intVar] + doubleVar * (double[]Var[intVar] - double[]Var[intVar]);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.NelderMead <104, 106>
for (int j = 0; j < n; ++j) {
            xR[j] = centroid[j] + rho * (centroid[j] - xWorst[j]);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.NelderMead <119, 121>
for (int j = 0; j < n; ++j) {
                xE[j] = centroid[j] + khi * (xR[j] - centroid[j]);
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.NelderMead <119, 121>
for (int intVar = 0; intVar < intVar; ++intVar) {
                double[]Var[intVar] = double[]Var[intVar] + doubleVar * (double[]Var[intVar] - double[]Var[intVar]);
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.NelderMead <119, 121>
for (int j = 0; j < n; ++j) {
                xE[j] = centroid[j] + khi * (xR[j] - centroid[j]);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.NelderMead <138, 140>
for (int j = 0; j < n; ++j) {
                    xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]);
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.NelderMead <138, 140>
for (int intVar = 0; intVar < intVar; ++intVar) {
                    double[]Var[intVar] = double[]Var[intVar] + doubleVar * (double[]Var[intVar] - double[]Var[intVar]);
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.NelderMead <138, 140>
for (int j = 0; j < n; ++j) {
                    xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]);
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.NelderMead <153, 155>
for (int j = 0; j < n; ++j) {
                    xC[j] = centroid[j] - gamma * (centroid[j] - xWorst[j]);
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.NelderMead <153, 155>
for (int intVar = 0; intVar < intVar; ++intVar) {
                    double[]Var[intVar] = double[]Var[intVar] - doubleVar * (double[]Var[intVar] - double[]Var[intVar]);
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.NelderMead <153, 155>
for (int j = 0; j < n; ++j) {
                    xC[j] = centroid[j] - gamma * (centroid[j] - xWorst[j]);
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.NelderMead <170, 172>
for (int j = 0; j < n; ++j) {
                    x[j] = xSmallest[j] + sigma * (x[j] - xSmallest[j]);
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.NelderMead <170, 172>
for (int intVar = 0; intVar < intVar; ++intVar) {
                    double[]Var[intVar] = double[]Var[intVar] + doubleVar * (double[]Var[intVar] - double[]Var[intVar]);
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.NelderMead <170, 172>
for (int j = 0; j < n; ++j) {
                    x[j] = xSmallest[j] + sigma * (x[j] - xSmallest[j]);
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.ZipfDistributionImpl <181, 183>
for (int k = n; k > 0; --k) {
            value += 1.0 / Math.pow(k, m);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.ZipfDistributionImpl <181, 183>
for (int intVar = intVar; intVar > 0; --intVar) {
            doubleVar += 1.0 / Math.pow(intVar, doubleVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.distribution.ZipfDistributionImpl <181, 183>
for (int k = n; k > 0; --k) {
            value += 1.0 / Math.pow(k, m);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm <165, 167>
for (int i = n-1; i >= 0; i--) {
            value = a[i] + (z - c[i]) * value;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm <165, 167>
for (int intVar = intVar-1; intVar >= 0; intVar--) {
            doubleVar = doubleVar[intVar] + (doubleVar - doubleVar[intVar]) * doubleVar;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm <165, 167>
for (int i = n-1; i >= 0; i--) {
            value = a[i] + (z - c[i]) * value;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.HypergeometricDistributionImpl <93, 93>
ret = innerCumulativeProbability(domain[0], x, 1, n, m, k);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.HypergeometricDistributionImpl <93, 93>
doubleVar = innerCumulativeProbability(int[]Var[0], intVar, 1, intVar, intVar, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.distribution.HypergeometricDistributionImpl <93, 93>
ret = innerCumulativeProbability(domain[0], x, 1, n, m, k);

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <662, 664>
for (int i = 0; i < n; ++i) {
                        realEigenvalues[begin + i] = lambda + work[4 * i];
                    }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <662, 664>
for (int intVar = 0; intVar < intVar; ++intVar) {
                        double[]Var[intVar + intVar] = doubleVar + double[]Var[4 * intVar];
                    }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <662, 664>
for (int i = 0; i < n; ++i) {
                        realEigenvalues[begin + i] = lambda + work[4 * i];
                    }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <666, 668>
for (int i = 0; i < n; ++i) {
                        realEigenvalues[begin + i] = lambda - work[4 * i];
                    }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <666, 668>
for (int intVar = 0; intVar < intVar; ++intVar) {
                        double[]Var[intVar + intVar] = doubleVar - double[]Var[4 * intVar];
                    }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <666, 668>
for (int i = 0; i < n; ++i) {
                        realEigenvalues[begin + i] = lambda - work[4 * i];
                    }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <652, 652>
tau = (range[1] - range[0]) * MathUtils.EPSILON * n + 2 * minPivot;

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <652, 652>
doubleVar = (double[]Var[1] - double[]Var[0]) * MathUtils.EPSILON * intVar + 2 * doubleVar;

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <652, 652>
tau = (range[1] - range[0]) * MathUtils.EPSILON * n + 2 * minPivot;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.AbstractEstimator <227, 227>
sum += jacobian[k + i] * jacobian[k + j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.AbstractEstimator <227, 227>
doubleVar += double[]Var[intVar + intVar] * double[]Var[intVar + intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.AbstractEstimator <227, 227>
sum += jacobian[k + i] * jacobian[k + j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm <185, 190>
for (int i = n-1; i >= 0; i--) {
            for (int j = n-i; j > 0; j--) {
                coefficients[j] = coefficients[j-1] - c[i] * coefficients[j];
            }
            coefficients[0] = a[i] - c[i] * coefficients[0];
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm <185, 190>
for (int intVar = intVar-1; intVar >= 0; intVar--) {
            for (int j = intVar-intVar; j > 0; j--) {
                doubleVar[j] = doubleVar[j-1] - doubleVar[intVar] * doubleVar[j];
            }
            doubleVar[0] = doubleVar[intVar] - doubleVar[intVar] * doubleVar[0];
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm <185, 190>
for (int i = n-1; i >= 0; i--) {
            for (int j = n-i; j > 0; j--) {
                coefficients[j] = coefficients[j-1] - c[i] * coefficients[j];
            }
            coefficients[0] = a[i] - c[i] * coefficients[0];
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.StatUtils <567, 571>
if ((n  != sample2.length) || (n < 1)) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "input arrays must have the same positive length ({0} and {1})",
                  n, sample2.length);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.StatUtils <567, 571>
if ((intVar  != double[]Var.length) || (intVar < 1)) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "input arrays must have the same positive length ({0} and {1})",
                  intVar, double[]Var.length);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.StatUtils <567, 571>
if ((n  != sample2.length) || (n < 1)) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "input arrays must have the same positive length ({0} and {1})",
                  n, sample2.length);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.StatUtils <612, 616>
if (n < 2 || n != sample2.length) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "input arrays must have the same length and at least two elements ({0} and {1})",
                  n, sample2.length);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.StatUtils <612, 616>
if (intVar < 2 || intVar != double[]Var.length) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "input arrays must have the same length and at least two elements ({0} and {1})",
                  intVar, double[]Var.length);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.StatUtils <612, 616>
if (n < 2 || n != sample2.length) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "input arrays must have the same length and at least two elements ({0} and {1})",
                  n, sample2.length);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.HighamHall54Integrator <118, 120>
final double tol = (vecAbsoluteTolerance == null) ?
                         (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                         (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.HighamHall54Integrator <118, 120>
final double doubleVar = (double[]Var == null) ?
                         (doubleVar + doubleVar * doubleVar) :
                         (double[]Var[intVar] + double[]Var[intVar] * doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.HighamHall54Integrator <118, 120>
final double tol = (vecAbsoluteTolerance == null) ?
                         (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                         (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator <263, 265>
final double tol = (vecAbsoluteTolerance == null) ?
                         (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                         (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator <263, 265>
final double doubleVar = (double[]Var == null) ?
                         (doubleVar + doubleVar * doubleVar) :
                         (double[]Var[intVar] + double[]Var[intVar] * doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator <263, 265>
final double tol = (vecAbsoluteTolerance == null) ?
                         (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                         (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator <144, 146>
final double tol = (vecAbsoluteTolerance == null) ?
                           (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                               (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator <144, 146>
final double doubleVar = (double[]Var == null) ?
                           (doubleVar + doubleVar * doubleVar) :
                               (double[]Var[intVar] + double[]Var[intVar] * doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator <144, 146>
final double tol = (vecAbsoluteTolerance == null) ?
                           (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                               (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <234, 240>
for (int i = 0; i < n; i++) {
            for (int j = i; j > 0; j--) {
                c[j] = c[j-1] - c[j] * x[i];
            }
            c[0] *= -x[i];
            c[i+1] = 1;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <234, 240>
for (int intVar = 0; intVar < intVar; intVar++) {
            for (int j = intVar; j > 0; j--) {
                double[]Var[j] = double[]Var[j-1] - double[]Var[j] * doubleVar[intVar];
            }
            double[]Var[0] *= -doubleVar[intVar];
            double[]Var[intVar+1] = 1;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <234, 240>
for (int i = 0; i < n; i++) {
            for (int j = i; j > 0; j--) {
                c[j] = c[j-1] - c[j] * x[i];
            }
            c[0] *= -x[i];
            c[i+1] = 1;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <203, 208>
if (nearest < 0.5*(n-i+1)) {
                value += c[nearest];    // fork down
            } else {
                nearest--;
                value += d[nearest];    // fork up
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <203, 208>
if (intVar < 0.5*(intVar-intVar+1)) {
                doubleVar += double[]Var[intVar];    // fork down
            } else {
                intVar--;
                doubleVar += double[]Var[intVar];    // fork up
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <203, 208>
if (nearest < 0.5*(n-i+1)) {
                value += c[nearest];    // fork down
            } else {
                nearest--;
                value += d[nearest];    // fork up
            }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <179, 181>
for (int k = n - 1; k >= p; --k) {
                cachedV.setEntry(k, k, 1);
            }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <179, 181>
for (int intVar = intVar - 1; intVar >= intVar; --intVar) {
                RealMatrix.setEntry(intVar, intVar, 1);
            }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <179, 181>
for (int k = n - 1; k >= p; --k) {
                RealMatrix.setEntry(k, k, 1);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <509, 509>
final double ratio = (f[j+1][l] - f[0][l]) / scale[l];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <509, 509>
final double doubleVar = (double[][]Var[intVar+1][intVar] - double[][]Var[0][intVar]) / double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <509, 509>
final double ratio = (f[j+1][l] - f[0][l]) / scale[l];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <281, 281>
final double fac2 = 2 * fac1 * (j - 2) * (j - 3);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <281, 281>
final double doubleVar = 2 * doubleVar * (intVar - 2) * (intVar - 3);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <281, 281>
final double fac2 = 2 * fac1 * (j - 2) * (j - 3);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator <139, 141>
final double errSum = E1 * yDotK[0][j] +  E3 * yDotK[2][j] +
                              E4 * yDotK[3][j] +  E5 * yDotK[4][j] +
                              E6 * yDotK[5][j] +  E7 * yDotK[6][j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator <139, 141>
final double doubleVar = doubleVar * double[][]Var[0][intVar] +  doubleVar * double[][]Var[2][intVar] +
                              doubleVar * double[][]Var[3][intVar] +  doubleVar * double[][]Var[4][intVar] +
                              doubleVar * double[][]Var[5][intVar] +  doubleVar * double[][]Var[6][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator <139, 141>
final double errSum = E1 * yDotK[0][j] +  E3 * yDotK[2][j] +
                              E4 * yDotK[3][j] +  E5 * yDotK[4][j] +
                              E6 * yDotK[5][j] +  E7 * yDotK[6][j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <154, 154>
yTmp[j] = y[j] + stepSize * sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <154, 154>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <154, 154>
yTmp[j] = y[j] + stepSize * sum;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <167, 167>
yTmp[j] = y[j] + stepSize * sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <167, 167>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <167, 167>
yTmp[j] = y[j] + stepSize * sum;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <269, 269>
yTmp[j] = y[j] + stepSize * sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <269, 269>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <269, 269>
yTmp[j] = y[j] + stepSize * sum;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <282, 282>
yTmp[j] = y[j] + stepSize * sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <282, 282>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <282, 282>
yTmp[j] = y[j] + stepSize * sum;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <405, 405>
yTmp[j] = currentState[j] + h * s;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <405, 405>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <405, 405>
yTmp[j] = currentState[j] + h * s;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <415, 415>
yTmp[j] = currentState[j] + h * s;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <415, 415>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <415, 415>
yTmp[j] = currentState[j] + h * s;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <425, 425>
yTmp[j] = currentState[j] + h * s;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <425, 425>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <425, 425>
yTmp[j] = currentState[j] + h * s;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <341, 341>
c = polynoms[j][i] + c * d * theta05;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <341, 341>
doubleVar = double[][]Var[intVar][intVar] + doubleVar * doubleVar * doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <341, 341>
c = polynoms[j][i] + c * d * theta05;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.linear.SimplexTableau <326, 326>
matrix[i - 1][col++] = tableau.getEntry(i, j);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.linear.SimplexTableau <326, 326>
double[][]Var[intVar - 1][intVar++] = RealMatrix.getEntry(intVar, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.linear.SimplexTableau <326, 326>
matrix[i - 1][col++] = RealMatrix.getEntry(i, j);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm <180, 182>
for (int i = 0; i <= n; i++) {
            coefficients[i] = 0.0;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm <180, 182>
for (int intVar = 0; intVar <= intVar; intVar++) {
            doubleVar[intVar] = 0.0;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm <180, 182>
for (int i = 0; i <= n; i++) {
            coefficients[i] = 0.0;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <227, 229>
for (int i = 0; i < n; i++) {
            coefficients[i] = 0.0;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <227, 229>
for (int intVar = 0; intVar < intVar; intVar++) {
            doubleVar[intVar] = 0.0;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <227, 229>
for (int i = 0; i < n; i++) {
            coefficients[i] = 0.0;
        }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1233, 1238>
for (int i = 1; i < n; ++i) {
            ratio = main[index + i] - squaredSecondary[index + i - 1] / ratio - t;
            if (ratio <= 0) {
                ++count;
            }
        }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <1233, 1238>
for (int intVar = 1; intVar < intVar; ++intVar) {
            doubleVar = double[]Var[intVar + intVar] - double[]Var[intVar + intVar - 1] / doubleVar - doubleVar;
            if (doubleVar <= 0) {
                ++intVar;
            }
        }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1233, 1238>
for (int i = 1; i < n; ++i) {
            ratio = main[index + i] - squaredSecondary[index + i - 1] / ratio - t;
            if (ratio <= 0) {
                ++count;
            }
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <340, 342>
for (int i = n - k + 1; i <= n; i++) {
            logSum += Math.log(i);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <340, 342>
for (int intVar = intVar - intVar + 1; intVar <= intVar; intVar++) {
            doubleVar += Math.log(intVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <340, 342>
for (int i = n - k + 1; i <= n; i++) {
            logSum += Math.log(i);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <91, 96>
for (int i = 1; i < n; i++) {
            g = 2d * (x[i+1]  - x[i - 1]) - h[i - 1] * mu[i -1];
            mu[i] = h[i] / g;
            z[i] = (3d * (y[i + 1] * h[i - 1] - y[i] * (x[i + 1] - x[i - 1])+ y[i - 1] * h[i]) /
                    (h[i - 1] * h[i]) - h[i - 1] * z[i - 1]) / g;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <91, 96>
for (int intVar = 1; intVar < intVar; intVar++) {
            doubleVar = 2d * (doubleVar[intVar+1]  - doubleVar[intVar - 1]) - doubleVar[intVar - 1] * doubleVar[intVar -1];
            doubleVar[intVar] = doubleVar[intVar] / doubleVar;
            doubleVar[intVar] = (3d * (doubleVar[intVar + 1] * doubleVar[intVar - 1] - doubleVar[intVar] * (doubleVar[intVar + 1] - doubleVar[intVar - 1])+ doubleVar[intVar - 1] * doubleVar[intVar]) /
                    (doubleVar[intVar - 1] * doubleVar[intVar]) - doubleVar[intVar - 1] * doubleVar[intVar - 1]) / doubleVar;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <91, 96>
for (int i = 1; i < n; i++) {
            g = 2d * (x[i+1]  - x[i - 1]) - h[i - 1] * mu[i -1];
            mu[i] = h[i] / g;
            z[i] = (3d * (y[i + 1] * h[i - 1] - y[i] * (x[i + 1] - x[i - 1])+ y[i - 1] * h[i]) /
                    (h[i - 1] * h[i]) - h[i - 1] * z[i - 1]) / g;
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <144, 152>
if (m < n) {
                    if (i > 0) {
                        cachedB.setEntry(i, i - 1, secondary[i - 1]);
                    }
                } else {
                    if (i < main.length - 1) {
                        cachedB.setEntry(i, i + 1, secondary[i]);
                    }
                }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <144, 152>
if (intVar < intVar) {
                    if (intVar > 0) {
                        RealMatrix.setEntry(intVar, intVar - 1, double[]Var[intVar - 1]);
                    }
                } else {
                    if (intVar < double[]Var.length - 1) {
                        RealMatrix.setEntry(intVar, intVar + 1, double[]Var[intVar]);
                    }
                }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <144, 152>
if (m < n) {
                    if (i > 0) {
                        RealMatrix.setEntry(i, i - 1, secondary[i - 1]);
                    }
                } else {
                    if (i < main.length - 1) {
                        RealMatrix.setEntry(i, i + 1, secondary[i]);
                    }
                }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <115, 115>
cachedU.addToEntry(i, j, -alpha * householderVectors[i][k - diagOffset]);

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <115, 115>
RealMatrix.addToEntry(intVar, intVar, -doubleVar * doubleVar[intVar][intVar - intVar]);

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <115, 115>
RealMatrix.addToEntry(i, j, -alpha * householderVectors[i][k - diagOffset]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator <253, 256>
final double errSum1 = E1_01 * yDotK[0][j]  + E1_06 * yDotK[5][j] +
                             E1_07 * yDotK[6][j]  + E1_08 * yDotK[7][j] +
                             E1_09 * yDotK[8][j]  + E1_10 * yDotK[9][j] +
                             E1_11 * yDotK[10][j] + E1_12 * yDotK[11][j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator <253, 256>
final double doubleVar = doubleVar * double[][]Var[0][intVar]  + doubleVar * double[][]Var[5][intVar] +
                             doubleVar * double[][]Var[6][intVar]  + doubleVar * double[][]Var[7][intVar] +
                             doubleVar * double[][]Var[8][intVar]  + doubleVar * double[][]Var[9][intVar] +
                             doubleVar * double[][]Var[10][intVar] + doubleVar * double[][]Var[11][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator <253, 256>
final double errSum1 = E1_01 * yDotK[0][j]  + E1_06 * yDotK[5][j] +
                             E1_07 * yDotK[6][j]  + E1_08 * yDotK[7][j] +
                             E1_09 * yDotK[8][j]  + E1_10 * yDotK[9][j] +
                             E1_11 * yDotK[10][j] + E1_12 * yDotK[11][j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator <257, 260>
final double errSum2 = E2_01 * yDotK[0][j]  + E2_06 * yDotK[5][j] +
                             E2_07 * yDotK[6][j]  + E2_08 * yDotK[7][j] +
                             E2_09 * yDotK[8][j]  + E2_10 * yDotK[9][j] +
                             E2_11 * yDotK[10][j] + E2_12 * yDotK[11][j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator <257, 260>
final double doubleVar = doubleVar * double[][]Var[0][intVar]  + doubleVar * double[][]Var[5][intVar] +
                             doubleVar * double[][]Var[6][intVar]  + doubleVar * double[][]Var[7][intVar] +
                             doubleVar * double[][]Var[8][intVar]  + doubleVar * double[][]Var[9][intVar] +
                             doubleVar * double[][]Var[10][intVar] + doubleVar * double[][]Var[11][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator <257, 260>
final double errSum2 = E2_01 * yDotK[0][j]  + E2_06 * yDotK[5][j] +
                             E2_07 * yDotK[6][j]  + E2_08 * yDotK[7][j] +
                             E2_09 * yDotK[8][j]  + E2_10 * yDotK[9][j] +
                             E2_11 * yDotK[10][j] + E2_12 * yDotK[11][j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <335, 343>
for (int i = 0; i < n; ++i) {
                final double arg = residuals[i] / (6 * medianResidual);
                if (arg >= 1) {
                    robustnessWeights[i] = 0;
                } else {
                    final double w = 1 - arg * arg;
                    robustnessWeights[i] = w * w;
                }
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <335, 343>
for (int intVar = 0; intVar < intVar; ++intVar) {
                final double arg = double[]Var[intVar] / (6 * doubleVar);
                if (arg >= 1) {
                    double[]Var[intVar] = 0;
                } else {
                    final double w = 1 - arg * arg;
                    double[]Var[intVar] = w * w;
                }
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <335, 343>
for (int i = 0; i < n; ++i) {
                final double arg = residuals[i] / (6 * medianResidual);
                if (arg >= 1) {
                    robustnessWeights[i] = 0;
                } else {
                    final double w = 1 - arg * arg;
                    robustnessWeights[i] = w * w;
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <72, 78>
for (int i = 0; i < n; i++) {
            if (x[i]  >= x[i + 1]) {
                throw MathRuntimeException.createIllegalArgumentException(
                      "points {0} and {1} are not strictly increasing ({2} >= {3})",
                      i, i+1, x[i], x[i+1]);
            }
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <72, 78>
for (int intVar = 0; intVar < intVar; intVar++) {
            if (doubleVar[intVar]  >= doubleVar[intVar + 1]) {
                throw MathRuntimeException.createIllegalArgumentException(
                      "points {0} and {1} are not strictly increasing ({2} >= {3})",
                      intVar, intVar+1, doubleVar[intVar], doubleVar[intVar+1]);
            }
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <72, 78>
for (int i = 0; i < n; i++) {
            if (x[i]  >= x[i + 1]) {
                throw MathRuntimeException.createIllegalArgumentException(
                      "points {0} and {1} are not strictly increasing ({2} >= {3})",
                      i, i+1, x[i], x[i+1]);
            }
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <604, 607>
sum += tBlock[l] * mBlock[n] +
                                       tBlock[l + 1] * mBlock[n + jWidth] +
                                       tBlock[l + 2] * mBlock[n + jWidth2] +
                                       tBlock[l + 3] * mBlock[n + jWidth3];

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockRealMatrix <604, 607>
doubleVar += double[]Var[intVar] * double[]Var[intVar] +
                                       double[]Var[intVar + 1] * double[]Var[intVar + intVar] +
                                       double[]Var[intVar + 2] * double[]Var[intVar + intVar] +
                                       double[]Var[intVar + 3] * double[]Var[intVar + intVar];

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BlockRealMatrix <604, 607>
sum += tBlock[l] * mBlock[n] +
                                       tBlock[l + 1] * mBlock[n + jWidth] +
                                       tBlock[l + 2] * mBlock[n + jWidth2] +
                                       tBlock[l + 3] * mBlock[n + jWidth3];

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <297, 297>
subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractFieldMatrix <297, 297>
FieldMatrix.setEntry(intVar - intVar, intVar - intVar, getEntry(intVar, intVar));

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractFieldMatrix <297, 297>
FieldMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <270, 270>
subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <270, 270>
RealMatrix.setEntry(intVar - intVar, intVar - intVar, getEntry(intVar, intVar));

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <270, 270>
RealMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <152, 152>
sum += a[k-1][l] * yDotK[l][j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <152, 152>
doubleVar += double[][]Var[intVar-1][intVar] * double[][]Var[intVar][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <152, 152>
sum += a[k-1][l] * yDotK[l][j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <267, 267>
sum += a[k-1][l] * yDotK[l][j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <267, 267>
doubleVar += double[][]Var[intVar-1][intVar] * double[][]Var[intVar][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <267, 267>
sum += a[k-1][l] * yDotK[l][j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <402, 404>
s = K14_01 * yDotK[0][j]  + K14_06 * yDotK[5][j]  + K14_07 * yDotK[6][j] +
          K14_08 * yDotK[7][j]  + K14_09 * yDotK[8][j]  + K14_10 * yDotK[9][j] +
          K14_11 * yDotK[10][j] + K14_12 * yDotK[11][j] + K14_13 * yDotK[12][j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <402, 404>
doubleVar = doubleVar * double[][]Var[0][intVar]  + doubleVar * double[][]Var[5][intVar]  + doubleVar * double[][]Var[6][intVar] +
          doubleVar * double[][]Var[7][intVar]  + doubleVar * double[][]Var[8][intVar]  + doubleVar * double[][]Var[9][intVar] +
          doubleVar * double[][]Var[10][intVar] + doubleVar * double[][]Var[11][intVar] + doubleVar * double[][]Var[12][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <402, 404>
s = K14_01 * yDotK[0][j]  + K14_06 * yDotK[5][j]  + K14_07 * yDotK[6][j] +
          K14_08 * yDotK[7][j]  + K14_09 * yDotK[8][j]  + K14_10 * yDotK[9][j] +
          K14_11 * yDotK[10][j] + K14_12 * yDotK[11][j] + K14_13 * yDotK[12][j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <82, 84>
for (int i = 0; i < n; i++) {
            h[i] = x[i + 1] - x[i];
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <82, 84>
for (int intVar = 0; intVar < intVar; intVar++) {
            doubleVar[intVar] = doubleVar[intVar + 1] - doubleVar[intVar];
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <82, 84>
for (int i = 0; i < n; i++) {
            h[i] = x[i + 1] - x[i];
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <282, 283>
polynoms[j+4][i] =
                  16 * (yMidDots[j][i] + fac1 * polynoms[j+2][i] - fac2 * polynoms[j][i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <282, 283>
double[][]Var[intVar+4][intVar] =
                  16 * (double[][]Var[intVar][intVar] + doubleVar * double[][]Var[intVar+2][intVar] - doubleVar * double[][]Var[intVar][intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <282, 283>
polynoms[j+4][i] =
                  16 * (yMidDots[j][i] + fac1 * polynoms[j+2][i] - fac2 * polynoms[j][i]);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.QRDecompositionImpl <194, 196>
for (int minor = m - 1; minor >= Math.min(m, n); minor--) {
                cachedQT.setEntry(minor, minor, 1.0);
            }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.QRDecompositionImpl <194, 196>
for (int intVar = intVar - 1; intVar >= Math.min(intVar, intVar); intVar--) {
                RealMatrix.setEntry(intVar, intVar, 1.0);
            }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.QRDecompositionImpl <194, 196>
for (int minor = m - 1; minor >= Math.min(m, n); minor--) {
                RealMatrix.setEntry(minor, minor, 1.0);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.special.Gamma <186, 190>
if (n >= maxIterations) {
                throw new MaxIterationsExceededException(maxIterations);
            } else {
                ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.special.Gamma <186, 190>
if (doubleVar >= intVar) {
                throw new MaxIterationsExceededException(intVar);
            } else {
                doubleVar = Math.exp(-doubleVar + (doubleVar * Math.log(doubleVar)) - logGamma(doubleVar)) * doubleVar;
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.special.Gamma <186, 190>
if (n >= maxIterations) {
                throw new MaxIterationsExceededException(maxIterations);
            } else {
                ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <404, 404>
f[i+j+k] = f[j+k].subtract(z);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <404, 404>
Complex[intVar+intVar+intVar] = Complex[intVar+intVar].subtract(Complex);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <404, 404>
Complex[i+j+k] = Complex[j+k].subtract(Complex);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <405, 405>
f[j+k] = f[j+k].add(z);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <405, 405>
Complex[intVar+intVar] = Complex[intVar+intVar].add(Complex);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <405, 405>
Complex[j+k] = Complex[j+k].add(Complex);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <411, 414>
s = K15_01 * yDotK[0][j]  + K15_06 * yDotK[5][j]  + K15_07 * yDotK[6][j] +
         K15_08 * yDotK[7][j]  + K15_09 * yDotK[8][j]  + K15_10 * yDotK[9][j] +
         K15_11 * yDotK[10][j] + K15_12 * yDotK[11][j] + K15_13 * yDotK[12][j] +
         K15_14 * yDotKLast[0][j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <411, 414>
doubleVar = doubleVar * double[][]Var[0][intVar]  + doubleVar * double[][]Var[5][intVar]  + doubleVar * double[][]Var[6][intVar] +
         doubleVar * double[][]Var[7][intVar]  + doubleVar * double[][]Var[8][intVar]  + doubleVar * double[][]Var[9][intVar] +
         doubleVar * double[][]Var[10][intVar] + doubleVar * double[][]Var[11][intVar] + doubleVar * double[][]Var[12][intVar] +
         doubleVar * double[][]Var[0][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <411, 414>
s = K15_01 * yDotK[0][j]  + K15_06 * yDotK[5][j]  + K15_07 * yDotK[6][j] +
         K15_08 * yDotK[7][j]  + K15_09 * yDotK[8][j]  + K15_10 * yDotK[9][j] +
         K15_11 * yDotK[10][j] + K15_12 * yDotK[11][j] + K15_13 * yDotK[12][j] +
         K15_14 * yDotKLast[0][j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <760, 762>
for (int i = j + 1; i < nSing; ++i) {
          sum += jacobian[i * cols + pj] * work[i];
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <760, 762>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
          doubleVar += double[]Var[intVar * intVar + intVar] * double[]Var[intVar];
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <760, 762>
for (int i = j + 1; i < nSing; ++i) {
          sum += jacobian[i * cols + pj] * work[i];
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <211, 212>
interpolatedDerivatives[j] =
                (interpolatedDerivatives[j] + scaled[j] * normalizedAbscissa) / x;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <211, 212>
double[]Var[intVar] =
                (double[]Var[intVar] + double[]Var[intVar] * doubleVar) / doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <211, 212>
interpolatedDerivatives[j] =
                (interpolatedDerivatives[j] + scaled[j] * normalizedAbscissa) / x;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.HypergeometricDistributionImpl <234, 236>
return Math.exp(MathUtils.binomialCoefficientLog(m, x) +
               MathUtils.binomialCoefficientLog(n - m, k - x) -
               MathUtils.binomialCoefficientLog(n, k));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.HypergeometricDistributionImpl <234, 236>
return Math.exp(MathUtils.binomialCoefficientLog(intVar, intVar) +
               MathUtils.binomialCoefficientLog(intVar - intVar, intVar - intVar) -
               MathUtils.binomialCoefficientLog(intVar, intVar));

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.distribution.HypergeometricDistributionImpl <234, 236>
return Math.exp(MathUtils.binomialCoefficientLog(m, x) +
               MathUtils.binomialCoefficientLog(n - m, k - x) -
               MathUtils.binomialCoefficientLog(n, k));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <421, 424>
s = K16_01 * yDotK[0][j]  + K16_06 * yDotK[5][j]  + K16_07 * yDotK[6][j] +
          K16_08 * yDotK[7][j]  + K16_09 * yDotK[8][j]  + K16_10 * yDotK[9][j] +
          K16_11 * yDotK[10][j] + K16_12 * yDotK[11][j] + K16_13 * yDotK[12][j] +
          K16_14 * yDotKLast[0][j] +  K16_15 * yDotKLast[1][j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <421, 424>
doubleVar = doubleVar * double[][]Var[0][intVar]  + doubleVar * double[][]Var[5][intVar]  + doubleVar * double[][]Var[6][intVar] +
          doubleVar * double[][]Var[7][intVar]  + doubleVar * double[][]Var[8][intVar]  + doubleVar * double[][]Var[9][intVar] +
          doubleVar * double[][]Var[10][intVar] + doubleVar * double[][]Var[11][intVar] + doubleVar * double[][]Var[12][intVar] +
          doubleVar * double[][]Var[0][intVar] +  doubleVar * double[][]Var[1][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <421, 424>
s = K16_01 * yDotK[0][j]  + K16_06 * yDotK[5][j]  + K16_07 * yDotK[6][j] +
          K16_08 * yDotK[7][j]  + K16_09 * yDotK[8][j]  + K16_10 * yDotK[9][j] +
          K16_11 * yDotK[10][j] + K16_12 * yDotK[11][j] + K16_13 * yDotK[12][j] +
          K16_14 * yDotKLast[0][j] +  K16_15 * yDotKLast[1][j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <845, 845>
diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <845, 845>
double[][]Var[intVar-1][intVar] = doubleVar * double[][][]Var[intVar+intVar][intVar+intVar][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <845, 845>
diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <212, 216>
for (int j = Math.max(0, i + 1 - p.coefficients.length);
                 j < Math.min(coefficients.length, i + 1);
                 ++j) {
                newCoefficients[i] += coefficients[j] * p.coefficients[i-j];
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <212, 216>
for (int intVar = Math.max(0, intVar + 1 - PolynomialFunction.doubleVar.length);
                 intVar < Math.min(doubleVar.length, intVar + 1);
                 ++intVar) {
                double[]Var[intVar] += doubleVar[intVar] * PolynomialFunction.doubleVar[intVar-intVar];
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <212, 216>
for (int j = Math.max(0, i + 1 - PolynomialFunction.coefficients.length);
                 j < Math.min(coefficients.length, i + 1);
                 ++j) {
                newCoefficients[i] += coefficients[j] * PolynomialFunction.coefficients[i-j];
            }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SingularValueDecompositionImpl <135, 145>
for (int i = 0; i < n - 1; ++i) {
                    // compute Bt.E.S^(-1) where E is the eigenvectors matrix
                    // we reuse the array from matrix E to store the result
                    final double[] ei0 = ei1;
                    ei1 = eData[i + 1];
                    iData[i + 1] = ei1;
                    for (int j = 0; j < n; ++j) {
                        ei0[j] = (mainBidiagonal[i] * ei0[j] +
                                  secondaryBidiagonal[i] * ei1[j]) / singularValues[j];
                    }
                }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.SingularValueDecompositionImpl <135, 145>
for (int intVar = 0; intVar < intVar - 1; ++intVar) {
                    // compute Bt.E.S^(-1) where E is the eigenvectors matrix
                    // we reuse the array from matrix E to store the result
                    final double[] ei0 = double[]Var;
                    double[]Var = double[][]Var[intVar + 1];
                    double[][]Var[intVar + 1] = double[]Var;
                    for (int j = 0; j < intVar; ++j) {
                        ei0[j] = (double[]Var[intVar] * ei0[j] +
                                  double[]Var[intVar] * double[]Var[j]) / double[]Var[j];
                    }
                }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.SingularValueDecompositionImpl <135, 145>
for (int i = 0; i < n - 1; ++i) {
                    // compute Bt.E.S^(-1) where E is the eigenvectors matrix
                    // we reuse the array from matrix E to store the result
                    final double[] ei0 = ei1;
                    ei1 = eData[i + 1];
                    iData[i + 1] = ei1;
                    for (int j = 0; j < n; ++j) {
                        ei0[j] = (mainBidiagonal[i] * ei0[j] +
                                  secondaryBidiagonal[i] * ei1[j]) / singularValues[j];
                    }
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <356, 360>
if (n == 2) {
            f[0] = data[0].add(data[1]);
            f[1] = data[0].subtract(data[1]);
            return f;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <356, 360>
if (intVar == 2) {
            Complex[0] = Complex[0].add(Complex[1]);
            Complex[1] = Complex[0].subtract(Complex[1]);
            return Complex;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <356, 360>
if (n == 2) {
            Complex[0] = Complex[0].add(Complex[1]);
            Complex[1] = Complex[0].subtract(Complex[1]);
            return Complex;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <442, 444>
for (int i = 0; i < n; i++) {
            s[i] = f.value(min + i * h);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <442, 444>
for (int intVar = 0; intVar < intVar; intVar++) {
            doubleVar[intVar] = UnivariateRealFunction.value(doubleVar + intVar * doubleVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <442, 444>
for (int i = 0; i < n; i++) {
            s[i] = UnivariateRealFunction.value(min + i * h);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <676, 678>
for (int i = j + 1; i < solvedCols; ++i) {
        jacobian[i * cols + pj] = jacobian[j * cols + permutation[i]];
      }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <676, 678>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
        double[]Var[intVar * intVar + intVar] = double[]Var[intVar * intVar + int[]Var[intVar]];
      }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <676, 678>
for (int i = j + 1; i < solvedCols; ++i) {
        jacobian[i * cols + pj] = jacobian[j * cols + permutation[i]];
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <257, 258>
double entry = covarianceMatrix.getEntry(i, j) /
                       (sigma * Math.sqrt(covarianceMatrix.getEntry(j, j)));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <257, 258>
double doubleVar = RealMatrix.getEntry(intVar, intVar) /
                       (doubleVar * Math.sqrt(RealMatrix.getEntry(intVar, intVar)));

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <257, 258>
double entry = RealMatrix.getEntry(i, j) /
                       (sigma * Math.sqrt(RealMatrix.getEntry(j, j)));

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.CholeskyDecompositionImpl <226, 228>
for (int i = j + 1; i < m; i++) {
                    x[i] -= xJ * lJ[i];
                }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.CholeskyDecompositionImpl <226, 228>
for (int intVar = intVar + 1; intVar < intVar; intVar++) {
                    double[]Var[intVar] -= doubleVar * double[]Var[intVar];
                }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.CholeskyDecompositionImpl <226, 228>
for (int i = j + 1; i < m; i++) {
                    x[i] -= xJ * lJ[i];
                }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.CholeskyDecompositionImpl <265, 267>
for (int i = j + 1; i < m; i++) {
                        x[i] -= xJ * lJ[i];
                    }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.CholeskyDecompositionImpl <265, 267>
for (int intVar = intVar + 1; intVar < intVar; intVar++) {
                        double[]Var[intVar] -= doubleVar * double[]Var[intVar];
                    }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.CholeskyDecompositionImpl <265, 267>
for (int i = j + 1; i < m; i++) {
                        x[i] -= xJ * lJ[i];
                    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <128, 130>
for (int i = 0; i < n; ++i) {
                    r[i] = -r[i];
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <128, 130>
for (int intVar = 0; intVar < intVar; ++intVar) {
                    double[]Var[intVar] = -double[]Var[intVar];
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <128, 130>
for (int i = 0; i < n; ++i) {
                    r[i] = -r[i];
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <172, 174>
for (int i = 0; i < n; ++i) {
                        r[i] = -r[i];
                    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <172, 174>
for (int intVar = 0; intVar < intVar; ++intVar) {
                        double[]Var[intVar] = -double[]Var[intVar];
                    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <172, 174>
for (int i = 0; i < n; ++i) {
                        r[i] = -r[i];
                    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <625, 627>
for (int i = j + 1; i < solvedCols; ++i) {
          work1[permutation[i]] -= jacobian[i * cols + pj] * tmp;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <625, 627>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
          double[]Var[int[]Var[intVar]] -= double[]Var[intVar * intVar + intVar] * doubleVar;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <625, 627>
for (int i = j + 1; i < solvedCols; ++i) {
          work1[permutation[i]] -= jacobian[i * cols + pj] * tmp;
        }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <961, 969>
if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                           (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                    final double tmp = work[i + 2] / work[j];
                    work[j + 2] = work[i] * tmp;
                    d *= tmp;
                } else {
                    work[j + 2] = work[i + 2] * (work[i] / work[j]);
                    d *= work[i + 2] / work[j];
               }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <961, 969>
if ((MathUtils.SAFE_MIN * double[]Var[intVar + 2] < double[]Var[intVar]) &&
                           (MathUtils.SAFE_MIN * double[]Var[intVar] < double[]Var[intVar + 2])) {
                    final double tmp = double[]Var[intVar + 2] / double[]Var[intVar];
                    double[]Var[intVar + 2] = double[]Var[intVar] * tmp;
                    doubleVar *= tmp;
                } else {
                    double[]Var[intVar + 2] = double[]Var[intVar + 2] * (double[]Var[intVar] / double[]Var[intVar]);
                    doubleVar *= double[]Var[intVar + 2] / double[]Var[intVar];
               }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <961, 969>
if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                           (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                    final double tmp = work[i + 2] / work[j];
                    work[j + 2] = work[i] * tmp;
                    d *= tmp;
                } else {
                    work[j + 2] = work[i + 2] * (work[i] / work[j]);
                    d *= work[i + 2] / work[j];
               }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.AbstractMultipleLinearRegression <54, 56>
for (int j = 1; j < nvars + 1; j++) {
                x[i][j] = data[pointer++];
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.AbstractMultipleLinearRegression <54, 56>
for (int intVar = 1; intVar < intVar + 1; intVar++) {
                double[][]Var[intVar][intVar] = double[]Var[intVar++];
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.AbstractMultipleLinearRegression <54, 56>
for (int j = 1; j < nvars + 1; j++) {
                x[i][j] = data[pointer++];
            }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1256, 1263>
for (int i = 1; i < n; ++i) {
            final int    fourI = 4 * i;
            final double eiM1  = secondary[index + i - 1];
            final double ratio = eiM1 / di;
            work[fourI - 2] = ratio * ratio * Math.abs(di);
            di = (main[index + i] - lambda) - eiM1 * ratio;
            work[fourI] = Math.abs(di);
        }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <1256, 1263>
for (int intVar = 1; intVar < intVar; ++intVar) {
            final int    fourI = 4 * intVar;
            final double eiM1  = double[]Var[intVar + intVar - 1];
            final double ratio = eiM1 / doubleVar;
            double[]Var[fourI - 2] = ratio * ratio * Math.abs(doubleVar);
            doubleVar = (double[]Var[intVar + intVar] - doubleVar) - eiM1 * ratio;
            double[]Var[fourI] = Math.abs(doubleVar);
        }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1256, 1263>
for (int i = 1; i < n; ++i) {
            final int    fourI = 4 * i;
            final double eiM1  = secondary[index + i - 1];
            final double ratio = eiM1 / di;
            work[fourI - 2] = ratio * ratio * Math.abs(di);
            di = (main[index + i] - lambda) - eiM1 * ratio;
            work[fourI] = Math.abs(di);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <213, 215>
for (int i = 0; i < data.length && n > 0; i++) {
            removeData(data[i][0], data[i][1]);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.SimpleRegression <213, 215>
for (int intVar = 0; intVar < double[][]Var.length && longVar > 0; intVar++) {
            removeData(double[][]Var[intVar][0], double[][]Var[intVar][1]);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.SimpleRegression <213, 215>
for (int i = 0; i < data.length && n > 0; i++) {
            removeData(data[i][0], data[i][1]);
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.TriDiagonalTransformer <212, 215>
for (int j = k + 1; j < m; ++j) {
                final double c = hK[j];
                xNormSqr += c * c;
            }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.TriDiagonalTransformer <212, 215>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                final double c = double[]Var[intVar];
                doubleVar += c * c;
            }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.TriDiagonalTransformer <212, 215>
for (int j = k + 1; j < m; ++j) {
                final double c = hK[j];
                xNormSqr += c * c;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <854, 860>
for (int j = (l + 1) / 2; j <= k; ++j) {
            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {
              for (int i = 0; i < y0.length; ++i) {
                fk[j][m][i] -= fk[j][m-2][i];
              }
            }
          }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <854, 860>
for (int intVar = (intVar + 1) / 2; intVar <= intVar; ++intVar) {
            for (int m = fk[j].length - 1; m >= 2 * (intVar + 1); --m) {
              for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
                double[][][]Var[intVar][m][intVar] -= double[][][]Var[intVar][m-2][intVar];
              }
            }
          }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <854, 860>
for (int j = (l + 1) / 2; j <= k; ++j) {
            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {
              for (int i = 0; i < y0.length; ++i) {
                fk[j][m][i] -= fk[j][m-2][i];
              }
            }
          }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <225, 227>
for (int j = 0; j < abscissas.length; ++j) {
                sum += weights[j] * f.value(midPoint + halfStep * abscissas[j]);
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <225, 227>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
                doubleVar += double[]Var[intVar] * UnivariateRealFunction.value(doubleVar + doubleVar * double[]Var[intVar]);
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <225, 227>
for (int j = 0; j < abscissas.length; ++j) {
                sum += weights[j] * UnivariateRealFunction.value(midPoint + halfStep * abscissas[j]);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <398, 402>
final Complex z = new Complex(
                        f[i+j+k].getReal() * omega_k_times_m_real -
                        f[i+j+k].getImaginary() * omega_k_times_m_imaginary,
                        f[i+j+k].getReal() * omega_k_times_m_imaginary +
                        f[i+j+k].getImaginary() * omega_k_times_m_real);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <398, 402>
final Complex Complex = new Complex(
                        Complex[intVar+intVar+intVar].getReal() * doubleVar -
                        Complex[intVar+intVar+intVar].getImaginary() * doubleVar,
                        Complex[intVar+intVar+intVar].getReal() * doubleVar +
                        Complex[intVar+intVar+intVar].getImaginary() * doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <398, 402>
final Complex Complex = new Complex(
                        Complex[i+j+k].getReal() * omega_k_times_m_real -
                        Complex[i+j+k].getImaginary() * omega_k_times_m_imaginary,
                        Complex[i+j+k].getReal() * omega_k_times_m_imaginary +
                        Complex[i+j+k].getImaginary() * omega_k_times_m_real);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <426, 428>
for (int j = 0; j < nCols; ++j) {
                setEntry(row + i, column + j, subMatrix[i][j]);
            }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractFieldMatrix <426, 428>
for (int intVar = 0; intVar < intVar; ++intVar) {
                setEntry(intVar + intVar, intVar + intVar, T[][]Var[intVar][intVar]);
            }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractFieldMatrix <426, 428>
for (int j = 0; j < nCols; ++j) {
                setEntry(row + i, column + j, subMatrix[i][j]);
            }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <399, 401>
for (int j = 0; j < nCols; ++j) {
                setEntry(row + i, column + j, subMatrix[i][j]);
            }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <399, 401>
for (int intVar = 0; intVar < intVar; ++intVar) {
                setEntry(intVar + intVar, intVar + intVar, double[][]Var[intVar][intVar]);
            }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <399, 401>
for (int j = 0; j < nCols; ++j) {
                setEntry(row + i, column + j, subMatrix[i][j]);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <190, 204>
for (int j = 0; j < i; ++j) {
                final double[] refJ = referenceSimplex[j];
                boolean allEquals = true;
                for (int k = 0; k < n; ++k) {
                    if (refI[k] != refJ[k]) {
                        allEquals = false;
                        break;
                    }
                }
                if (allEquals) {
                    throw MathRuntimeException.createIllegalArgumentException(
                            "equals vertices {0} and {1} in simplex configuration",
                            i, j);
                }
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <190, 204>
for (int intVar = 0; intVar < intVar; ++intVar) {
                final double[] refJ = double[][]Var[intVar];
                boolean allEquals = true;
                for (int k = 0; k < intVar; ++k) {
                    if (double[]Var[k] != refJ[k]) {
                        allEquals = false;
                        break;
                    }
                }
                if (allEquals) {
                    throw MathRuntimeException.createIllegalArgumentException(
                            "equals vertices {0} and {1} in simplex configuration",
                            intVar, intVar);
                }
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <190, 204>
for (int j = 0; j < i; ++j) {
                final double[] refJ = referenceSimplex[j];
                boolean allEquals = true;
                for (int k = 0; k < n; ++k) {
                    if (refI[k] != refJ[k]) {
                        allEquals = false;
                        break;
                    }
                }
                if (allEquals) {
                    throw MathRuntimeException.createIllegalArgumentException(
                            "equals vertices {0} and {1} in simplex configuration",
                            i, j);
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <198, 206>
if ((getIterations() % n == 0) || (beta < 0)) {
                    // break conjugation: reset search direction
                    searchDirection = steepestDescent.clone();
                } else {
                    // compute new conjugate search direction
                    for (int i = 0; i < n; ++i) {
                        searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];
                    }
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <198, 206>
if ((getIterations() % intVar == 0) || (doubleVar < 0)) {
                    // break conjugation: reset search direction
                    double[]Var = double[]Var.clone();
                } else {
                    // compute new conjugate search direction
                    for (int intVar = 0; intVar < intVar; ++intVar) {
                        double[]Var[intVar] = double[]Var[intVar] + doubleVar * double[]Var[intVar];
                    }
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <198, 206>
if ((getIterations() % n == 0) || (beta < 0)) {
                    // break conjugation: reset search direction
                    searchDirection = steepestDescent.clone();
                } else {
                    // compute new conjugate search direction
                    for (int i = 0; i < n; ++i) {
                        searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];
                    }
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.StatUtils <573, 575>
for (int i = 0; i < n; i++) {
            result += sample1[i] - sample2[i];
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.StatUtils <573, 575>
for (int intVar = 0; intVar < intVar; intVar++) {
            doubleVar += double[]Var[intVar] - double[]Var[intVar];
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.StatUtils <573, 575>
for (int i = 0; i < n; i++) {
            result += sample1[i] - sample2[i];
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.GaussNewtonOptimizer <89, 91>
for (int j = 0; j < cols; ++j) {
                    b[j] += wr * grad[j];
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.GaussNewtonOptimizer <89, 91>
for (int intVar = 0; intVar < intVar; ++intVar) {
                    double[]Var[intVar] += doubleVar * double[]Var[intVar];
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.GaussNewtonOptimizer <89, 91>
for (int j = 0; j < cols; ++j) {
                    b[j] += wr * grad[j];
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <138, 140>
for (int i = 0; i < n; ++i) {
                delta += r[i] * searchDirection[i];
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <138, 140>
for (int intVar = 0; intVar < intVar; ++intVar) {
                doubleVar += double[]Var[intVar] * double[]Var[intVar];
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <138, 140>
for (int i = 0; i < n; ++i) {
                delta += r[i] * searchDirection[i];
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <181, 183>
for (int i = 0; i < n; ++i) {
                    delta += r[i] * newSteepestDescent[i];
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <181, 183>
for (int intVar = 0; intVar < intVar; ++intVar) {
                    doubleVar += double[]Var[intVar] * double[]Var[intVar];
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <181, 183>
for (int i = 0; i < n; ++i) {
                    delta += r[i] * newSteepestDescent[i];
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <355, 357>
for (int j = 0; j < solvedCols; ++j) {
                    coeff1 += work1[j] * work1[j];
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <355, 357>
for (int intVar = 0; intVar < intVar; ++intVar) {
                    doubleVar += double[]Var[intVar] * double[]Var[intVar];
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <355, 357>
for (int j = 0; j < solvedCols; ++j) {
                    coeff1 += work1[j] * work1[j];
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <392, 394>
for (int j = 0; j < solvedCols; ++j) {
         coeff1 += work1[j] * work1[j];
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <392, 394>
for (int intVar = 0; intVar < intVar; ++intVar) {
         doubleVar += double[]Var[intVar] * double[]Var[intVar];
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <392, 394>
for (int j = 0; j < solvedCols; ++j) {
         coeff1 += work1[j] * work1[j];
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.LUDecompositionImpl <390, 392>
for (int j = 0; j < nColB; j++) {
                        bpI[j] -= bpCol[j] * luICol;
                    }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.LUDecompositionImpl <390, 392>
for (int intVar = 0; intVar < intVar; intVar++) {
                        double[]Var[intVar] -= double[]Var[intVar] * doubleVar;
                    }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.LUDecompositionImpl <390, 392>
for (int j = 0; j < nColB; j++) {
                        bpI[j] -= bpCol[j] * luICol;
                    }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.LUDecompositionImpl <406, 408>
for (int j = 0; j < nColB; j++) {
                        bpI[j] -= bpCol[j] * luICol;
                    }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.LUDecompositionImpl <406, 408>
for (int intVar = 0; intVar < intVar; intVar++) {
                        double[]Var[intVar] -= double[]Var[intVar] * doubleVar;
                    }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.LUDecompositionImpl <406, 408>
for (int j = 0; j < nColB; j++) {
                        bpI[j] -= bpCol[j] * luICol;
                    }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SingularValueDecompositionImpl <228, 230>
for (int j = 0; j < m; ++j) {
                    ei1[j] *= lastMain / singularValues[j];
                }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.SingularValueDecompositionImpl <228, 230>
for (int intVar = 0; intVar < intVar; ++intVar) {
                    double[]Var[intVar] *= doubleVar / double[]Var[intVar];
                }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.SingularValueDecompositionImpl <228, 230>
for (int j = 0; j < m; ++j) {
                    ei1[j] *= lastMain / singularValues[j];
                }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <414, 416>
for (int j = 0; j < m; ++j) {
                    bp[j] += s * vData[j];
                }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <414, 416>
for (int intVar = 0; intVar < intVar; ++intVar) {
                    double[]Var[intVar] += doubleVar * double[]Var[intVar];
                }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <414, 416>
for (int j = 0; j < m; ++j) {
                    bp[j] += s * vData[j];
                }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <450, 452>
for (int j = 0; j < m; ++j) {
                    bp[j] += s * vData[j];
                }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <450, 452>
for (int intVar = 0; intVar < intVar; ++intVar) {
                    double[]Var[intVar] += doubleVar * double[]Var[intVar];
                }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <450, 452>
for (int j = 0; j < m; ++j) {
                    bp[j] += s * vData[j];
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <263, 265>
for (int j = 0; j < y0.length; ++j) {
                    predictedScaled[j] = stepSize * yDot[j];
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <263, 265>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
                    double[]Var[intVar] = doubleVar * double[]Var[intVar];
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <263, 265>
for (int j = 0; j < y0.length; ++j) {
                    predictedScaled[j] = stepSize * yDot[j];
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <279, 281>
for (int j = 0; j < y0.length; ++j) {
                        correctedScaled[j] = stepSize * yDot[j];
                    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <279, 281>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
                        double[]Var[intVar] = doubleVar * double[]Var[intVar];
                    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <279, 281>
for (int j = 0; j < y0.length; ++j) {
                        correctedScaled[j] = stepSize * yDot[j];
                    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <260, 262>
for (int j = 0; j < y0.length; ++j) {
                        predictedScaled[j] = stepSize * yDot[j];
                    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <260, 262>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
                        double[]Var[intVar] = doubleVar * double[]Var[intVar];
                    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <260, 262>
for (int j = 0; j < y0.length; ++j) {
                        predictedScaled[j] = stepSize * yDot[j];
                    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <353, 361>
while (n < 1000 * mean) {
                rnd = generator.nextDouble();
                r = r * rnd;
                if (r >= p) {
                    n++;
                } else {
                    return n;
                }
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.RandomDataImpl <353, 361>
while (longVar < 1000 * doubleVar) {
                doubleVar = RandomGenerator.nextDouble();
                doubleVar = doubleVar * doubleVar;
                if (doubleVar >= doubleVar) {
                    longVar++;
                } else {
                    return longVar;
                }
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.RandomDataImpl <353, 361>
while (n < 1000 * mean) {
                rnd = RandomGenerator.nextDouble();
                r = r * rnd;
                if (r >= p) {
                    n++;
                } else {
                    return n;
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <712, 715>
for (int j = 0; j < y0.length; ++j) {
              final double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j];
              error += e * e;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <712, 715>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
              final double e = Math.abs(double[]Var[intVar] - double[][]Var[0][intVar]) / double[]Var[intVar];
              doubleVar += e * e;
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <712, 715>
for (int j = 0; j < y0.length; ++j) {
              final double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j];
              error += e * e;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.StatUtils <617, 621>
for (int i = 0; i < n; i++) {
            diff = sample1[i] - sample2[i];
            sum1 += (diff - meanDifference) *(diff - meanDifference);
            sum2 += diff - meanDifference;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.StatUtils <617, 621>
for (int intVar = 0; intVar < intVar; intVar++) {
            doubleVar = double[]Var[intVar] - double[]Var[intVar];
            doubleVar += (doubleVar - doubleVar) *(doubleVar - doubleVar);
            doubleVar += doubleVar - doubleVar;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.StatUtils <617, 621>
for (int i = 0; i < n; i++) {
            diff = sample1[i] - sample2[i];
            sum1 += (diff - meanDifference) *(diff - meanDifference);
            sum2 += diff - meanDifference;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <233, 235>
for (int j = 0; j < y0.length; ++j) {
      y1[j] = y0[j] + h * yDot0[j];
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <233, 235>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
      double[]Var[intVar] = double[]Var[intVar] + doubleVar * double[]Var[intVar];
    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <233, 235>
for (int j = 0; j < y0.length; ++j) {
      y1[j] = y0[j] + h * yDot0[j];
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer <306, 308>
for (int j = 0; j < dataI.length; ++j) {
                dataI[j] += c1I * (start[j] - end[j]);
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer <306, 308>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
                double[]Var[intVar] += doubleVar * (double[]Var[intVar] - double[]Var[intVar]);
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer <306, 308>
for (int j = 0; j < dataI.length; ++j) {
                dataI[j] += c1I * (start[j] - end[j]);
            }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <488, 490>
for (int j = 0; j < m; ++j) {
                        s += v.getEntry(j) * b.getEntry(j, k);
                    }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <488, 490>
for (int intVar = 0; intVar < intVar; ++intVar) {
                        doubleVar += ArrayRealVector.getEntry(intVar) * RealMatrix.getEntry(intVar, intVar);
                    }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <488, 490>
for (int j = 0; j < m; ++j) {
                        s += ArrayRealVector.getEntry(j) * RealMatrix.getEntry(j, k);
                    }

---fix ingredient(SameMethod)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1136, 1143>
for (int i = 0; i < j; i += 4) {
                for (int k = 0; k < 4; k += step) {
                    final double tmp = work[i + k];
                    work[i + k] = work[j - k];
                    work[j - k] = tmp;
                }
                j -= 4;
            }

---fix ingredient(SameMethod)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <1136, 1143>
for (int intVar = 0; intVar < intVar; intVar += 4) {
                for (int k = 0; k < 4; k += intVar) {
                    final double tmp = double[]Var[intVar + k];
                    double[]Var[intVar + k] = double[]Var[intVar - k];
                    double[]Var[intVar - k] = tmp;
                }
                intVar -= 4;
            }

---fix ingredient(SameMethod)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1136, 1143>
for (int i = 0; i < j; i += 4) {
                for (int k = 0; k < 4; k += step) {
                    final double tmp = work[i + k];
                    work[i + k] = work[j - k];
                    work[j - k] = tmp;
                }
                j -= 4;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <240, 243>
for (int j = 0; j < y0.length; ++j) {
      ratio         = (yDot1[j] - yDot0[j]) / scale[j];
      yDDotOnScale += ratio * ratio;
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <240, 243>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
      doubleVar         = (double[]Var[intVar] - double[]Var[intVar]) / double[]Var[intVar];
      doubleVar += doubleVar * doubleVar;
    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <240, 243>
for (int j = 0; j < y0.length; ++j) {
      ratio         = (yDot1[j] - yDot0[j]) / scale[j];
      yDDotOnScale += ratio * ratio;
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <582, 584>
for (int i = j + 1; i < solvedCols; ++i) {
                    work1[permutation[i]] -= jacobian[i][pj] * tmp;
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <582, 584>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                    double[]Var[int[]Var[intVar]] -= double[][]Var[intVar][intVar] * doubleVar;
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <582, 584>
for (int i = j + 1; i < solvedCols; ++i) {
                    work1[permutation[i]] -= jacobian[i][pj] * tmp;
                }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <361, 372>
for (int j = k + 1; j < n; ++j) {
                        double beta = 0;
                        for (int i = k + 1; i < m; ++i) {
                            final double[] hI = householderVectors[i];
                            beta -= hI[j] * hI[k];
                        }
                        beta /= b * hKp1[k];
                        for (int i = k + 1; i < m; ++i) {
                            final double[] hI = householderVectors[i];
                            hI[j] -= beta * hI[k];
                        }
                    }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <361, 372>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                        double beta = 0;
                        for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                            final double[] hI = doubleVar[intVar];
                            beta -= hI[intVar] * hI[intVar];
                        }
                        beta /= doubleVar * double[]Var[intVar];
                        for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                            final double[] hI = doubleVar[intVar];
                            hI[intVar] -= beta * hI[intVar];
                        }
                    }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <361, 372>
for (int j = k + 1; j < n; ++j) {
                        double beta = 0;
                        for (int i = k + 1; i < m; ++i) {
                            final double[] hI = householderVectors[i];
                            beta -= hI[j] * hI[k];
                        }
                        beta /= b * hKp1[k];
                        for (int i = k + 1; i < m; ++i) {
                            final double[] hI = householderVectors[i];
                            hI[j] -= beta * hI[k];
                        }
                    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <539, 545>
for (int j = 1; j < k; ++j) {
      for (int i = 0; i < last.length; ++i) {
        // Aitken-Neville's recursive formula
        diag[k-j-1][i] = diag[k-j][i] +
                         coeff[k+offset][j-1] * (diag[k-j][i] - diag[k-j-1][i]);
      }
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <539, 545>
for (int intVar = 1; intVar < intVar; ++intVar) {
      for (int i = 0; i < double[]Var.length; ++i) {
        // Aitken-Neville's recursive formula
        double[][]Var[intVar-intVar-1][i] = double[][]Var[intVar-intVar][i] +
                         double[][]Var[intVar+intVar][intVar-1] * (double[][]Var[intVar-intVar][i] - double[][]Var[intVar-intVar-1][i]);
      }
    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <539, 545>
for (int j = 1; j < k; ++j) {
      for (int i = 0; i < last.length; ++i) {
        // Aitken-Neville's recursive formula
        diag[k-j-1][i] = diag[k-j][i] +
                         coeff[k+offset][j-1] * (diag[k-j][i] - diag[k-j-1][i]);
      }
    }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.TriDiagonalTransformer <233, 237>
for (int j = i + 1; j < m; ++j) {
                        final double hIJ = hI[j];
                        zI   += hIJ * hK[j];
                        z[j] += hIJ * hKI;
                    }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.TriDiagonalTransformer <233, 237>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                        final double hIJ = double[]Var[intVar];
                        doubleVar   += hIJ * double[]Var[intVar];
                        double[]Var[intVar] += hIJ * doubleVar;
                    }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.TriDiagonalTransformer <233, 237>
for (int j = i + 1; j < m; ++j) {
                        final double hIJ = hI[j];
                        zI   += hIJ * hK[j];
                        z[j] += hIJ * hKI;
                    }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SingularValueDecompositionImpl <221, 224>
for (int j = 0; j < m; ++j) {
                        ei0[j] = (mainBidiagonal[i] * ei0[j] +
                                  secondaryBidiagonal[i] * ei1[j]) / singularValues[j];
                    }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.SingularValueDecompositionImpl <221, 224>
for (int intVar = 0; intVar < intVar; ++intVar) {
                        double[]Var[intVar] = (double[]Var[intVar] * double[]Var[intVar] +
                                  double[]Var[intVar] * double[]Var[intVar]) / double[]Var[intVar];
                    }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.SingularValueDecompositionImpl <221, 224>
for (int j = 0; j < m; ++j) {
                        ei0[j] = (mainBidiagonal[i] * ei0[j] +
                                  secondaryBidiagonal[i] * ei1[j]) / singularValues[j];
                    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <713, 720>
for (int j = nSing - 1; j >= 0; --j) {
                int pj = permutation[j];
                double sum = 0;
                for (int i = j + 1; i < nSing; ++i) {
                    sum += jacobian[i][pj] * work[i];
                }
                work[j] = (work[j] - sum) / lmDiag[j];
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <713, 720>
for (int intVar = intVar - 1; intVar >= 0; --intVar) {
                int pj = int[]Var[intVar];
                double sum = 0;
                for (int i = intVar + 1; i < intVar; ++i) {
                    sum += double[][]Var[i][pj] * double[]Var[i];
                }
                double[]Var[intVar] = (double[]Var[intVar] - sum) / double[]Var[intVar];
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <713, 720>
for (int j = nSing - 1; j >= 0; --j) {
                int pj = permutation[j];
                double sum = 0;
                for (int i = j + 1; i < nSing; ++i) {
                    sum += jacobian[i][pj] * work[i];
                }
                work[j] = (work[j] - sum) / lmDiag[j];
            }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <219, 225>
for (int j = i + 1; j < columns; ++j) {
                final double mij = matrix.getEntry(i, j);
                final double mji = matrix.getEntry(j, i);
                if (Math.abs(mij - mji) > (Math.max(Math.abs(mij), Math.abs(mji)) * eps)) {
                    return false;
                }
            }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <219, 225>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                final double mij = RealMatrix.getEntry(intVar, intVar);
                final double mji = RealMatrix.getEntry(intVar, intVar);
                if (Math.abs(mij - mji) > (Math.max(Math.abs(mij), Math.abs(mji)) * doubleVar)) {
                    return false;
                }
            }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <219, 225>
for (int j = i + 1; j < columns; ++j) {
                final double mij = RealMatrix.getEntry(i, j);
                final double mji = RealMatrix.getEntry(j, i);
                if (Math.abs(mij - mji) > (Math.max(Math.abs(mij), Math.abs(mji)) * eps)) {
                    return false;
                }
            }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1162, 1165>
for (int i = 0; i < n; ++i) {
            lower = Math.min(lower, work[lowerStart + index +i]);
            upper = Math.max(upper, work[upperStart + index +i]);
        }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <1162, 1165>
for (int intVar = 0; intVar < intVar; ++intVar) {
            doubleVar = Math.min(doubleVar, double[]Var[intVar + intVar +intVar]);
            doubleVar = Math.max(doubleVar, double[]Var[intVar + intVar +intVar]);
        }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1162, 1165>
for (int i = 0; i < n; ++i) {
            lower = Math.min(lower, work[lowerStart + index +i]);
            upper = Math.max(upper, work[upperStart + index +i]);
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockFieldMatrix <616, 620>
sum = sum.
                                      add(tBlock[l].multiply(mBlock[n])).
                                      add(tBlock[l + 1].multiply(mBlock[n + jWidth])).
                                      add(tBlock[l + 2].multiply(mBlock[n + jWidth2])).
                                      add(tBlock[l + 3].multiply(mBlock[n + jWidth3]));

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockFieldMatrix <616, 620>
TVar = TVar.
                                      add(T[]Var[intVar].multiply(T[]Var[intVar])).
                                      add(T[]Var[intVar + 1].multiply(T[]Var[intVar + intVar])).
                                      add(T[]Var[intVar + 2].multiply(T[]Var[intVar + intVar])).
                                      add(T[]Var[intVar + 3].multiply(T[]Var[intVar + intVar]));

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BlockFieldMatrix <616, 620>
sum = sum.
                                      add(tBlock[l].multiply(mBlock[n])).
                                      add(tBlock[l + 1].multiply(mBlock[n + jWidth])).
                                      add(tBlock[l + 2].multiply(mBlock[n + jWidth2])).
                                      add(tBlock[l + 3].multiply(mBlock[n + jWidth3]));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <574, 577>
for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                work1[pj] = work3[pj] * diag[pj] / dxNorm;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <574, 577>
for (int intVar = 0; intVar < intVar; ++intVar) {
                int pj = int[]Var[intVar];
                double[]Var[pj] = double[]Var[pj] * double[]Var[pj] / doubleVar;
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <574, 577>
for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                work1[pj] = work3[pj] * diag[pj] / dxNorm;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <617, 620>
for (int j = 0; j < solvedCols; ++j) {
       int pj = permutation[j];
        work1[pj] = work3[pj] * diag[pj] / dxNorm;
      }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <617, 620>
for (int intVar = 0; intVar < intVar; ++intVar) {
       int pj = int[]Var[intVar];
        double[]Var[pj] = double[]Var[pj] * double[]Var[pj] / doubleVar;
      }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <617, 620>
for (int j = 0; j < solvedCols; ++j) {
       int pj = permutation[j];
        work1[pj] = work3[pj] * diag[pj] / dxNorm;
      }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.QRDecompositionImpl <157, 162>
for (int row = Math.min(m, n) - 1; row >= 0; row--) {
                cachedR.setEntry(row, row, rDiag[row]);
                for (int col = row + 1; col < n; col++) {
                    cachedR.setEntry(row, col, qrt[col][row]);
                }
            }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.QRDecompositionImpl <157, 162>
for (int intVar = Math.min(intVar, intVar) - 1; intVar >= 0; intVar--) {
                RealMatrix.setEntry(intVar, intVar, double[]Var[intVar]);
                for (int col = intVar + 1; col < intVar; col++) {
                    RealMatrix.setEntry(intVar, col, double[][]Var[col][intVar]);
                }
            }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.QRDecompositionImpl <157, 162>
for (int row = Math.min(m, n) - 1; row >= 0; row--) {
                RealMatrix.setEntry(row, row, rDiag[row]);
                for (int col = row + 1; col < n; col++) {
                    RealMatrix.setEntry(row, col, qrt[col][row]);
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <219, 224>
for (int j = 0; j < y0.length; ++j) {
      ratio         = y0[j] / scale[j];
      yOnScale2    += ratio * ratio;
      ratio         = yDot0[j] / scale[j];
      yDotOnScale2 += ratio * ratio;
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <219, 224>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
      doubleVar         = double[]Var[intVar] / double[]Var[intVar];
      doubleVar    += doubleVar * doubleVar;
      doubleVar         = double[]Var[intVar] / double[]Var[intVar];
      doubleVar += doubleVar * doubleVar;
    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <219, 224>
for (int j = 0; j < y0.length; ++j) {
      ratio         = y0[j] / scale[j];
      yOnScale2    += ratio * ratio;
      ratio         = yDot0[j] / scale[j];
      yDotOnScale2 += ratio * ratio;
    }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.TriDiagonalTransformer <119, 129>
for (int j = k + 1; j < m; ++j) {
                        beta = 0;
                        for (int i = k + 1; i < m; ++i) {
                            beta += cachedQt.getEntry(j, i) * hK[i];
                        }
                        beta *= inv;
                        cachedQt.setEntry(j, k, beta * hK[k]);
                        for (int i = k + 1; i < m; ++i) {
                            cachedQt.addToEntry(j, i, beta * hK[i]);
                        }
                    }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.TriDiagonalTransformer <119, 129>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                        doubleVar = 0;
                        for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                            doubleVar += RealMatrix.getEntry(intVar, intVar) * double[]Var[intVar];
                        }
                        doubleVar *= doubleVar;
                        RealMatrix.setEntry(intVar, intVar, doubleVar * double[]Var[intVar]);
                        for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                            RealMatrix.addToEntry(intVar, intVar, doubleVar * double[]Var[intVar]);
                        }
                    }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.TriDiagonalTransformer <119, 129>
for (int j = k + 1; j < m; ++j) {
                        beta = 0;
                        for (int i = k + 1; i < m; ++i) {
                            beta += RealMatrix.getEntry(j, i) * hK[i];
                        }
                        beta *= inv;
                        RealMatrix.setEntry(j, k, beta * hK[k]);
                        for (int i = k + 1; i < m; ++i) {
                            RealMatrix.addToEntry(j, i, beta * hK[i]);
                        }
                    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <280, 290>
for (int j = 0; j < solvedCols; ++j) {
                    int    pj = permutation[j];
                    double s  = jacNorm[pj];
                    if (s != 0) {
                        double sum = 0;
                        for (int i = 0; i <= j; ++i) {
                            sum += jacobian[i][pj] * residuals[i];
                        }
                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                    }
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <280, 290>
for (int intVar = 0; intVar < intVar; ++intVar) {
                    int    pj = int[]Var[intVar];
                    double s  = double[]Var[pj];
                    if (s != 0) {
                        double sum = 0;
                        for (int i = 0; i <= intVar; ++i) {
                            sum += double[][]Var[i][pj] * double[]Var[i];
                        }
                        doubleVar = Math.max(doubleVar, Math.abs(sum) / (s * doubleVar));
                    }
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <280, 290>
for (int j = 0; j < solvedCols; ++j) {
                    int    pj = permutation[j];
                    double s  = jacNorm[pj];
                    if (s != 0) {
                        double sum = 0;
                        for (int i = 0; i <= j; ++i) {
                            sum += jacobian[i][pj] * residuals[i];
                        }
                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                    }
                }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <531, 538>
for (int j = 0; j < m; ++j) {
                    double invIJ = 0;
                    for (int k = 0; k < m; ++k) {
                        final double[] vK = eigenvectors[k].getDataRef();
                        invIJ += vK[i] * vK[j] / realEigenvalues[k];
                    }
                    invI[j] = invIJ;
                }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <531, 538>
for (int intVar = 0; intVar < intVar; ++intVar) {
                    double invIJ = 0;
                    for (int k = 0; k < intVar; ++k) {
                        final double[] vK = ArrayRealVector[]Var[k].getDataRef();
                        invIJ += vK[intVar] * vK[intVar] / double[]Var[k];
                    }
                    double[]Var[intVar] = invIJ;
                }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <531, 538>
for (int j = 0; j < m; ++j) {
                    double invIJ = 0;
                    for (int k = 0; k < m; ++k) {
                        final double[] vK = eigenvectors[k].getDataRef();
                        invIJ += vK[i] * vK[j] / realEigenvalues[k];
                    }
                    invI[j] = invIJ;
                }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.CholeskyDecompositionImpl <318, 324>
for (int i = j + 1; i < m; i++) {
                    final double[] xI = x[i];
                    final double lJI = lJ[i];
                    for (int k = 0; k < nColB; ++k) {
                        xI[k] -= xJ[k] * lJI;
                    }
                }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.CholeskyDecompositionImpl <318, 324>
for (int intVar = intVar + 1; intVar < intVar; intVar++) {
                    final double[] xI = double[][]Var[intVar];
                    final double lJI = double[]Var[intVar];
                    for (int intVar = 0; intVar < intVar; ++intVar) {
                        xI[intVar] -= double[]Var[intVar] * lJI;
                    }
                }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.CholeskyDecompositionImpl <318, 324>
for (int i = j + 1; i < m; i++) {
                    final double[] xI = x[i];
                    final double lJI = lJ[i];
                    for (int k = 0; k < nColB; ++k) {
                        xI[k] -= xJ[k] * lJI;
                    }
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <372, 379>
for (int i = 0; i < n; ++i) {
            final double[] confI   = startConfiguration[i];
            final double[] vertexI = new double[n];
            for (int k = 0; k < n; ++k) {
                vertexI[k] = startPoint[k] + confI[k];
            }
            simplex[i + 1] = new RealPointValuePair(vertexI, Double.NaN);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <372, 379>
for (int intVar = 0; intVar < intVar; ++intVar) {
            final double[] confI   = double[][]Var[intVar];
            final double[] vertexI = new double[intVar];
            for (int k = 0; k < intVar; ++k) {
                vertexI[k] = double[]Var[k] + confI[k];
            }
            RealPointValuePair[]Var[intVar + 1] = new RealPointValuePair(vertexI, Double.NaN);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <372, 379>
for (int i = 0; i < n; ++i) {
            final double[] confI   = startConfiguration[i];
            final double[] vertexI = new double[n];
            for (int k = 0; k < n; ++k) {
                vertexI[k] = startPoint[k] + confI[k];
            }
            simplex[i + 1] = new RealPointValuePair(vertexI, Double.NaN);
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.CholeskyDecompositionImpl <115, 125>
for (int j = i + 1; j < order; ++j) {
                final double[] lJ = lTData[j];
                final double lIJ = lI[j];
                final double lJI = lJ[i];
                final double maxDelta =
                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
                if (Math.abs(lIJ - lJI) > maxDelta) {
                    throw new NotSymmetricMatrixException();
                }
                lJ[i] = 0;
           }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.CholeskyDecompositionImpl <115, 125>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                final double[] lJ = double[][]Var[intVar];
                final double lIJ = double[]Var[intVar];
                final double lJI = lJ[intVar];
                final double maxDelta =
                    doubleVar * Math.max(Math.abs(lIJ), Math.abs(lJI));
                if (Math.abs(lIJ - lJI) > maxDelta) {
                    throw new NotSymmetricMatrixException();
                }
                lJ[intVar] = 0;
           }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.CholeskyDecompositionImpl <115, 125>
for (int j = i + 1; j < order; ++j) {
                final double[] lJ = lTData[j];
                final double lIJ = lI[j];
                final double lJI = lJ[i];
                final double maxDelta =
                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
                if (Math.abs(lIJ - lJI) > maxDelta) {
                    throw new NotSymmetricMatrixException();
                }
                lJ[i] = 0;
           }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <314, 326>
for (int j = 0; j < solvedCols; ++j) {
          int    pj = permutation[j];
          double s  = jacNorm[pj];
          if (s != 0) {
            double sum = 0;
            int index = pj;
            for (int i = 0; i <= j; ++i) {
              sum += jacobian[index] * residuals[i];
              index += cols;
            }
            maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
          }
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <314, 326>
for (int intVar = 0; intVar < intVar; ++intVar) {
          int    pj = int[]Var[intVar];
          double s  = double[]Var[pj];
          if (s != 0) {
            double sum = 0;
            int index = pj;
            for (int i = 0; i <= intVar; ++i) {
              sum += double[]Var[index] * double[]Var[i];
              index += intVar;
            }
            doubleVar = Math.max(doubleVar, Math.abs(sum) / (s * doubleVar));
          }
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <314, 326>
for (int j = 0; j < solvedCols; ++j) {
          int    pj = permutation[j];
          double s  = jacNorm[pj];
          if (s != 0) {
            double sum = 0;
            int index = pj;
            for (int i = 0; i <= j; ++i) {
              sum += jacobian[index] * residuals[i];
              index += cols;
            }
            maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
          }
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <519, 527>
for (int j = 0; j < solvedCols; ++j) {
            int pj = permutation[j];
            double sum = 0;
            for (int i = 0; i <= j; ++i) {
                sum += jacobian[i][pj] * qy[i];
            }
            sum /= diag[pj];
            sum2 += sum * sum;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <519, 527>
for (int intVar = 0; intVar < intVar; ++intVar) {
            int pj = int[]Var[intVar];
            double sum = 0;
            for (int i = 0; i <= intVar; ++i) {
                sum += double[][]Var[i][pj] * double[]Var[i];
            }
            sum /= double[]Var[pj];
            doubleVar += sum * sum;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <519, 527>
for (int j = 0; j < solvedCols; ++j) {
            int pj = permutation[j];
            double sum = 0;
            for (int i = 0; i <= j; ++i) {
                sum += jacobian[i][pj] * qy[i];
            }
            sum /= diag[pj];
            sum2 += sum * sum;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <504, 513>
for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double sum = 0;
                for (int i = 0; i < j; ++i) {
                    sum += jacobian[i][pj] * work1[permutation[i]];
                }
                double s = (work1[pj] - sum) / diagR[pj];
                work1[pj] = s;
                sum2 += s * s;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <504, 513>
for (int intVar = 0; intVar < intVar; ++intVar) {
                int pj = int[]Var[intVar];
                double sum = 0;
                for (int i = 0; i < intVar; ++i) {
                    sum += double[][]Var[i][pj] * double[]Var[int[]Var[i]];
                }
                double s = (double[]Var[pj] - sum) / double[]Var[pj];
                double[]Var[pj] = s;
                doubleVar += s * s;
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <504, 513>
for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double sum = 0;
                for (int i = 0; i < j; ++i) {
                    sum += jacobian[i][pj] * work1[permutation[i]];
                }
                double s = (work1[pj] - sum) / diagR[pj];
                work1[pj] = s;
                sum2 += s * s;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <521, 521>
yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <521, 521>
double[]Var[intVar] = 0.5 * (double[]Var[intVar] + double[]Var[intVar] + doubleVar * double[][]Var[intVar][intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <521, 521>
yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <543, 554>
for (int j = 0; j < solvedCols; ++j) {
        int pj = permutation[j];
        double sum = 0;
        int index = pj;
        for (int i = 0; i < j; ++i) {
          sum += jacobian[index] * work1[permutation[i]];
          index += cols;
        }
        double s = (work1[pj] - sum) / diagR[pj];
        work1[pj] = s;
        sum2 += s * s;
      }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <543, 554>
for (int intVar = 0; intVar < intVar; ++intVar) {
        int pj = int[]Var[intVar];
        double sum = 0;
        int index = pj;
        for (int i = 0; i < intVar; ++i) {
          sum += double[]Var[index] * double[]Var[int[]Var[i]];
          index += intVar;
        }
        double s = (double[]Var[pj] - sum) / double[]Var[pj];
        double[]Var[pj] = s;
        doubleVar += s * s;
      }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <543, 554>
for (int j = 0; j < solvedCols; ++j) {
        int pj = permutation[j];
        double sum = 0;
        int index = pj;
        for (int i = 0; i < j; ++i) {
          sum += jacobian[index] * work1[permutation[i]];
          index += cols;
        }
        double s = (work1[pj] - sum) / diagR[pj];
        work1[pj] = s;
        sum2 += s * s;
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.AggregateSummaryStatistics <330, 330>
m2 = m2 + current.getSecondMoment() + meanDiff * meanDiff * oldN * curN / n;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.AggregateSummaryStatistics <330, 330>
doubleVar = doubleVar + SummaryStatistics.getSecondMoment() + doubleVar * doubleVar * doubleVar * doubleVar / longVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.AggregateSummaryStatistics <330, 330>
m2 = m2 + SummaryStatistics.getSecondMoment() + meanDiff * meanDiff * oldN * curN / n;

