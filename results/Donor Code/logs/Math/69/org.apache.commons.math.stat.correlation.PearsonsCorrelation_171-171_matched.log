---patch code ori--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <171, 171>
out[i][j] = 2 * tDistribution.cumulativeProbability(-t);

---fix ingredient(SameMethod)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <171, 171>
out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));

---patch code 0--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <171, 171>
double[][]Var[intVar][intVar] = 2 * TDistribution.cumulativeProbability(-doubleVar);

---fix ingredient(SameMethod)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <171, 171>
double[][]Var[intVar][intVar] = 2 * (1 - TDistribution.cumulativeProbability(doubleVar));

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <141, 141>
out[i][j] = Math.sqrt((1 - r * r) /(nObs - 2));

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <141, 141>
double[][]Var[intVar][intVar] = Math.sqrt((1 - doubleVar * doubleVar) /(intVar - 2));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <987, 987>
out.setEntry(i, j, data[i] * v[j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <987, 987>
RealMatrix.setEntry(intVar, intVar, doubleVar[intVar] * double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <960, 960>
out.setEntry(i, j, data[i] * v.getEntry(j));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <960, 960>
RealMatrix.setEntry(intVar, intVar, doubleVar[intVar] * RealVector.getEntry(intVar));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <216, 216>
double[]Var[intVar] *= doubleVar / (intVar + 1);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <537, 537>
e[i + 1] = p * t;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <537, 537>
double[]Var[intVar + 1] = doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <543, 543>
e[i + 1] = q * t;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <543, 543>
double[]Var[intVar + 1] = doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <498, 498>
computeDerivatives(t, yEnd, f[j+1]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <498, 498>
computeDerivatives(doubleVar, double[]Var, double[][]Var[intVar+1]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <579, 579>
out.setEntry(i, j, data[i].multiply(v[j]));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.sampling.DummyStepInterpolator <124, 124>
out.writeDouble(currentDerivative[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.sampling.AbstractStepInterpolator <386, 386>
out.writeDouble(currentState[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <235, 235>
out.writeDouble(scaled[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <791, 791>
out.writeDouble(array[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <803, 803>
writeArray(out, array[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <263, 263>
final double t = y[i] / d;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <263, 263>
final double doubleVar = doubleVar[intVar] / doubleVar;

---patch code 1--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <171, 171>
out[i][j] = 2 * TDistribution.cumulativeProbability(-t);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <263, 263>
final double t = y[i] / d;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <278, 278>
dataI[j] = getEntry(i, j);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <553, 553>
out[i] = getEntry(row, i);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <585, 585>
out[i] = getEntry(i, column);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <611, 611>
out[i] *= v.getEntry(i);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <649, 649>
out[i] /= v.getEntry(i);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <185, 185>
dataI[j] = getEntry(i, j);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <528, 528>
out[i] = getEntry(row, i);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <560, 560>
out[i] = getEntry(i, column);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <251, 251>
doubleVar *= doubleVar[intVar] - doubleVar[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <271, 271>
coefficients[j] += t * tc[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <271, 271>
doubleVar[intVar] += doubleVar * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator <145, 145>
out.writeDouble(yDotK[k][i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <282, 282>
double[][]Var[intVar][intVar] = doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <283, 283>
double[][]Var[intVar][intVar] = doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.AbstractEstimator <229, 229>
double[][]Var[intVar][intVar] = doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.AbstractEstimator <230, 230>
double[][]Var[intVar][intVar] = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1317, 1317>
res.append(data[i][j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <293, 293>
out[i] += v[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <334, 334>
out[i] -= v[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <624, 624>
out[i] *= v[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <662, 662>
out[i] /= v[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <213, 213>
result = result * i / j;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <675, 675>
sum += Math.abs(block[i * jWidth + j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockRealMatrix <675, 675>
doubleVar += Math.abs(double[]Var[intVar * intVar + intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <341, 341>
c = polynoms[j][i] + c * d * theta05;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <341, 341>
doubleVar = double[][]Var[intVar][intVar] + doubleVar * doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.linear.SimplexTableau <329, 329>
matrix[i - 1][col++] = tableau.getEntry(i, j);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <1179, 1179>
out[i] = values[i] * normalizedSum / sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <1179, 1179>
double[]Var[intVar] = double[]Var[intVar] * doubleVar / doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <315, 315>
out[i] = data[i].add(d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <332, 332>
out[i] = data[i].subtract(d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <349, 349>
out[i] = data[i].multiply(d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <366, 366>
out[i] = data[i].divide(d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <384, 384>
out[i] = one.divide(data[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <1197, 1197>
out[outIndex++] = block[i * jWidth + jColumn];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockFieldMatrix <1171, 1171>
out[outIndex++] = block[i * jWidth + jColumn];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <196, 196>
cachedV.addToEntry(i, j, -beta * hK[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <196, 196>
RealMatrix.addToEntry(intVar, intVar, -doubleVar * double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <408, 410>
throw MathRuntimeException.createIllegalArgumentException(
                          "element ({0}, {1}) is negative: {2}",
                          i, j, in[i][j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.TriDiagonalTransformer <122, 122>
beta += cachedQt.getEntry(j, i) * hK[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.TriDiagonalTransformer <122, 122>
doubleVar += RealMatrix.getEntry(intVar, intVar) * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <191, 191>
beta -= cachedV.getEntry(i, j) * hK[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <191, 191>
doubleVar -= RealMatrix.getEntry(intVar, intVar) * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <407, 407>
result += coeff[i][j] * pX[i] * pY[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <407, 407>
doubleVar += double[][]Var[intVar][intVar] * double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.CholeskyDecompositionImpl <236, 236>
x[i] -= xJ * lTData[i][j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.CholeskyDecompositionImpl <236, 236>
double[]Var[intVar] -= doubleVar * double[][]Var[intVar][intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.CholeskyDecompositionImpl <275, 275>
x[i] -= xJ * lTData[i][j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.CholeskyDecompositionImpl <275, 275>
double[]Var[intVar] -= doubleVar * double[][]Var[intVar][intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <420, 420>
f[i+j+k] = f[j+k].subtract(z);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <553, 553>
t = (realEigenvalues[i] - q) * s + 2.0 * c * h;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <553, 553>
doubleVar = (double[]Var[intVar] - doubleVar) * doubleVar + 2.0 * doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <298, 298>
splines[i][j][k] = new TricubicSplineFunction(computeSplineCoefficients(beta));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <73, 73>
productsSums[k++] += v[i] * v[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.AbstractEstimator <227, 227>
doubleVar += double[]Var[intVar + intVar] * double[]Var[intVar + intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <439, 439>
doubleVar += double[]Var[intVar] * double[]Var[intVar] / double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.LUDecompositionImpl <174, 174>
cachedL.setEntry(i, j, luI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.LUDecompositionImpl <190, 190>
cachedU.setEntry(i, j, luI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <494, 494>
visitor.visit(i, j, rowI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <530, 530>
visitor.visit(i, j, rowI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.FieldLUDecompositionImpl <162, 162>
cachedL.setEntry(i, j, luI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.FieldLUDecompositionImpl <178, 178>
cachedU.setEntry(i, j, luI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <502, 502>
visitor.visit(i, j, rowI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <538, 538>
visitor.visit(i, j, rowI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <490, 490>
visitor.visit(i, j, rowI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <526, 526>
visitor.visit(i, j, rowI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <228, 228>
throw new DimensionMismatchException(f[i][j].length, zLen);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <231, 231>
throw new DimensionMismatchException(dFdX[i][j].length, zLen);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <234, 234>
throw new DimensionMismatchException(dFdY[i][j].length, zLen);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <237, 237>
throw new DimensionMismatchException(dFdZ[i][j].length, zLen);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <240, 240>
throw new DimensionMismatchException(d2FdXdY[i][j].length, zLen);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <243, 243>
throw new DimensionMismatchException(d2FdXdZ[i][j].length, zLen);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <246, 246>
throw new DimensionMismatchException(d2FdYdZ[i][j].length, zLen);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <249, 249>
throw new DimensionMismatchException(d3FdXdYdZ[i][j].length, zLen);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <172, 172>
return splines[i][j].value(xN, yN);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <172, 172>
return BicubicSplineFunction[][]Var[intVar][intVar].value(doubleVar, doubleVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.TriDiagonalTransformer <127, 127>
cachedQt.addToEntry(j, i, beta * hK[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.TriDiagonalTransformer <127, 127>
RealMatrix.addToEntry(intVar, intVar, doubleVar * double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <427, 427>
setEntry(row + i, column + j, subMatrix[i][j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <400, 400>
setEntry(row + i, column + j, subMatrix[i][j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <219, 219>
newCoefficients[i] += coefficients[j] * p.coefficients[i-j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <219, 219>
double[]Var[intVar] += doubleVar[intVar] * PolynomialFunction.doubleVar[intVar-intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.CorrelatedRandomVectorGenerator <295, 295>
correlated[i] += root.getEntry(i, j) * normalized[j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator <100, 100>
xFitter.addObservedPoint(1, xval[i], fval[i][j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator <122, 122>
yFitter.addObservedPoint(1, yval[j], fval_1[i][j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <392, 392>
destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <260, 260>
out[i] = data[i].add(v[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <295, 295>
out[i] = data[i].subtract(v[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <419, 419>
out[i] = data[i].multiply(v[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <456, 456>
out[i] = data[i].divide(v[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <365, 365>
destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <238, 238>
result = mulAndCheck(result / (j / d), i / d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <270, 270>
tc[j] = c[j+1] + tc[j+1] * x[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <270, 270>
double[]Var[intVar] = double[]Var[intVar+1] + double[]Var[intVar+1] * doubleVar[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm <187, 187>
coefficients[j] = coefficients[j-1] - c[i] * coefficients[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm <187, 187>
doubleVar[intVar] = doubleVar[intVar-1] - doubleVar[intVar] * doubleVar[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <239, 239>
double[]Var[intVar] = double[]Var[intVar-1] - double[]Var[intVar] * doubleVar[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <347, 347>
F[2*N-i] = F[i].conjugate();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <249, 249>
out[i] = data[i].add(v.getEntry(i));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <284, 284>
out[i] = data[i].subtract(v.getEntry(i));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <407, 407>
out[i] = data[i].multiply(v.getEntry(i));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <444, 444>
out[i] = data[i].divide(v.getEntry(i));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <110, 110>
alpha -= cachedU.getEntry(i, j) * householderVectors[i][k - diagOffset];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <110, 110>
doubleVar -= RealMatrix.getEntry(intVar, intVar) * doubleVar[intVar][intVar - intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <561, 561>
visitor.visit(i, j, data[i][j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <596, 596>
visitor.visit(i, j, data[i][j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <569, 569>
visitor.visit(i, j, data[i][j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.Array2DRowRealMatrix <569, 569>
RealMatrixPreservingVisitor.visit(intVar, intVar, doubleVar[intVar][intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <604, 604>
visitor.visit(i, j, data[i][j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.Array2DRowRealMatrix <604, 604>
RealMatrixPreservingVisitor.visit(intVar, intVar, doubleVar[intVar][intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <557, 557>
visitor.visit(i, j, data[i][j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <557, 557>
RealMatrixPreservingVisitor.visit(intVar, intVar, doubleVar[intVar][intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <592, 592>
visitor.visit(i, j, data[i][j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <592, 592>
RealMatrixPreservingVisitor.visit(intVar, intVar, doubleVar[intVar][intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.QRDecompositionImpl <233, 233>
cachedH.setEntry(i, j, qrt[j][i] / -rDiag[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <115, 115>
cachedU.addToEntry(i, j, -alpha * householderVectors[i][k - diagOffset]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <115, 115>
RealMatrix.addToEntry(intVar, intVar, -doubleVar * doubleVar[intVar][intVar - intVar]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <280, 280>
doubleVar += double[][]Var[intVar][intVar] * double[][]Var[intVar][intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <480, 480>
result += a[i][j][k] * pX[i] * pY[j] * pZ[k];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <480, 480>
doubleVar += double[][][]Var[intVar][intVar][intVar] * double[]Var[intVar] * double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <494, 494>
yEnd[i]       = yTmp[i] + subStep2 * f[j][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <494, 494>
double[]Var[intVar]       = double[]Var[intVar] + doubleVar * double[][]Var[intVar][intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.ranking.NaturalRanking <271, 272>
outRanks[j] = new IntDoublePair(
                        ranks[i].getValue(), ranks[i].getPosition());

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolator <113, 113>
dFdX[i][j][k] = f.partialDerivativeX(x, y);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolator <113, 113>
double[][][]Var[intVar][intVar][intVar] = BicubicSplineInterpolatingFunction.partialDerivativeX(doubleVar, doubleVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolator <114, 114>
dFdY[i][j][k] = f.partialDerivativeY(x, y);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolator <114, 114>
double[][][]Var[intVar][intVar][intVar] = BicubicSplineInterpolatingFunction.partialDerivativeY(doubleVar, doubleVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolator <115, 115>
d2FdXdY[i][j][k] = f.partialDerivativeXY(x, y);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolator <115, 115>
double[][][]Var[intVar][intVar][intVar] = BicubicSplineInterpolatingFunction.partialDerivativeXY(doubleVar, doubleVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolator <129, 129>
dFdZ[i][j][k] = f.partialDerivativeY(y, z);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolator <129, 129>
double[][][]Var[intVar][intVar][intVar] = BicubicSplineInterpolatingFunction.partialDerivativeY(doubleVar, doubleVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolator <130, 130>
d2FdYdZ[i][j][k] = f.partialDerivativeXY(y, z);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolator <130, 130>
double[][][]Var[intVar][intVar][intVar] = BicubicSplineInterpolatingFunction.partialDerivativeXY(doubleVar, doubleVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolator <143, 143>
d2FdZdX[i][j][k] = f.partialDerivativeXY(z, x);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolator <143, 143>
double[][][]Var[intVar][intVar][intVar] = BicubicSplineInterpolatingFunction.partialDerivativeXY(doubleVar, doubleVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <248, 248>
result = partialDerivatives[which][i][j].value(xN, yN);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <248, 248>
doubleVar = BivariateRealFunction[][][]Var[intVar][intVar][intVar].value(doubleVar, doubleVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <612, 612>
System.arraycopy(data[i], 0, out[i], 0, data[i].length);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <620, 620>
System.arraycopy(data[i], 0, out[i], 0, data[i].length);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.Array2DRowRealMatrix <620, 620>
System.arraycopy(doubleVar[intVar], 0, double[][]Var[intVar], 0, data[i].length);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1448, 1448>
System.arraycopy(data[i], 0, out[i], 0, data[i].length);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <608, 608>
System.arraycopy(data[i], 0, out[i], 0, data[i].length);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <608, 608>
System.arraycopy(doubleVar[intVar], 0, double[][]Var[intVar], 0, data[i].length);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <478, 478>
rowI[j] = visitor.visit(i, j, rowI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <512, 512>
rowI[j] = visitor.visit(i, j, rowI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <546, 546>
rowI[j] = visitor.visit(i, j, rowI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <579, 579>
rowI[j] = visitor.visit(i, j, rowI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <486, 486>
rowI[j] = visitor.visit(i, j, rowI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <520, 520>
rowI[j] = visitor.visit(i, j, rowI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <554, 554>
rowI[j] = visitor.visit(i, j, rowI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <587, 587>
rowI[j] = visitor.visit(i, j, rowI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <474, 474>
rowI[j] = visitor.visit(i, j, rowI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <508, 508>
rowI[j] = visitor.visit(i, j, rowI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <542, 542>
rowI[j] = visitor.visit(i, j, rowI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <575, 575>
rowI[j] = visitor.visit(i, j, rowI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <677, 677>
jacobian[i * cols + pj] = jacobian[j * cols + permutation[i]];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <523, 523>
q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q - t);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <523, 523>
doubleVar = double[]Var[intVar] - double[]Var[intVar] + double[]Var[intVar] / (doubleVar - doubleVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <525, 525>
q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + t);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <525, 525>
doubleVar = double[]Var[intVar] - double[]Var[intVar] + double[]Var[intVar] / (doubleVar + doubleVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.CorrelatedRandomVectorGenerator <273, 273>
root.setEntry(index[i], j, b[i][j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <845, 845>
diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <845, 845>
double[][]Var[intVar-1][intVar] = doubleVar * double[][][]Var[intVar+intVar][intVar+intVar][intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <340, 340>
Complex A = z[N-i].conjugate();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <297, 297>
subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <270, 270>
subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <328, 328>
return splines[i][j][k].value(xN, yN, zN);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <328, 328>
return TricubicSplineFunction[][][]Var[intVar][intVar][intVar].value(doubleVar, doubleVar, doubleVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <93, 93>
double e = c * (n * productsSums[k++] - sums[i] * sums[j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <93, 93>
double doubleVar = doubleVar * (longVar * double[]Var[intVar++] - double[]Var[intVar] * double[]Var[intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <93, 93>
double e = c * (n * productsSums[k++] - sums[i] * sums[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <513, 513>
dFdY[i][j] = (tmpDot[i] - yDot[i]) / hY[j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <523, 523>
dFdP[i][j] = (tmpDot[i] - yDot[i]) / hP[j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <346, 346>
F[i] = B.subtract(C.multiply(D));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <382, 382>
simplex[i + 1] = new RealPointValuePair(vertexI, Double.NaN);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.MultistepIntegrator <344, 344>
multistep[i - 1] = msI;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <283, 283>
optima[i + 1]       = mIX;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <283, 283>
double[]Var[intVar + 1]       = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <284, 284>
optimaValues[i + 1] = mIY;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <284, 284>
double[]Var[intVar + 1] = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <293, 293>
optima[i + 1]       = currX;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <293, 293>
double[]Var[intVar + 1]       = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <294, 294>
optimaValues[i + 1] = currY;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <294, 294>
double[]Var[intVar + 1] = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser <175, 175>
observations[i + 1] = mI;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser <182, 182>
observations[i + 1] = curr;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.SingularValueDecompositionImpl <297, 297>
doubleVar=1.0 / double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <548, 548>
double[]Var[intVar + 1] -= doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastSineTransformer <246, 246>
transformed[2 * i]     = -y[i].getImaginary();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastSineTransformer <246, 246>
doubleVar[2 * intVar]     = -Complex[intVar].getImaginary();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <213, 213>
final double[] confI = startConfiguration[i - 1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <213, 213>
final double[] confI = startConfiguration[i - 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.integration.RombergIntegrator <92, 92>
final double tIJm1 = currentRow[j - 1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.integration.RombergIntegrator <92, 92>
final double doubleVar = doubleVar[intVar - 1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.integration.RombergIntegrator <92, 92>
final double tIJm1 = currentRow[j - 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.QRDecompositionImpl <417, 417>
final double   factor = 1.0 / rDiag[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.QRDecompositionImpl <417, 417>
final double   doubleVar = 1.0 / double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.QRDecompositionImpl <417, 417>
final double   factor = 1.0 / rDiag[j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.CholeskyDecompositionImpl <139, 139>
final double inverse = 1.0 / ltI[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.CholeskyDecompositionImpl <139, 139>
final double doubleVar = 1.0 / double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.CholeskyDecompositionImpl <139, 139>
final double inverse = 1.0 / ltI[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.AbstractMultipleLinearRegression <54, 56>
for (int j = 1; j < nvars + 1; j++) {
                x[i][j] = data[pointer++];
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.complex.Complex <795, 795>
double t = Math.sqrt((Math.abs(real) + abs()) / 2.0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.complex.Complex <795, 795>
double doubleVar = Math.sqrt((Math.abs(doubleVar) + abs()) / 2.0);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.complex.Complex <795, 795>
double t = Math.sqrt((Math.abs(real) + abs()) / 2.0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer <245, 245>
pI[j] = new BigFraction(aj * (j + 2));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastCosineTransformer <255, 255>
transformed[2 * i]     = y[i].getReal();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastCosineTransformer <255, 255>
doubleVar[2 * intVar]     = Complex[intVar].getReal();

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <257, 258>
double entry = covarianceMatrix.getEntry(i, j) /
                       (sigma * Math.sqrt(covarianceMatrix.getEntry(j, j)));

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <257, 258>
double doubleVar = RealMatrix.getEntry(intVar, intVar) /
                       (doubleVar * Math.sqrt(RealMatrix.getEntry(intVar, intVar)));

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <257, 258>
double entry = RealMatrix.getEntry(i, j) /
                       (sigma * Math.sqrt(RealMatrix.getEntry(j, j)));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <241, 241>
double[]Var[0] *= -doubleVar[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <816, 818>
for (int i=0;i<ncols;i++) {
            out[i] = data[row][i].doubleValue();
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <816, 818>
for (int i=0;i<ncols;i++) {
            out[i] = BigDecimal[row][i].doubleValue();
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <857, 859>
for (int i=0;i<nrows;i++) {
            out[i] = data[i][col].doubleValue();
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <857, 859>
for (int i=0;i<nrows;i++) {
            out[i] = BigDecimal[i][col].doubleValue();
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <398, 398>
f[i+2] = a.subtract(b);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <1023, 1023>
final double[] out = new double[data.length + 1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <1023, 1023>
final double[] double[]Var = new double[doubleVar.length + 1];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.ArrayRealVector <1023, 1023>
final double[] out = new double[data.length + 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <615, 615>
final T[] out = buildArray(data.length + 1);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Kurtosis <178, 178>
accum3 += Math.pow(values[i] - mean, 4.0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Kurtosis <178, 178>
doubleVar += Math.pow(double[]Var[intVar] - doubleVar, 4.0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer <169, 169>
shiftedP[i] = shiftedP[i - 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <850, 850>
yMidDots[l+1][i] *= stepSize;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <850, 850>
double[][]Var[intVar+1][intVar] *= doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <525, 525>
data[i] = 1.0 / data[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <525, 525>
doubleVar[intVar] = 1.0 / doubleVar[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <552, 552>
doubleVar = double[]Var[intVar + 1] - doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <555, 555>
double[]Var[intVar + 1] = doubleVar + doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <558, 558>
doubleVar = double[][]Var[intVar][intVar + 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <191, 191>
final double factor = -Math.sqrt(residualsWeights[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <191, 191>
final double doubleVar = -Math.sqrt(double[]Var[intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <191, 191>
final double factor = -Math.sqrt(residualsWeights[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <836, 838>
for (int i = 0; i < nRows; i++) {
            out[i] = data[i][col];
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <611, 613>
for (int j = 0; j < n; j++) {
                tmp[j] = z[j][i];
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.AbstractEstimator <185, 185>
criterion += wm[i].getWeight() * residual * residual;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.AbstractEstimator <185, 185>
doubleVar += WeightedMeasurement[]Var[intVar].getWeight() * doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <248, 248>
optima[i]       = Double.NaN;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <249, 249>
optimaValues[i] = Double.NaN;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <251, 251>
optima[i]       = Double.NaN;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <252, 252>
optimaValues[i] = Double.NaN;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <342, 342>
Complex C = z[i].subtract(A);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <514, 516>
for (int j = 0; j < nCols; j++) {
                d[i][j] = data[i][j].doubleValue();
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <514, 516>
for (int intVar = 0; intVar < intVar; intVar++) {
                doubleVar[intVar][intVar] = BigDecimal[intVar][intVar].doubleValue();
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <514, 516>
for (int j = 0; j < nCols; j++) {
                d[i][j] = BigDecimal[i][j].doubleValue();
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.EmpiricalDistributionImpl <445, 445>
binUpperBounds[i] = binUpperBounds[i-1] + delta;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.EmpiricalDistributionImpl <445, 445>
double[]Var[intVar] = double[]Var[intVar-1] + doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <245, 245>
result[i - 1] = i * coefficients[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <582, 584>
for (int i = j + 1; i < solvedCols; ++i) {
                    work1[permutation[i]] -= jacobian[i][pj] * tmp;
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <582, 584>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                    double[]Var[int[]Var[intVar]] -= double[][]Var[intVar][intVar] * doubleVar;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.AbstractEstimator <162, 162>
residuals[i] = Math.sqrt(wm.getWeight()) * residual;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.AbstractEstimator <162, 162>
double[]Var[intVar] = Math.sqrt(WeightedMeasurement.getWeight()) * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <200, 200>
newCoefficients[i] = -coefficients[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <200, 200>
double[]Var[intVar] = -doubleVar[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <339, 339>
final double doubleVar = double[]Var[intVar] / (6 * doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <339, 339>
final double arg = residuals[i] / (6 * medianResidual);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <182, 182>
newCoefficients[i] = -p.coefficients[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <182, 182>
double[]Var[intVar] = -PolynomialFunction.doubleVar[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <842, 842>
factor = Math.pow(0.5 * sequence[j + l2], l);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <842, 842>
doubleVar = Math.pow(0.5 * int[]Var[intVar + intVar], intVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.MultiDirectional <136, 136>
simplex[i] = new RealPointValuePair(xTransformed, Double.NaN, false);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.NelderMead <173, 173>
simplex[i] = new RealPointValuePair(x, Double.NaN, false);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <343, 343>
interpolatedState[i]       += t4 * c;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <343, 343>
double[]Var[intVar]       += doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <204, 204>
interpolatedDerivatives[j] += order * d;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <204, 204>
double[]Var[intVar] += intVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.SemiVariance <287, 287>
dev = values[i] - cutoff;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.SemiVariance <287, 287>
doubleVar = double[]Var[intVar] - doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Mean <165, 165>
correction += values[i] - xbar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Mean <165, 165>
doubleVar += double[]Var[intVar] - doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Variance <400, 400>
doubleVar = double[]Var[intVar] - doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Variance <502, 502>
doubleVar = double[]Var[intVar] - doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Variance <504, 504>
accum2 += weights[i] * dev;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Variance <504, 504>
doubleVar += double[]Var[intVar] * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.LeastSquaresConverter <176, 176>
sumSquares +=  weights[i] * ri * ri;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.LeastSquaresConverter <176, 176>
doubleVar +=  double[]Var[intVar] * doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <221, 221>
cost += residualsWeights[i] * residual * residual;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <221, 221>
doubleVar += double[]Var[intVar] * doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <242, 242>
criterion += residualsWeights[i] * residual * residual;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <242, 242>
doubleVar += double[]Var[intVar] * doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.GaussNewtonEstimator <187, 187>
bDecrementData[j] = weight * residual * grad[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.GaussNewtonEstimator <187, 187>
double[]Var[intVar] = doubleVar * doubleVar * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <202, 202>
c[j] = tc * w;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <202, 202>
double[]Var[intVar] = doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <203, 203>
d[j] = td * w;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <203, 203>
double[]Var[intVar] = doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <344, 344>
robustnessWeights[i] = w * w;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <344, 344>
double[]Var[intVar] = doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.OpenMapRealVector <662, 662>
setEntry(i + index, v[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.OpenMapRealVector <715, 715>
res.setEntry(i, -v[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.TriDiagonalTransformer <235, 235>
doubleVar   += doubleVar * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.TriDiagonalTransformer <236, 236>
double[]Var[intVar] += doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealVector <90, 90>
setEntry(i + index, v[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SparseFieldVector <486, 486>
setEntry(i + index, v[i]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.genetics.RandomKey <263, 263>
res[index] = (double) i / l;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolator <64, 66>
for (int j = 0; j < yLen; j++) {
                fX[j][i] = fval[i][j];
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SmoothingBicubicSplineInterpolator <73, 75>
for (int j = 0; j < yLen; j++) {
                zX[j][i] = zval[i][j];
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <536, 536>
t = Math.sqrt(c * c + 1.0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <536, 536>
doubleVar = Math.sqrt(doubleVar * doubleVar + 1.0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <542, 542>
t = Math.sqrt(s * s + 1.0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <542, 542>
doubleVar = Math.sqrt(doubleVar * doubleVar + 1.0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <394, 394>
final Complex d = f[i+2].subtract(f[i+3]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.OLSMultipleLinearRegression <112, 116>
if (i == j && i < p) {
                    augIData[i][j] = 1d;
                } else {
                    augIData[i][j] = 0d;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <843, 843>
middleIndex = fk[l2+j].length / 2;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.AbstractEstimator <200, 200>
chiSquare += residual * residual / wm[i].getWeight();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.AbstractEstimator <200, 200>
doubleVar += doubleVar * doubleVar / WeightedMeasurement[]Var[intVar].getWeight();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <150, 150>
data[i-pos] = d[i].doubleValue();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <150, 150>
doubleVar[intVar-intVar] = Double[]Var[intVar].doubleValue();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.ArrayRealVector <150, 150>
data[i-pos] = d[i].doubleValue();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <393, 393>
final Complex c = f[i].subtract(f[i+1]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.ranking.NaturalRanking <357, 357>
ranks[iterator.next()] = f + i++;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <112, 112>
yDotK [i] = new double[y0.length];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <112, 112>
yDotK [i] = new double[y0.length];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <197, 197>
newPols[i] = new double[currentState.length];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <197, 197>
newPols[i] = new double[currentState.length];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <201, 201>
newPols[i] = new double[currentState.length];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <201, 201>
newPols[i] = new double[currentState.length];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <602, 602>
yMidDots[j] = new double[y0.length];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <602, 602>
yMidDots[j] = new double[y0.length];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.summary.SumOfLogs <135, 135>
sumLog += Math.log(values[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.summary.SumOfLogs <135, 135>
doubleVar += Math.log(double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <633, 635>
for (int i = j + 1; i < solvedCols; ++i) {
                jacobian[i][pj] = jacobian[j][permutation[i]];
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.OpenMapRealVector <506, 506>
double delta = Math.abs(getEntry(i) - v[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.OpenMapRealVector <506, 506>
double doubleVar = Math.abs(getEntry(intVar) - double[]Var[intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.OpenMapRealVector <506, 506>
double delta = Math.abs(getEntry(i) - v[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.OpenMapRealVector <556, 556>
double delta = Math.abs(getEntry(i) - v[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.OpenMapRealVector <556, 556>
double doubleVar = Math.abs(getEntry(intVar) - double[]Var[intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.OpenMapRealVector <556, 556>
double delta = Math.abs(getEntry(i) - v[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.ranking.NaturalRanking <223, 223>
out[ranks[0].getPosition()] = pos;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <268, 268>
coefficients[n-1] += t * tc[n-1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <268, 268>
doubleVar[intVar-1] += doubleVar * double[]Var[intVar-1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <248, 248>
final double yp0   = h * y0Dot[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <248, 248>
final double doubleVar   = doubleVar * double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <248, 248>
final double yp0   = h * y0Dot[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <249, 249>
final double yp1   = h * y1Dot[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <249, 249>
final double doubleVar   = doubleVar * double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <249, 249>
final double yp1   = h * y1Dot[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <202, 202>
final double d = nDataI[j] * power;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <202, 202>
final double doubleVar = double[]Var[intVar] * doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <202, 202>
final double d = nDataI[j] * power;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Skewness <167, 167>
final double doubleVar = double[]Var[intVar] - doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.Skewness <167, 167>
final double d = values[i] - m;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Skewness <175, 175>
final double doubleVar = double[]Var[intVar] - doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.Skewness <175, 175>
final double d = values[i] - m;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <532, 532>
double doubleVar = doubleVar * double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <532, 532>
double p = s * e[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <533, 533>
double doubleVar = doubleVar * double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <533, 533>
double h = c * e[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <481, 481>
computeDerivatives(t, yEnd, f[1]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <481, 481>
computeDerivatives(doubleVar, double[]Var, double[][]Var[1]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.sampling.DummyStepInterpolator <146, 146>
currentDerivative[i] = in.readDouble();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.sampling.AbstractStepInterpolator <428, 428>
currentState[i] = in.readDouble();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <737, 737>
out.writeInt(dydp[0].length);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.clustering.EuclideanIntegerPoint <69, 69>
centroid[i] /= points.size();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <246, 246>
optimaValues[i] = optimizer.getFunctionValue();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.linear.SimplexTableau <376, 376>
int colIndex = columnLabels.indexOf("x" + i);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser <213, 213>
currentX = observations[i].getX();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser <213, 213>
doubleVar = WeightedObservedPoint[]Var[intVar].getX();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser <214, 214>
currentY = observations[i].getY();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser <214, 214>
doubleVar = WeightedObservedPoint[]Var[intVar].getY();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser <263, 263>
currentX = observations[i].getX();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser <263, 263>
doubleVar = WeightedObservedPoint[]Var[intVar].getX();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser <264, 264>
currentY = observations[i].getY();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser <264, 264>
doubleVar = WeightedObservedPoint[]Var[intVar].getY();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.fitting.CurveFitter <135, 135>
target[i]  = point.getY();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.fitting.CurveFitter <136, 136>
weights[i] = point.getWeight();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.CorrelatedRandomVectorGenerator <287, 287>
normalized[i] = generator.nextNormalizedDouble();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator <103, 103>
yPolyX[j] = xFitter.fit();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator <125, 125>
xPolyY[i] = yFitter.fit();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.MatrixUtils <823, 823>
data[i] = ois.readDouble();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.MatrixUtils <931, 931>
dataI[j] = ois.readDouble();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealVector <769, 769>
values[i] = getEntry(i);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <614, 614>
eigenvectors[i] = new ArrayRealVector(tmp);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <521, 521>
yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <521, 521>
double[]Var[intVar] = 0.5 * (double[]Var[intVar] + double[]Var[intVar] + doubleVar * double[][]Var[intVar][intVar]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <83, 83>
doubleVar[intVar] = doubleVar[intVar + 1] - doubleVar[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastHadamardTransformer <185, 185>
yCurrent[i] = yPrevious[twoI] + yPrevious[twoI + 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastHadamardTransformer <236, 236>
yCurrent[i] = yPrevious[twoI] + yPrevious[twoI + 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.LaguerreSolver <186, 186>
c[i] = new Complex(coefficients[i], 0.0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.solvers.LaguerreSolver <186, 186>
Complex[intVar] = new Complex(doubleVar[intVar], 0.0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.LaguerreSolver <243, 243>
c[i] = new Complex(coefficients[i], 0.0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.solvers.LaguerreSolver <243, 243>
Complex[intVar] = new Complex(doubleVar[intVar], 0.0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <847, 847>
extrapolate(l2, j, diagonal, yMidDots[l+1]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <204, 204>
data[l1 + i] = v2.getEntry(i);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <204, 204>
doubleVar[intVar + intVar] = RealVector.getEntry(intVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <1063, 1063>
data[i] = v.getEntry(i-index);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <1063, 1063>
doubleVar[intVar] = RealVector.getEntry(intVar-intVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <654, 654>
data[i] = v.getEntry(i-index);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.TriDiagonalTransformer <157, 157>
cachedT.setEntry(i, i + 1, secondary[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <688, 688>
sum += getEntry(row, i) * v[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <688, 688>
doubleVar += getEntry(intVar, intVar) * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <740, 740>
sum += getEntry(i, col) * v[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <740, 740>
doubleVar += getEntry(intVar, intVar) * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <150, 150>
cachedB.setEntry(i, i + 1, secondary[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <521, 521>
double t = Math.sqrt(1 + q * q);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <521, 521>
double doubleVar = Math.sqrt(1 + doubleVar * doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <521, 521>
double t = Math.sqrt(1 + q * q);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <264, 264>
predictedScaled[j] = stepSize * yDot[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <264, 264>
double[]Var[intVar] = doubleVar * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <280, 280>
correctedScaled[j] = stepSize * yDot[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <280, 280>
double[]Var[intVar] = doubleVar * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <220, 220>
ratio         = y0[j] / scale[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <220, 220>
doubleVar         = double[]Var[intVar] / double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <222, 222>
ratio         = yDot0[j] / scale[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <222, 222>
doubleVar         = double[]Var[intVar] / double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <191, 191>
v2[i] = yDot0 - v1[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <191, 191>
double[]Var[intVar] = doubleVar - double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <261, 261>
predictedScaled[j] = stepSize * yDot[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <261, 261>
double[]Var[intVar] = doubleVar * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <438, 438>
scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * yi;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <438, 438>
double[]Var[intVar] = doubleVar + doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <419, 419>
zDot[startIndex + i * n] = s;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <419, 419>
double[]Var[intVar + intVar * intVar] = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <435, 435>
zDot[startIndex + i * k] = s;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <435, 435>
double[]Var[intVar + intVar * intVar] = doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.summary.SumOfSquares <124, 124>
doubleVar += double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.summary.Sum <164, 164>
sum += values[i] * weights[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.summary.Sum <164, 164>
doubleVar += double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Variance <503, 503>
accum += weights[i] * (dev * dev);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Variance <503, 503>
doubleVar += double[]Var[intVar] * (doubleVar * doubleVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.StatUtils <574, 574>
result += sample1[i] - sample2[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.StatUtils <574, 574>
doubleVar += double[]Var[intVar] - double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.StatUtils <618, 618>
doubleVar = double[]Var[intVar] - double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <96, 96>
sumSq += dev * dev / expected[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <96, 96>
doubleVar += doubleVar * doubleVar / double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.fitting.PolynomialFitter <103, 103>
y = y * x + parameters[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.fitting.PolynomialFitter <103, 103>
doubleVar = doubleVar * doubleVar + double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <255, 255>
chiSquare += residual * residual / residualsWeights[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <255, 255>
doubleVar += doubleVar * doubleVar / double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.GaussNewtonOptimizer <90, 90>
double[]Var[intVar] += doubleVar * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <139, 139>
delta += r[i] * searchDirection[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <139, 139>
doubleVar += double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <168, 168>
point[i] += step * searchDirection[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <168, 168>
double[]Var[intVar] += doubleVar * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <182, 182>
delta += r[i] * newSteepestDescent[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <182, 182>
doubleVar += double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <191, 191>
deltaMid += r[i] * steepestDescent[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <191, 191>
doubleVar += double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <275, 275>
shiftedPoint[i] += x * searchDirection[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <275, 275>
double[]Var[intVar] += doubleVar * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <284, 284>
dotProduct += gradient[i] * searchDirection[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <284, 284>
doubleVar += double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <356, 356>
doubleVar += double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <321, 321>
doubleVar += double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <387, 387>
double[]Var[intVar] += double[]Var[intVar] * doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <393, 393>
doubleVar += double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <565, 565>
doubleVar += double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <731, 731>
jacobian[i * cols + pk] = temp2;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <731, 731>
double[]Var[intVar * intVar + intVar] = doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <882, 882>
doubleVar += double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <888, 888>
double[]Var[intVar] -= doubleVar * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <666, 666>
result[i] = index[n - i - 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <133, 133>
result = argument * result + coefficients[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <133, 133>
doubleVar = doubleVar * doubleVar + double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <93, 93>
doubleVar[intVar] = doubleVar[intVar] / doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <410, 410>
result += row[j] * beta[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <410, 410>
doubleVar += double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <334, 334>
result += row[j] * beta[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <334, 334>
doubleVar += double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <315, 315>
res[i] = beta * x + alpha;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <315, 315>
double[]Var[intVar] = doubleVar * doubleVar + doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.LUDecompositionImpl <393, 393>
double[]Var[intVar] -= double[]Var[intVar] * doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.LUDecompositionImpl <409, 409>
double[]Var[intVar] -= double[]Var[intVar] * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.QRDecompositionImpl <326, 326>
y[i] -= yRow * qrtRow[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.QRDecompositionImpl <326, 326>
double[]Var[intVar] -= doubleVar * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.CholeskyDecompositionImpl <227, 227>
double[]Var[intVar] -= doubleVar * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.CholeskyDecompositionImpl <266, 266>
double[]Var[intVar] -= doubleVar * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <444, 444>
sum += dataRow[i] * v[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.Array2DRowRealMatrix <444, 444>
doubleVar += double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <354, 354>
data[i] = data[i] + d;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <354, 354>
doubleVar[intVar] = doubleVar[intVar] + doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <363, 363>
data[i] = data[i] - d;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <363, 363>
doubleVar[intVar] = doubleVar[intVar] - doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <372, 372>
data[i] = data[i] * d;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <372, 372>
doubleVar[intVar] = doubleVar[intVar] * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <381, 381>
data[i] = data[i] / d;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <381, 381>
doubleVar[intVar] = doubleVar[intVar] / doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <718, 718>
dot += data[i] * v[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <718, 718>
doubleVar += doubleVar[intVar] * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <431, 431>
sum += dataRow[i] * v[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <431, 431>
doubleVar += double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.TriDiagonalTransformer <244, 244>
doubleVar += double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.TriDiagonalTransformer <250, 250>
double[]Var[intVar] -= doubleVar * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <276, 276>
doubleVar -= double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <281, 281>
double[]Var[intVar] -= doubleVar * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <301, 301>
beta -= hI[j] * hK[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <301, 301>
doubleVar -= double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <305, 305>
hI[j] -= beta * hK[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <305, 305>
double[]Var[intVar] -= doubleVar * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <340, 340>
doubleVar -= double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <344, 344>
double[]Var[intVar] -= doubleVar * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <365, 365>
beta -= hI[j] * hI[k];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <365, 365>
doubleVar -= double[]Var[intVar] * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <370, 370>
hI[j] -= beta * hI[k];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <370, 370>
double[]Var[intVar] -= doubleVar * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <304, 304>
bp[j] += s * vData[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <304, 304>
double[]Var[intVar] += doubleVar * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <346, 346>
bp[j] += s * vData[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <346, 346>
double[]Var[intVar] += doubleVar * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <400, 400>
f[i+1] = roots.isForward() ? e2 : e1;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <401, 401>
f[i+3] = roots.isForward() ? e1 : e2;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.TriDiagonalTransformer <154, 154>
cachedT.setEntry(i, i - 1, secondary[i - 1]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <146, 146>
cachedB.setEntry(i, i - 1, secondary[i - 1]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.MultistepIntegrator <333, 333>
scaled[j] *= stepSize;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <495, 495>
double[]Var[intVar]       = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <678, 678>
stepSize = t - stepStart;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <678, 678>
doubleVar = doubleVar - doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <146, 146>
scaled[i] *= ratio;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <146, 146>
double[]Var[intVar] *= doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <155, 155>
nDataI[j] *= power;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <155, 155>
double[]Var[intVar] *= doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <203, 203>
stateVariation[j]          += d;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <203, 203>
double[]Var[intVar]          += doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <515, 515>
double[]Var[intVar] = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.clustering.EuclideanIntegerPoint <111, 111>
buff.append(coordinates[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics <335, 335>
buffer.append(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.summary.Sum <125, 125>
doubleVar += double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.summary.Product <125, 125>
product *= values[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.summary.Product <125, 125>
doubleVar *= double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Variance <509, 509>
sumWts += weights[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Variance <509, 509>
doubleVar += double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <80, 80>
sumExpected += expected[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <80, 80>
doubleVar += double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <81, 81>
doubleVar += long[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <245, 245>
countSum1 += observed1[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <246, 246>
countSum2 += observed2[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <275, 275>
currX = optima[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <275, 275>
doubleVar = double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <276, 276>
currY = optimaValues[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <276, 276>
doubleVar = double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <286, 286>
mIX = optima[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <286, 286>
doubleVar = double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <287, 287>
mIY = optimaValues[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <287, 287>
doubleVar = double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <295, 295>
currX = optima[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <295, 295>
doubleVar = double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <296, 296>
currY = optimaValues[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <296, 296>
doubleVar = double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.linear.SimplexSolver <105, 105>
int column = i + tableau.getArtificialVariableOffset();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser <169, 169>
curr = observations[j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser <177, 177>
mI = observations[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser <183, 183>
curr = observations[j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.fitting.PolynomialFitter <93, 93>
gradient[i] = xn;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.fitting.PolynomialFitter <93, 93>
double[]Var[intVar] = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <193, 193>
ji[j] *= factor;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <193, 193>
double[]Var[intVar] *= doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <220, 220>
double[]Var[intVar] = doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <650, 650>
double[]Var[intVar] = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.NelderMead <92, 92>
final double[] x = simplex[i].getPointRef();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.NelderMead <92, 92>
final double[] x = simplex[i].getPointRef();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.NelderMead <99, 99>
centroid[j] *= scaling;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.NelderMead <99, 99>
double[]Var[intVar] *= doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.GaussNewtonEstimator <181, 181>
double weight   = measurements[i].getWeight();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.GaussNewtonEstimator <181, 181>
double doubleVar   = WeightedMeasurement[]Var[intVar].getWeight();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.GaussNewtonEstimator <181, 181>
double weight   = measurements[i].getWeight();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.GaussNewtonEstimator <182, 182>
double residual = measurements[i].getResidual();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.GaussNewtonEstimator <182, 182>
double doubleVar = WeightedMeasurement[]Var[intVar].getResidual();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.GaussNewtonEstimator <182, 182>
double residual = measurements[i].getResidual();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <693, 693>
double[]Var[intVar] = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <743, 743>
natural[i] = i;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.EmpiricalDistributionImpl <300, 300>
sampleStats.addValue(inputArray[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.EmpiricalDistributionImpl <310, 310>
stats.addValue(inputArray[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.UnitSphereRandomVectorGenerator <75, 75>
double[]Var[intVar] *= doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <412, 412>
a[i] = result;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <412, 412>
double[]Var[intVar] = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <336, 336>
a[i] = result;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <336, 336>
double[]Var[intVar] = doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.LUDecompositionImpl <403, 403>
double[]Var[intVar] /= doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <689, 689>
out[row] = sum;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <716, 716>
out[row] = sum;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <741, 741>
out[col] = sum;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <769, 769>
out[col] = sum;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <438, 438>
out[row] = sum;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <461, 461>
out[col] = sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockRealMatrix <677, 677>
double[]Var[intVar] += doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <1389, 1389>
out[p] += sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockRealMatrix <1389, 1389>
double[]Var[intVar] += doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <1438, 1438>
out[q] += sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockRealMatrix <1438, 1438>
double[]Var[intVar] += doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <446, 446>
out[row] = sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.Array2DRowRealMatrix <446, 446>
double[]Var[intVar] = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <469, 469>
out[col] = sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.Array2DRowRealMatrix <469, 469>
double[]Var[intVar] = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1041, 1041>
out[row] = sum;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1082, 1082>
out[col] = sum;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <433, 433>
out[row] = sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <433, 433>
double[]Var[intVar] = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <457, 457>
out[col] = sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <457, 457>
double[]Var[intVar] = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <690, 690>
out[row] = sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <690, 690>
double[]Var[intVar] = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <717, 717>
out[row] = sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <717, 717>
double[]Var[intVar] = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <742, 742>
out[col] = sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <742, 742>
double[]Var[intVar] = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <770, 770>
out[col] = sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <770, 770>
double[]Var[intVar] = doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.SingularValueDecompositionImpl <303, 303>
double[]Var[intVar] *= doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <441, 441>
double[]Var[intVar] = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <554, 554>
u = s * t;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <554, 554>
doubleVar = doubleVar * doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <565, 565>
double[]Var[intVar] -= doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <566, 566>
double[]Var[intVar] = doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <579, 579>
doubleVar = double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.genetics.RandomKey <211, 211>
repr.add((double)i/l);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <1168, 1168>
doubleVar += double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <1830, 1830>
doubleVar = double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <474, 474>
doubleVar[intVar] *= doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <255, 255>
double[][]Var[1][intVar] = doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <256, 256>
double[][]Var[2][intVar] = doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <257, 257>
double[][]Var[3][intVar] = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <466, 466>
lmDir[permutation[j]] = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <503, 503>
lmDir[permutation[j]] = 0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <669, 669>
t = (v - u) / 2;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <758, 758>
t = (v - u) / 2;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <1025, 1025>
out[data.length] = in;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <1025, 1025>
double[]Var[doubleVar.length] = doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <617, 617>
out[data.length] = in;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <487, 487>
maxAbsoluteValue=Math.abs(realEigenvalues[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <487, 487>
doubleVar=Math.abs(double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <490, 490>
maxAbsoluteValue=Math.abs(e[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <490, 490>
doubleVar=Math.abs(double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <597, 597>
maxAbsoluteValue=Math.abs(realEigenvalues[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <597, 597>
doubleVar=Math.abs(double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <614, 614>
vector[subVector.length] = i;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <330, 330>
Complex[intVar] = new Complex(doubleVar[2*intVar], doubleVar[2*intVar+1]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <181, 181>
final double dist = Math.abs(z - x[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <181, 181>
final double doubleVar = Math.abs(doubleVar - doubleVar[intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <181, 181>
final double dist = Math.abs(z - x[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <1709, 1709>
sum += Math.abs(p1[i] - p2[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <1709, 1709>
doubleVar += Math.abs(double[]Var[intVar] - double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <1724, 1724>
sum += Math.abs(p1[i] - p2[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <154, 154>
yTmp[j] = y[j] + stepSize * sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <154, 154>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <167, 167>
yTmp[j] = y[j] + stepSize * sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <167, 167>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <270, 270>
yTmp[j] = y[j] + stepSize * sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <270, 270>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <283, 283>
yTmp[j] = y[j] + stepSize * sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <283, 283>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <425, 425>
yTmp[j] = currentState[j] + h * s;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <425, 425>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Mean <213, 213>
correction += weights[i] * (values[i] - xbarw);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Mean <213, 213>
doubleVar += double[]Var[intVar] * (double[]Var[intVar] - doubleVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.TriDiagonalTransformer <238, 238>
z[i] = beta * (z[i] + zI);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.TriDiagonalTransformer <238, 238>
double[]Var[intVar] = doubleVar * (double[]Var[intVar] + doubleVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <399, 399>
data[i] = Math.exp(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <399, 399>
doubleVar[intVar] = Math.exp(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <408, 408>
data[i] = Math.expm1(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <408, 408>
doubleVar[intVar] = Math.expm1(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <417, 417>
data[i] = Math.log(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <417, 417>
doubleVar[intVar] = Math.log(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <426, 426>
data[i] = Math.log10(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <426, 426>
doubleVar[intVar] = Math.log10(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <435, 435>
data[i] = Math.log1p(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <435, 435>
doubleVar[intVar] = Math.log1p(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <444, 444>
data[i] = Math.cosh(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <444, 444>
doubleVar[intVar] = Math.cosh(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <453, 453>
data[i] = Math.sinh(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <453, 453>
doubleVar[intVar] = Math.sinh(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <462, 462>
data[i] = Math.tanh(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <462, 462>
doubleVar[intVar] = Math.tanh(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <471, 471>
data[i] = Math.cos(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <471, 471>
doubleVar[intVar] = Math.cos(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <480, 480>
data[i] = Math.sin(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <480, 480>
doubleVar[intVar] = Math.sin(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <489, 489>
data[i] = Math.tan(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <489, 489>
doubleVar[intVar] = Math.tan(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <498, 498>
data[i] = Math.acos(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <498, 498>
doubleVar[intVar] = Math.acos(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <507, 507>
data[i] = Math.asin(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <507, 507>
doubleVar[intVar] = Math.asin(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <516, 516>
data[i] = Math.atan(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <516, 516>
doubleVar[intVar] = Math.atan(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <552, 552>
data[i] = Math.cbrt(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <552, 552>
doubleVar[intVar] = Math.cbrt(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <561, 561>
data[i] = Math.ceil(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <561, 561>
doubleVar[intVar] = Math.ceil(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <570, 570>
data[i] = Math.floor(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <570, 570>
doubleVar[intVar] = Math.floor(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <579, 579>
data[i] = Math.rint(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <579, 579>
doubleVar[intVar] = Math.rint(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <588, 588>
data[i] = Math.signum(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <588, 588>
doubleVar[intVar] = Math.signum(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <597, 597>
data[i] = Math.ulp(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <597, 597>
doubleVar[intVar] = Math.ulp(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolator <110, 110>
divdiff[j] = (divdiff[j+1] - divdiff[j]) / denominator;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolator <110, 110>
double[]Var[intVar] = (double[]Var[intVar+1] - double[]Var[intVar]) / doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <201, 201>
final double doubleVar = (double[]Var[intVar+1] - double[]Var[intVar]) / doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <201, 201>
final double w = (c[j+1] - d[j]) / divider;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.HighamHall54Integrator <114, 114>
errSum += STATIC_E[l] * yDotK[l][j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.HighamHall54Integrator <114, 114>
doubleVar += double[]Var[intVar] * double[][]Var[intVar][intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.special.Gamma <104, 104>
doubleVar = doubleVar + (double[]Var[intVar] / (doubleVar + intVar));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <648, 648>
Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <691, 691>
Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <459, 459>
doubleVar[intVar] = UnivariateRealFunction.value(doubleVar + intVar * doubleVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator <168, 168>
yDotK[k][i] = in.readDouble();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer <192, 192>
c1[i] = bigC1[i].doubleValue();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.clustering.EuclideanIntegerPoint <65, 65>
centroid[i] += p.getPoint()[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics <185, 185>
results[i] = stats[i].getResult();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.VectorialMean <68, 68>
result[i] = means[i].getResult();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <168, 168>
derivativePolynomials[i] = polynomials[i].polynomialDerivative();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1480, 1480>
dataI[j] = new BigDecimal(inI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1500, 1500>
dataI[j] = new BigDecimal(inI[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <133, 133>
data[i] = d[i].doubleValue();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <133, 133>
doubleVar[intVar] = Double[]Var[intVar].doubleValue();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.ArrayRealVector <133, 133>
data[i] = d[i].doubleValue();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer <263, 263>
final double[] msI = multistep[i];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer <263, 263>
final double[] msI = multistep[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <476, 476>
double t = t0 + subStep;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <476, 476>
double doubleVar = doubleVar + doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <476, 476>
double t = t0 + subStep;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <153, 153>
final double[] nDataI = nData[i];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <153, 153>
final double[] nDataI = nData[i];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <425, 425>
final double[] dFdYi = dFdY[i];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <426, 426>
final double[] dFdPi = dFdP[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.OneWayAnovaImpl <154, 154>
double val = data[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.inference.OneWayAnovaImpl <154, 154>
double doubleVar = double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.inference.OneWayAnovaImpl <154, 154>
double val = data[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <280, 280>
double mIX = optima[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <280, 280>
double doubleVar = double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <280, 280>
double mIX = optima[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <281, 281>
double mIY = optimaValues[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <281, 281>
double doubleVar = double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <281, 281>
double mIY = optimaValues[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.SimpleVectorialValueChecker <77, 77>
final double doubleVar         = double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.SimpleVectorialValueChecker <77, 77>
final double pi         = p[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.SimpleVectorialValueChecker <78, 78>
final double doubleVar         = double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.SimpleVectorialValueChecker <78, 78>
final double ci         = c[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser <173, 173>
WeightedObservedPoint mI = observations[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.SimpleVectorialPointChecker <77, 77>
final double doubleVar         = double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.SimpleVectorialPointChecker <77, 77>
final double pi         = p[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.SimpleVectorialPointChecker <78, 78>
final double doubleVar         = double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.SimpleVectorialPointChecker <78, 78>
final double ci         = c[i];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.GaussNewtonOptimizer <83, 83>
final double[] grad   = jacobian[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.GaussNewtonOptimizer <84, 84>
final double weight   = residualsWeights[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.GaussNewtonOptimizer <84, 84>
final double doubleVar   = double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.GaussNewtonOptimizer <84, 84>
final double weight   = residualsWeights[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <645, 645>
int pj = permutation[j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <153, 153>
final double[] vertexI = startConfiguration[i];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <153, 153>
final double[] vertexI = startConfiguration[i];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <189, 189>
final double[] refI = referenceSimplex[i];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <197, 197>
final double[] refJ = referenceSimplex[j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <688, 688>
int pj = permutation[j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.integration.RombergIntegrator <95, 95>
final double s = currentRow[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.integration.RombergIntegrator <95, 95>
final double doubleVar = doubleVar[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.integration.RombergIntegrator <95, 95>
final double s = currentRow[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolator <138, 138>
final BicubicSplineInterpolatingFunction f = ySplineZX[j];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatingFunction <166, 166>
final double[] xvalI = xval[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <255, 255>
final double doubleVar = double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <255, 255>
final double x = xval[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <448, 448>
final double doubleVar = double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <448, 448>
final double x = values[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.OpenMapRealMatrix <172, 172>
final int i        = key / columns;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.OpenMapRealMatrix <203, 203>
final int i        = key / columns;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.LUDecompositionImpl <172, 172>
final double[] double[]Var = doubleVar[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.LUDecompositionImpl <172, 172>
final double[] luI = lu[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.LUDecompositionImpl <188, 188>
final double[] double[]Var = doubleVar[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.LUDecompositionImpl <188, 188>
final double[] luI = lu[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <276, 276>
final T[] dataI = data[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.QRDecompositionImpl <415, 415>
final int      jBlock = j / blockSize;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.QRDecompositionImpl <418, 418>
final double[] yJ     = y[j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.QRDecompositionImpl <426, 426>
final double[] qrtJ = qrt[j];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.QRDecompositionImpl <426, 426>
final double[] qrtJ = qrt[j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.MatrixUtils <929, 929>
final double[] dataI = data[i];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.MatrixUtils <929, 929>
final double[] dataI = data[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <476, 476>
final T[] rowI = data[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <492, 492>
final T[] rowI = data[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <510, 510>
final T[] rowI = data[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <528, 528>
final T[] rowI = data[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <578, 578>
final T[] rowI = data[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.CholeskyDecompositionImpl <131, 131>
final double[] ltI = lTData[i];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.CholeskyDecompositionImpl <131, 131>
final double[] ltI = lTData[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.CholeskyDecompositionImpl <312, 312>
final double[] lJ = lTData[j];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.CholeskyDecompositionImpl <312, 312>
final double[] lJ = lTData[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.CholeskyDecompositionImpl <313, 313>
final double doubleVar = double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.CholeskyDecompositionImpl <313, 313>
final double lJJ = lJ[j];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.CholeskyDecompositionImpl <314, 314>
final double[] xJ = x[j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <484, 484>
final double[] rowI = data[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.Array2DRowRealMatrix <484, 484>
final double[] double[]Var = doubleVar[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.Array2DRowRealMatrix <484, 484>
final double[] rowI = data[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <500, 500>
final double[] rowI = data[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.Array2DRowRealMatrix <500, 500>
final double[] double[]Var = doubleVar[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.Array2DRowRealMatrix <500, 500>
final double[] rowI = data[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <518, 518>
final double[] rowI = data[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.Array2DRowRealMatrix <518, 518>
final double[] double[]Var = doubleVar[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.Array2DRowRealMatrix <518, 518>
final double[] rowI = data[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <536, 536>
final double[] rowI = data[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.Array2DRowRealMatrix <536, 536>
final double[] double[]Var = doubleVar[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.Array2DRowRealMatrix <536, 536>
final double[] rowI = data[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <586, 586>
final double[] rowI = data[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.Array2DRowRealMatrix <586, 586>
final double[] double[]Var = doubleVar[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.Array2DRowRealMatrix <586, 586>
final double[] rowI = data[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <472, 472>
final double[] rowI = data[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <472, 472>
final double[] double[]Var = doubleVar[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealMatrixImpl <472, 472>
final double[] rowI = data[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <488, 488>
final double[] rowI = data[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <488, 488>
final double[] double[]Var = doubleVar[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealMatrixImpl <488, 488>
final double[] rowI = data[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <506, 506>
final double[] rowI = data[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <506, 506>
final double[] double[]Var = doubleVar[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealMatrixImpl <506, 506>
final double[] rowI = data[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <524, 524>
final double[] rowI = data[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <524, 524>
final double[] double[]Var = doubleVar[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealMatrixImpl <524, 524>
final double[] rowI = data[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <574, 574>
final double[] rowI = data[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <574, 574>
final double[] double[]Var = doubleVar[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealMatrixImpl <574, 574>
final double[] rowI = data[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <183, 183>
final double[] dataI = data[i];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <183, 183>
final double[] dataI = data[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <329, 329>
final double doubleVar = double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <329, 329>
final double c = hK[j];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.SingularValueDecompositionImpl <301, 301>
final double[] suTi = suT[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <575, 575>
double doubleVar = double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <575, 575>
double p = realEigenvalues[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.UncorrelatedRandomVectorGenerator <88, 88>
random[i] = mean[i] + standardDeviation[i] * generator.nextNormalizedDouble();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.OpenMapRealVector <278, 278>
res.setEntry(i + virtualSize, a[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.OpenMapRealVector <450, 450>
double delta = entries.get(i) - v[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.OpenMapRealVector <450, 450>
double doubleVar = OpenIntToDoubleHashMap.get(intVar) - double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.OpenMapRealVector <450, 450>
double delta = OpenIntToDoubleHashMap.get(i) - v[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <774, 774>
final double delta = data[i] - v.getEntry(i);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <774, 774>
final double doubleVar = doubleVar[intVar] - RealVector.getEntry(intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.ArrayRealVector <774, 774>
final double delta = data[i] - RealVector.getEntry(i);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <822, 822>
final double delta = data[i] - v.getEntry(i);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <822, 822>
final double doubleVar = doubleVar[intVar] - RealVector.getEntry(intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.ArrayRealVector <822, 822>
final double delta = data[i] - RealVector.getEntry(i);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <870, 870>
final double delta = data[i] - v.getEntry(i);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <870, 870>
final double doubleVar = doubleVar[intVar] - RealVector.getEntry(intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.ArrayRealVector <870, 870>
final double delta = data[i] - RealVector.getEntry(i);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SparseFieldVector <202, 202>
res.setEntry(i + virtualSize, a[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <302, 302>
final double s = v.dotProduct(b) / realEigenvalues[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <302, 302>
final double doubleVar = AbstractRealVector.dotProduct(double[]Var) / double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <302, 302>
final double s = null.dotProduct(b) / realEigenvalues[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <344, 344>
final double s = v.dotProduct(b) / realEigenvalues[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <344, 344>
final double doubleVar = AbstractRealVector.dotProduct(RealVector) / double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <344, 344>
final double s = null.dotProduct(RealVector) / realEigenvalues[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <248, 248>
scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <248, 248>
double[]Var[intVar] = doubleVar + doubleVar * Math.abs(double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <375, 377>
throw MathRuntimeException.createIllegalArgumentException(
                      "element {0} is not positive: {1}",
                      i, in[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <391, 393>
throw MathRuntimeException.createIllegalArgumentException(
                      "element {0} is negative: {1}",
                      i, in[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <250, 250>
final double ydiff = y1[i] - currentState[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <250, 250>
final double doubleVar = double[]Var[intVar] - double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <250, 250>
final double ydiff = y1[i] - currentState[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <95, 95>
final double dev = observed[i] - expected[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <95, 95>
final double doubleVar = long[]Var[intVar] - double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <95, 95>
final double dev = observed[i] - expected[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <219, 219>
final double residual = targetValues[i] - objective[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <219, 219>
final double doubleVar = double[]Var[intVar] - double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <219, 219>
final double residual = targetValues[i] - objective[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.GaussNewtonOptimizer <85, 85>
final double residual = objective[i] - targetValues[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.GaussNewtonOptimizer <85, 85>
final double doubleVar = double[]Var[intVar] - double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.GaussNewtonOptimizer <85, 85>
final double residual = objective[i] - targetValues[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <739, 739>
int index = j * cols + permutation[j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <817, 817>
int iDiag = k * cols + permutation[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <788, 788>
final double delta = data[i] - v[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <788, 788>
final double doubleVar = doubleVar[intVar] - double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.ArrayRealVector <788, 788>
final double delta = data[i] - v[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <836, 836>
final double delta = data[i] - v[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <836, 836>
final double doubleVar = doubleVar[intVar] - double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.ArrayRealVector <836, 836>
final double delta = data[i] - v[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <884, 884>
final double delta = data[i] - v[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <884, 884>
final double doubleVar = doubleVar[intVar] - double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.ArrayRealVector <884, 884>
final double delta = data[i] - v[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <1739, 1739>
final double doubleVar = double[]Var[intVar] - double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <1739, 1739>
final double dp = p1[i] - p2[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <1755, 1755>
final double doubleVar = int[]Var[intVar] - int[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <1755, 1755>
final double dp = p1[i] - p2[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <149, 149>
return polynomials[i].value(v - knots[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction <149, 149>
return PolynomialFunction[intVar].value(doubleVar - doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialsUtils <215, 215>
a[i] = coefficients.get(start + i).doubleValue();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialsUtils <215, 215>
a[i] = ArrayList.get(start + i).doubleValue();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm <189, 189>
coefficients[0] = a[i] - c[i] * coefficients[0];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm <189, 189>
doubleVar[0] = doubleVar[intVar] - doubleVar[intVar] * doubleVar[0];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.EmpiricalDistributionImpl <346, 347>
upperBounds[i] = upperBounds[i-1] +
            ((double) binStats.get(i).getN()) / (double) sampleStats.getN();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.EmpiricalDistributionImpl <346, 347>
upperBounds[i] = upperBounds[i-1] +
            ((double) binStats.get(i).getN()) / (double) SummaryStatistics.getN();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <332, 332>
final double yDot1  = yDotK[0][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <332, 332>
final double doubleVar  = double[][]Var[0][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <332, 332>
final double yDot1  = yDotK[0][i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <333, 333>
final double yDot6  = yDotK[5][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <333, 333>
final double doubleVar  = double[][]Var[5][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <333, 333>
final double yDot6  = yDotK[5][i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <334, 334>
final double yDot7  = yDotK[6][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <334, 334>
final double doubleVar  = double[][]Var[6][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <334, 334>
final double yDot7  = yDotK[6][i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <335, 335>
final double yDot8  = yDotK[7][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <335, 335>
final double doubleVar  = double[][]Var[7][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <335, 335>
final double yDot8  = yDotK[7][i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <336, 336>
final double yDot9  = yDotK[8][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <336, 336>
final double doubleVar  = double[][]Var[8][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <336, 336>
final double yDot9  = yDotK[8][i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <337, 337>
final double yDot10 = yDotK[9][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <337, 337>
final double doubleVar = double[][]Var[9][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <337, 337>
final double yDot10 = yDotK[9][i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <338, 338>
final double yDot11 = yDotK[10][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <338, 338>
final double doubleVar = double[][]Var[10][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <338, 338>
final double yDot11 = yDotK[10][i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <339, 339>
final double yDot12 = yDotK[11][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <339, 339>
final double doubleVar = double[][]Var[11][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <339, 339>
final double yDot12 = yDotK[11][i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <340, 340>
final double yDot13 = yDotK[12][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <340, 340>
final double doubleVar = double[][]Var[12][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <340, 340>
final double yDot13 = yDotK[12][i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <341, 341>
final double yDot14 = yDotKLast[0][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <341, 341>
final double doubleVar = double[][]Var[0][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <341, 341>
final double yDot14 = yDotKLast[0][i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <342, 342>
final double yDot15 = yDotKLast[1][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <342, 342>
final double doubleVar = double[][]Var[1][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <342, 342>
final double yDot15 = yDotKLast[1][i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <343, 343>
final double yDot16 = yDotKLast[2][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <343, 343>
final double doubleVar = double[][]Var[2][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <343, 343>
final double yDot16 = yDotKLast[2][i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <184, 184>
final double yDot0 = yDotK[0][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <184, 184>
final double doubleVar = double[][]Var[0][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <184, 184>
final double yDot0 = yDotK[0][i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <185, 185>
final double yDot2 = yDotK[2][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <185, 185>
final double doubleVar = double[][]Var[2][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <185, 185>
final double yDot2 = yDotK[2][i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <186, 186>
final double yDot3 = yDotK[3][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <186, 186>
final double doubleVar = double[][]Var[3][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <186, 186>
final double yDot3 = yDotK[3][i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <997, 997>
outBlock[outIndex++] = block[i * jWidth + jColumn];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <1055, 1055>
block[i * jWidth + jColumn] = mBlock[mIndex++];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <1112, 1112>
outData[outIndex++] = block[i * jWidth + jColumn];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <1227, 1227>
block[i * jWidth + jColumn] = array[outIndex++];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockFieldMatrix <971, 971>
outBlock[outIndex++] = block[i * jWidth + jColumn];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockFieldMatrix <1029, 1029>
block[i * jWidth + jColumn] = mBlock[mIndex++];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockFieldMatrix <1086, 1086>
outData[outIndex++] = block[i * jWidth + jColumn];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockFieldMatrix <1201, 1201>
block[i * jWidth + jColumn] = array[outIndex++];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.LaguerreSolver <280, 280>
root[i] = solve(subarray, initial);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.LUDecompositionImpl <203, 203>
cachedP.setEntry(i, pivot[i], 1.0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.MatrixUtils <336, 336>
m.setEntry(0, i, rowData[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.MatrixUtils <359, 359>
m.setEntry(0, i, rowData[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.MatrixUtils <435, 435>
m.setEntry(i, 0, columnData[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.MatrixUtils <458, 458>
m.setEntry(i, 0, columnData[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <161, 161>
data[i] = v.getEntry(i);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <161, 161>
doubleVar[intVar] = RealVector.getEntry(intVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <218, 218>
data[i] = v1.getEntry(i);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <218, 218>
doubleVar[intVar] = RealVector.getEntry(intVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <145, 145>
data[i] = v.getEntry(i);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <592, 592>
temp[i] = mdcm.get(subVector);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <444, 448>
for (int i = 0; i < dimension; ++i) {
      out.writeDouble(yDotKLast[0][i]);
      out.writeDouble(yDotKLast[1][i]);
      out.writeDouble(yDotKLast[2][i]);
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <496, 498>
if (Math.abs(realEigenvalues[i])<=MathUtils.EPSILON*maxAbsoluteValue) {
                    realEigenvalues[i]=0.0;
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <496, 498>
if (Math.abs(double[]Var[intVar])<=MathUtils.EPSILON*doubleVar) {
                    double[]Var[intVar]=0.0;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <499, 501>
if (Math.abs(e[i])<=MathUtils.EPSILON*maxAbsoluteValue) {
                    e[i]=0.0;
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <499, 501>
if (Math.abs(double[]Var[intVar])<=MathUtils.EPSILON*doubleVar) {
                    double[]Var[intVar]=0.0;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <603, 605>
if (Math.abs(realEigenvalues[i])<MathUtils.EPSILON*maxAbsoluteValue) {
                    realEigenvalues[i]=0.0;
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <603, 605>
if (Math.abs(double[]Var[intVar])<MathUtils.EPSILON*doubleVar) {
                    double[]Var[intVar]=0.0;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.SimpleRealPointChecker <77, 77>
final double difference = Math.abs(p[i] - c[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.SimpleRealPointChecker <77, 77>
final double doubleVar = Math.abs(double[]Var[intVar] - double[]Var[intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.SimpleRealPointChecker <77, 77>
final double difference = Math.abs(p[i] - c[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <439, 439>
final double ratio  = (after[i] - before[i]) / tol;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <439, 439>
final double doubleVar  = (double[]Var[intVar] - double[]Var[intVar]) / doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <439, 439>
final double ratio  = (after[i] - before[i]) / tol;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <92, 92>
final double dev = observed[i] - ratio * expected[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <92, 92>
final double doubleVar = long[]Var[intVar] - doubleVar * double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <92, 92>
final double dev = observed[i] - ratio * expected[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.AbstractEstimator <132, 132>
jacobian[index++] = factor * wm.getPartial(parameters[j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.AbstractEstimator <132, 132>
double[]Var[intVar++] = doubleVar * WeightedMeasurement.getPartial(EstimatedParameter[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <275, 275>
System.arraycopy(z, n * (i + 1), dydy0[i], 0, n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <152, 152>
sum += a[k-1][l] * yDotK[l][j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <152, 152>
doubleVar += double[][]Var[intVar-1][intVar] * double[][]Var[intVar][intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <268, 268>
sum += a[k-1][l] * yDotK[l][j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <268, 268>
doubleVar += double[][]Var[intVar-1][intVar] * double[][]Var[intVar][intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.EulerStepInterpolator <85, 85>
interpolatedState[i] = currentState[i] - oneMinusThetaH * yDotK[0][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.EulerStepInterpolator <85, 85>
double[]Var[intVar] = double[]Var[intVar] - doubleVar * double[][]Var[0][intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <479, 479>
yEnd[i] = y0[i] + subStep * f[0][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <479, 479>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * double[][]Var[0][intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.integration.RombergIntegrator <93, 93>
currentRow[j] = tIJm1 + (tIJm1 - previousRow[j - 1]) / r;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.integration.RombergIntegrator <93, 93>
doubleVar[intVar] = doubleVar + (doubleVar - doubleVar[intVar - 1]) / doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.MersenneTwister <176, 179>
if (i >= N) {
                mt[0] = mt[N - 1];
                i = 1;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.MersenneTwister <191, 194>
if (i >= N) {
                mt[0] = mt[N - 1];
                i = 1;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.CholeskyDecompositionImpl <138, 138>
ltI[i] = Math.sqrt(ltI[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <534, 534>
data[i] = Math.abs(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <534, 534>
doubleVar[intVar] = Math.abs(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <543, 543>
data[i] = Math.sqrt(data[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <543, 543>
doubleVar[intVar] = Math.sqrt(doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <520, 520>
ode.setParameter(j, p[j] +  hP[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SingularValueDecompositionImpl <140, 140>
singularValues[i] = Math.sqrt(Math.abs(singularValues[i]));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <234, 234>
y1[j] = y0[j] + h * yDot0[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <234, 234>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <241, 241>
ratio         = (yDot1[j] - yDot0[j]) / scale[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <241, 241>
doubleVar         = (double[]Var[intVar] - double[]Var[intVar]) / double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer <307, 307>
dataI[j] += c1I * (start[j] - end[j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer <307, 307>
double[]Var[intVar] += doubleVar * (double[]Var[intVar] - double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <443, 443>
scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yi;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <443, 443>
double[]Var[intVar] = double[]Var[intVar] + double[]Var[intVar] * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <204, 204>
searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer <204, 204>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <719, 719>
double[]Var[intVar] = (double[]Var[intVar] - doubleVar) / double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <761, 761>
doubleVar += double[]Var[intVar * intVar + intVar] * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <763, 763>
double[]Var[intVar] = (double[]Var[intVar] - doubleVar) / double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm <166, 166>
doubleVar = doubleVar[intVar] + (doubleVar - doubleVar[intVar]) * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.complex.Complex <799, 800>
return createComplex(Math.abs(imaginary) / (2.0 * t),
                MathUtils.indicator(imaginary) * t);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.complex.Complex <799, 800>
return createComplex(Math.abs(doubleVar) / (2.0 * doubleVar),
                MathUtils.indicator(doubleVar) * doubleVar);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <109, 109>
doubleVar[intVar] = (doubleVar[intVar + 1] - doubleVar[intVar]) / (3d * doubleVar[intVar]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <107, 107>
doubleVar[intVar] = doubleVar[intVar] - doubleVar[intVar] * doubleVar[intVar + 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastHadamardTransformer <191, 191>
yCurrent[i] = yPrevious[twoI - n] - yPrevious[twoI - n + 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastHadamardTransformer <242, 242>
yCurrent[i] = yPrevious[twoI - n] - yPrevious[twoI - n + 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <371, 371>
out.writeDouble(polynoms[k][l]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer <265, 265>
msI[j] -= first[j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <779, 779>
copyArray(src[i], dest[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.VectorialMean <57, 57>
means[i].increment(v[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.LeastSquaresConverter <168, 168>
residuals[i] -= observations[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.GaussNewtonOptimizer <115, 115>
point[i] += dX[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.NelderMead <94, 94>
centroid[j] += x[j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.LaguerreSolver <272, 272>
c[i] = coefficients[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.LUDecompositionImpl <222, 222>
determinant *= lu[i][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.LUDecompositionImpl <222, 222>
doubleVar *= doubleVar[intVar][intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <556, 556>
q = c * t - h;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <556, 556>
doubleVar = doubleVar * doubleVar - doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <381, 381>
f[i] = data[ii];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <692, 692>
lastDimension = ((Object[]) lastDimension)[vector[i]];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <155, 158>
if (steps[j] == 0.0) {
                    throw MathRuntimeException.createIllegalArgumentException(
                          EQUAL_VERTICES_MESSAGE, j, j + 1);
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <773, 776>
for (int j = k; j < jacobian.length; ++j) {
                    double aki = jacobian[j][permutation[i]];
                    norm2 += aki * aki;
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <773, 776>
for (int intVar = intVar; intVar < double[][]Var.length; ++intVar) {
                    double aki = double[][]Var[intVar][int[]Var[intVar]];
                    doubleVar += aki * aki;
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <773, 776>
for (int j = k; j < jacobian.length; ++j) {
                    double aki = jacobian[j][permutation[i]];
                    norm2 += aki * aki;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <192, 192>
v3[i] = v1[i] - v2[i] - yDot6;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <192, 192>
double[]Var[intVar] = double[]Var[intVar] - double[]Var[intVar] - doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <93, 93>
sumSq += dev * dev / (ratio * expected[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <93, 93>
doubleVar += doubleVar * doubleVar / (doubleVar * double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.linear.LinearConstraint <129, 129>
sub[i] = lhsCoefficients[i] - rhsCoefficients[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <286, 286>
doubleVar += double[][]Var[intVar][intVar] * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <351, 351>
double[]Var[intVar] += double[][]Var[intVar][intVar] * doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <523, 523>
doubleVar += double[][]Var[intVar][intVar] * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <833, 833>
doubleVar += double[][]Var[intVar][intVar] * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <837, 837>
double[]Var[intVar] -= doubleVar * double[][]Var[intVar][intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <510, 510>
lmDir[permutation[i]] -= ypk * jacobian[index];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <510, 510>
double[]Var[int[]Var[intVar]] -= doubleVar * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <548, 548>
sum += jacobian[index] * work1[permutation[i]];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <548, 548>
doubleVar += double[]Var[intVar] * double[]Var[int[]Var[intVar]];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.LUDecompositionImpl <112, 112>
doubleVar -= double[]Var[intVar] * doubleVar[intVar][intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.LUDecompositionImpl <124, 124>
doubleVar -= double[]Var[intVar] * doubleVar[intVar][intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.LUDecompositionImpl <286, 286>
double[]Var[intVar] -= doubleVar * doubleVar[intVar][intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.LUDecompositionImpl <295, 295>
double[]Var[intVar] -= doubleVar * doubleVar[intVar][intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.LUDecompositionImpl <330, 330>
double[]Var[intVar] -= doubleVar * doubleVar[intVar][intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.LUDecompositionImpl <339, 339>
double[]Var[intVar] -= doubleVar * doubleVar[intVar][intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <467, 467>
sum += data[i][col] * v[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.Array2DRowRealMatrix <467, 467>
doubleVar += doubleVar[intVar][intVar] * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <455, 455>
sum += data[i][col] * v[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <455, 455>
doubleVar += doubleVar[intVar][intVar] * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <396, 396>
bp[j][k] += s * vData[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <396, 396>
double[][]Var[intVar][intVar] += doubleVar * double[]Var[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <1807, 1808>
throw MathRuntimeException.createIllegalArgumentException("points {0} and {1} are not strictly increasing ({2} >= {3})",
                                                                                  i - 1, i, previous, val[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <1807, 1808>
throw MathRuntimeException.createIllegalArgumentException("points {0} and {1} are not strictly increasing ({2} >= {3})",
                                                                                  intVar - 1, intVar, doubleVar, double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <1812, 1813>
throw MathRuntimeException.createIllegalArgumentException("points {0} and {1} are not increasing ({2} > {3})",
                                                                                  i - 1, i, previous, val[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <1812, 1813>
throw MathRuntimeException.createIllegalArgumentException("points {0} and {1} are not increasing ({2} > {3})",
                                                                                  intVar - 1, intVar, doubleVar, double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <1819, 1820>
throw MathRuntimeException.createIllegalArgumentException("points {0} and {1} are not strictly decreasing ({2} <= {3})",
                                                                                  i - 1, i, previous, val[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <1819, 1820>
throw MathRuntimeException.createIllegalArgumentException("points {0} and {1} are not strictly decreasing ({2} <= {3})",
                                                                                  intVar - 1, intVar, doubleVar, double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <1824, 1825>
throw MathRuntimeException.createIllegalArgumentException("points {0} and {1} are not decreasing ({2} < {3})",
                                                                                  i - 1, i, previous, val[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <1824, 1825>
throw MathRuntimeException.createIllegalArgumentException("points {0} and {1} are not decreasing ({2} < {3})",
                                                                                  intVar - 1, intVar, doubleVar, double[]Var[intVar]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <520, 520>
double doubleVar = (double[]Var[intVar + 1] - double[]Var[intVar]) / (2 * double[]Var[intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <520, 520>
double q = (realEigenvalues[j + 1] - realEigenvalues[j]) / (2 * e[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <226, 226>
sum += weights[j] * f.value(midPoint + halfStep * abscissas[j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <226, 226>
doubleVar += double[]Var[intVar] * UnivariateRealFunction.value(doubleVar + doubleVar * double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.AbstractMultipleLinearRegression <154, 154>
result[i] = Math.sqrt(sigma * betaVariance[i][i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.AbstractMultipleLinearRegression <154, 154>
double[]Var[intVar] = Math.sqrt(doubleVar * double[][]Var[intVar][intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <318, 318>
errors[i] = Math.sqrt(covar[i][i]) * c;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer <318, 318>
double[]Var[intVar] = Math.sqrt(double[][]Var[intVar][intVar]) * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.AbstractEstimator <267, 267>
errors[i] = Math.sqrt(covar[i][i]) * c;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.AbstractEstimator <267, 267>
double[]Var[intVar] = Math.sqrt(double[][]Var[intVar][intVar]) * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <152, 152>
newCoefficients[i] = coefficients[i] + p.coefficients[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <152, 152>
double[]Var[intVar] = doubleVar[intVar] + PolynomialFunction.doubleVar[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <178, 178>
newCoefficients[i] = coefficients[i] - p.coefficients[i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <178, 178>
double[]Var[intVar] = doubleVar[intVar] - PolynomialFunction.doubleVar[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <316, 316>
residuals[i] = Math.abs(yval[i] - res[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <304, 304>
sum += dataRow[i] * m.data[i][col];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.Array2DRowRealMatrix <304, 304>
doubleVar += double[]Var[intVar] * Array2DRowRealMatrixVar.doubleVar[intVar][intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <285, 285>
sum += dataRow[i] * m.data[i][col];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <285, 285>
doubleVar += double[]Var[intVar] * AbstractRealMatrix.doubleVar[intVar][intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.ranking.NaturalRanking <194, 194>
ranks[i] = new IntDoublePair(data[i], i);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.FieldLUDecompositionImpl <210, 210>
determinant = determinant.multiply(lu[i][i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <952, 952>
det = det.multiply(lu[i][i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1015, 1015>
trace = trace.add(data[i][i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockFieldMatrix <1367, 1367>
out[p] = out[p].add(sum);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockFieldMatrix <1418, 1418>
out[q] = out[q].add(sum);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <323, 323>
data[i] = data[i].add(d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <340, 340>
data[i] = data[i].subtract(d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <357, 357>
data[i] = data[i].multiply(d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <374, 374>
data[i] = data[i].divide(d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <393, 393>
data[i] = one.divide(data[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.summary.Product <165, 165>
product *= Math.pow(values[i], weights[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.summary.Product <165, 165>
doubleVar *= Math.pow(double[]Var[intVar], double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayRealVector <390, 390>
data[i] = Math.pow(data[i], d);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayRealVector <390, 390>
doubleVar[intVar] = Math.pow(doubleVar[intVar], doubleVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <400, 400>
simplex[i] = new RealPointValuePair(point, evaluate(point), false);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <525, 525>
ode.setParameter(j, p[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <572, 572>
setEntry(row, i, array[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <604, 604>
setEntry(i, column, array[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <547, 547>
setEntry(row, i, array[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <579, 579>
setEntry(i, column, array[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <621, 623>
System.arraycopy(data[i], startColumn,
                             subMatrixData[i - startRow], 0,
                             endColumn - startColumn + 1);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <713, 713>
final double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <713, 713>
final double doubleVar = Math.abs(double[]Var[intVar] - double[][]Var[0][intVar]) / double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <713, 713>
final double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <347, 347>
v[1][i] = yDot1 - v[0][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <347, 347>
double[][]Var[1][intVar] = doubleVar - double[][]Var[0][intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <211, 212>
interpolatedDerivatives[j] =
                (interpolatedDerivatives[j] + scaled[j] * normalizedAbscissa) / x;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.sampling.NordsieckStepInterpolator <211, 212>
double[]Var[intVar] =
                (double[]Var[intVar] + double[]Var[intVar] * doubleVar) / doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <626, 626>
work1[permutation[i]] -= jacobian[i * cols + pj] * tmp;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <626, 626>
double[]Var[int[]Var[intVar]] -= double[]Var[intVar * intVar + intVar] * doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <730, 730>
double[]Var[intVar] = -doubleVar * doubleVar + doubleVar * double[]Var[intVar];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <559, 559>
double[][]Var[intVar][intVar + 1] = doubleVar * double[][]Var[intVar][intVar] + doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.LaguerreSolver <284, 288>
for (int j = n-i-1; j >= 0; j--) {
                oldc = c[j];
                c[j] = newc;
                newc = oldc.add(newc.multiply(root[i]));
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <265, 265>
polynoms[4][i] = 16 * (yMidDots[0][i] - ph0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <265, 265>
double[][]Var[4][intVar] = 16 * (double[][]Var[0][intVar] - doubleVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <269, 269>
polynoms[5][i] = 16 * (yMidDots[1][i] - ph1);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <269, 269>
double[][]Var[5][intVar] = 16 * (double[][]Var[1][intVar] - doubleVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <279, 284>
for (int j = 4; j <= mu; ++j) {
              final double fac1 = 0.5 * j * (j - 1);
              final double fac2 = 2 * fac1 * (j - 2) * (j - 3);
              polynoms[j+4][i] =
                  16 * (yMidDots[j][i] + fac1 * polynoms[j+2][i] - fac2 * polynoms[j][i]);
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <279, 284>
for (int j = 4; j <= mu; ++j) {
              final double fac1 = 0.5 * j * (j - 1);
              final double fac2 = 2 * fac1 * (j - 2) * (j - 3);
              polynoms[j+4][i] =
                  16 * (yMidDots[j][i] + fac1 * polynoms[j+2][i] - fac2 * polynoms[j][i]);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <254, 254>
polynoms[0][i] = currentState[i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.clustering.EuclideanIntegerPoint <96, 98>
for (Integer i : point) {
            hashCode += i.hashCode() * 13 + 7;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <681, 681>
maxColSum = Math.max(maxColSum, colSums[j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockRealMatrix <681, 681>
doubleVar = Math.max(doubleVar, double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1109, 1109>
out[row] = solution[row][0];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <797, 797>
System.arraycopy(data[row], 0, out, 0, ncols);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <324, 324>
final double doubleVar = (doubleVar - double[]Var[intVar]) / (double[]Var[intVar + 1] - double[]Var[intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <324, 324>
final double xN = (x - xval[i]) / (xval[i + 1] - xval[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <325, 325>
final double doubleVar = (doubleVar - double[]Var[intVar]) / (double[]Var[intVar + 1] - double[]Var[intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <325, 325>
final double yN = (y - yval[j]) / (yval[j + 1] - yval[j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <169, 169>
final double doubleVar = (doubleVar - double[]Var[intVar]) / (double[]Var[intVar + 1] - double[]Var[intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <169, 169>
final double xN = (x - xval[i]) / (xval[i + 1] - xval[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <170, 170>
final double doubleVar = (doubleVar - double[]Var[intVar]) / (double[]Var[intVar + 1] - double[]Var[intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <170, 170>
final double yN = (y - yval[j]) / (yval[j + 1] - yval[j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <242, 242>
final double doubleVar = (doubleVar - double[]Var[intVar]) / (double[]Var[intVar + 1] - double[]Var[intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <242, 242>
final double xN = (x - xval[i]) / (xval[i + 1] - xval[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <243, 243>
final double doubleVar = (doubleVar - double[]Var[intVar]) / (double[]Var[intVar + 1] - double[]Var[intVar]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <243, 243>
final double yN = (y - yval[j]) / (yval[j + 1] - yval[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.univariate.BrentOptimizer <102, 102>
double tol = eps * Math.abs(x) + t;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.univariate.BrentOptimizer <102, 102>
double doubleVar = doubleVar * Math.abs(doubleVar) + doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.univariate.BrentOptimizer <102, 102>
double tol = eps * Math.abs(x) + t;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <258, 259>
throw MathRuntimeException.createArithmeticException("identical abscissas x[{0}] == x[{1}] == {2} cause division by zero",
                                                                             i, k, x[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <258, 259>
throw MathRuntimeException.createArithmeticException("identical abscissas x[{0}] == x[{1}] == {2} cause division by zero",
                                                                             intVar, intVar, doubleVar[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <172, 173>
System.arraycopy(interpolator.polynoms[i], 0,
                         polynoms[i], 0, dimension);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <489, 489>
f[i] = new Complex(d * f[i].getReal(), d * f[i].getImaginary());

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <489, 489>
Complex[intVar] = new Complex(doubleVar * Complex[intVar].getReal(), doubleVar * Complex[intVar].getImaginary());

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <220, 230>
for (int j = 1; j <= k; j++) {
                // We know that (result * i) is divisible by j,
                // but (result * i) may overflow, so we split j:
                // Filter out the gcd, d, so j/d and i/d are integer.
                // result is divisible by (j/d) because (j/d)
                // is relative prime to (i/d) and is a divisor of
                // result * (i/d).
                final long d = gcd(i, j);
                result = (result / (j / d)) * (i / d);
                i++;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.integration.TrapezoidIntegrator <119, 120>
final double rLimit =
                    relativeAccuracy * (Math.abs(oldt) + Math.abs(t)) * 0.5;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.integration.TrapezoidIntegrator <119, 120>
final double doubleVar =
                    doubleVar * (Math.abs(doubleVar) + Math.abs(doubleVar)) * 0.5;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.integration.TrapezoidIntegrator <119, 120>
final double rLimit =
                    relativeAccuracy * (Math.abs(oldt) + Math.abs(t)) * 0.5;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <1771, 1771>
max = Math.max(max, Math.abs(p1[i] - p2[i]));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <1771, 1771>
doubleVar = Math.max(doubleVar, Math.abs(double[]Var[intVar] - double[]Var[intVar]));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <1786, 1786>
max = Math.max(max, Math.abs(p1[i] - p2[i]));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <855, 859>
for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {
              for (int i = 0; i < y0.length; ++i) {
                fk[j][m][i] -= fk[j][m-2][i];
              }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.TransformerMap <183, 185>
for (NumberTransformer t : map.values()) {
            hash = hash * 31 + t.hashCode();
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <337, 337>
double c = polynoms[currentDegree][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <337, 337>
double doubleVar = double[][]Var[intVar][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <337, 337>
double c = polynoms[currentDegree][i];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.QRDecompositionImpl <420, 420>
int index = (j - jStart) * kWidth;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <353, 353>
System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowRealMatrix <361, 361>
System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.Array2DRowRealMatrix <361, 361>
System.arraycopy(double[][]Var[intVar], 0, doubleVar[intVar + intVar], intVar, intVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <742, 742>
System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <343, 343>
System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <343, 343>
System.arraycopy(double[][]Var[intVar], 0, doubleVar[intVar + intVar], intVar, intVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.TriDiagonalTransformer <117, 117>
cachedQt.setEntry(k, i, beta * hK[i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.TriDiagonalTransformer <117, 117>
RealMatrix.setEntry(intVar, intVar, doubleVar * double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.TriDiagonalTransformer <125, 125>
cachedQt.setEntry(j, k, beta * hK[k]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.TriDiagonalTransformer <125, 125>
RealMatrix.setEntry(intVar, intVar, doubleVar * double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.ranking.NaturalRanking <290, 291>
ranks[i] = new IntDoublePair(
                        value, ranks[i].getPosition());

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.ranking.NaturalRanking <290, 291>
IntDoublePair[]Var[intVar] = new IntDoublePair(
                        doubleVar, IntDoublePair[]Var[intVar].getPosition());

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <839, 839>
yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <839, 839>
double[][]Var[intVar+1][intVar] = doubleVar * double[][][]Var[intVar][intVar + intVar][intVar];

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.correlation.PearsonsCorrelation <228, 228>
regression.addData(xArray[i], yArray[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <309, 312>
if (i == -1) {
            throw MathRuntimeException.createIllegalArgumentException("{0} out of [{1}, {2}] range",
                                                                      x, xval[0], xval[xval.length - 1]);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <309, 312>
if (intVar == -1) {
            throw MathRuntimeException.createIllegalArgumentException("{0} out of [{1}, {2}] range",
                                                                      doubleVar, double[]Var[0], double[]Var[double[]Var.length - 1]);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <314, 317>
if (j == -1) {
            throw MathRuntimeException.createIllegalArgumentException("{0} out of [{1}, {2}] range",
                                                                      y, yval[0], yval[yval.length - 1]);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolatingFunction <314, 317>
if (intVar == -1) {
            throw MathRuntimeException.createIllegalArgumentException("{0} out of [{1}, {2}] range",
                                                                      doubleVar, double[]Var[0], double[]Var[double[]Var.length - 1]);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <159, 162>
if (i == -1) {
            throw MathRuntimeException.createIllegalArgumentException("{0} out of [{1}, {2}] range",
                                                                      x, xval[0], xval[xval.length - 1]);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <159, 162>
if (intVar == -1) {
            throw MathRuntimeException.createIllegalArgumentException("{0} out of [{1}, {2}] range",
                                                                      doubleVar, double[]Var[0], double[]Var[double[]Var.length - 1]);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <164, 167>
if (j == -1) {
            throw MathRuntimeException.createIllegalArgumentException("{0} out of [{1}, {2}] range",
                                                                      y, yval[0], yval[yval.length - 1]);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <164, 167>
if (intVar == -1) {
            throw MathRuntimeException.createIllegalArgumentException("{0} out of [{1}, {2}] range",
                                                                      doubleVar, double[]Var[0], double[]Var[double[]Var.length - 1]);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <232, 235>
if (i == -1) {
            throw MathRuntimeException.createIllegalArgumentException("{0} out of [{1}, {2}] range",
                                                                      x, xval[0], xval[xval.length - 1]);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <232, 235>
if (intVar == -1) {
            throw MathRuntimeException.createIllegalArgumentException("{0} out of [{1}, {2}] range",
                                                                      doubleVar, double[]Var[0], double[]Var[double[]Var.length - 1]);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <237, 240>
if (j == -1) {
            throw MathRuntimeException.createIllegalArgumentException("{0} out of [{1}, {2}] range",
                                                                      y, yval[0], yval[yval.length - 1]);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <237, 240>
if (intVar == -1) {
            throw MathRuntimeException.createIllegalArgumentException("{0} out of [{1}, {2}] range",
                                                                      doubleVar, double[]Var[0], double[]Var[double[]Var.length - 1]);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <252, 252>
scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <509, 509>
final double ratio = (f[j+1][l] - f[0][l]) / scale[l];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <509, 509>
final double doubleVar = (double[][]Var[intVar+1][intVar] - double[][]Var[0][intVar]) / double[]Var[intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <509, 509>
final double ratio = (f[j+1][l] - f[0][l]) / scale[l];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.MultiDirectional <134, 134>
xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.MultiDirectional <134, 134>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * (double[]Var[intVar] - double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.NelderMead <105, 105>
xR[j] = centroid[j] + rho * (centroid[j] - xWorst[j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.NelderMead <105, 105>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * (double[]Var[intVar] - double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.NelderMead <120, 120>
xE[j] = centroid[j] + khi * (xR[j] - centroid[j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.NelderMead <120, 120>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * (double[]Var[intVar] - double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.NelderMead <139, 139>
xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.NelderMead <139, 139>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * (double[]Var[intVar] - double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.NelderMead <154, 154>
xC[j] = centroid[j] - gamma * (centroid[j] - xWorst[j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.NelderMead <154, 154>
double[]Var[intVar] = double[]Var[intVar] - doubleVar * (double[]Var[intVar] - double[]Var[intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.NelderMead <171, 171>
x[j] = xSmallest[j] + sigma * (x[j] - xSmallest[j]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.direct.NelderMead <171, 171>
double[]Var[intVar] = double[]Var[intVar] + doubleVar * (double[]Var[intVar] - double[]Var[intVar]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <560, 560>
double[][]Var[intVar][intVar] = doubleVar * double[][]Var[intVar][intVar] - doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <540, 544>
for (int i = 0; i < last.length; ++i) {
        // Aitken-Neville's recursive formula
        diag[k-j-1][i] = diag[k-j][i] +
                         coeff[k+offset][j-1] * (diag[k-j][i] - diag[k-j-1][i]);
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolator <75, 75>
ySplineX[j] = spInterpolator.interpolate(xval, fX[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolator <82, 82>
xSplineY[i] = spInterpolator.interpolate(yval, fval[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SmoothingBicubicSplineInterpolator <84, 84>
ySplineX[j] = spInterpolator.interpolate(xval, zX[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SmoothingBicubicSplineInterpolator <101, 101>
xSplineY[i] = spInterpolator.interpolate(yval, zY_1[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.OpenMapRealVector <713, 713>
res.setEntry(i, entries.get(i) - v[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <662, 662>
System.arraycopy(extendedState, start, dydy0[i], 0, n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <675, 675>
System.arraycopy(extendedState, start, dydp[i], 0, k);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <694, 694>
System.arraycopy(extendedDerivatives, start, dydy0Dot[i], 0, n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <707, 707>
System.arraycopy(extendedDerivatives, start, dydpDot[i], 0, k);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics <250, 250>
stdDev[i] = Math.sqrt(matrix.getEntry(i, i));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <243, 243>
System.arraycopy(dY0dP[i], 0, z, n * (n + 1) + i * k, k);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians <280, 280>
System.arraycopy(z, n * (n + 1) + i * k, dydp[i], 0, k);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastCosineTransformer <256, 256>
transformed[2 * i + 1] = transformed[2 * i - 1] - y[i].getImaginary();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastCosineTransformer <256, 256>
doubleVar[2 * intVar + 1] = doubleVar[2 * intVar - 1] - Complex[intVar].getImaginary();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastSineTransformer <247, 247>
transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastSineTransformer <247, 247>
doubleVar[2 * intVar + 1] = Complex[intVar].getReal() + doubleVar[2 * intVar - 1];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <264, 264>
final double ph0 = 0.5 * (currentState[i] + y1[i]) + 0.125 * (aspl + bspl);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <264, 264>
final double doubleVar = 0.5 * (double[]Var[intVar] + double[]Var[intVar]) + 0.125 * (doubleVar + doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <264, 264>
final double ph0 = 0.5 * (currentState[i] + y1[i]) + 0.125 * (aspl + bspl);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <1163, 1166>
if (Double.isInfinite(values[i])) {
                 throw MathRuntimeException.createArithmeticException(
                         "Array contains an infinite element, {0} at index {1}", values[i], i);
             }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.integration.RombergIntegrator <88, 88>
currentRow[0] = qtrap.stage(f, min, max, i);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.integration.RombergIntegrator <88, 88>
doubleVar[0] = UnivariateRealIntegratorImpl.stage(UnivariateRealFunction, doubleVar, doubleVar, intVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <344, 344>
interpolatedDerivatives[i] += (t4 * cDot + t4Dot * c) / h;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <344, 344>
double[]Var[intVar] += (doubleVar * doubleVar + doubleVar * doubleVar) / doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <472, 472>
lmDir[permutation[i]] -= ypk * jacobian[i][pk];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <472, 472>
double[]Var[int[]Var[intVar]] -= doubleVar * double[][]Var[intVar][intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <436, 436>
sum = sum.add(dataRow[i].multiply(v[i]));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <507, 507>
dot = dot.add(data[i].multiply(v[i]));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.GaussNewtonEstimator <212, 212>
parameters[i].setEstimate(parameters[i].getEstimate() + dX.getEntry(i));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.CorrelatedRandomVectorGenerator <256, 256>
double doubleVar = double[][]Var[intVar][intVar] - doubleVar * double[][]Var[intVar][intVar];

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.CorrelatedRandomVectorGenerator <256, 256>
double f = c[ii][ij] - e * b[j][rank];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.TDistributionImpl <131, 135>
double t =
                Beta.regularizedBeta(
                    degreesOfFreedom / (degreesOfFreedom + (x * x)),
                    0.5 * degreesOfFreedom,
                    0.5);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.TDistributionImpl <131, 135>
double doubleVar =
                Beta.regularizedBeta(
                    doubleVar / (doubleVar + (doubleVar * doubleVar)),
                    0.5 * doubleVar,
                    0.5);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.distribution.TDistributionImpl <131, 135>
double t =
                Beta.regularizedBeta(
                    degreesOfFreedom / (degreesOfFreedom + (x * x)),
                    0.5 * degreesOfFreedom,
                    0.5);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <243, 243>
final double ratio  = nordsieck.getEntry(lastRow, i) / tol;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <243, 243>
final double doubleVar  = Array2DRowRealMatrixVar.getEntry(intVar, intVar) / doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <243, 243>
final double ratio  = nordsieck.getEntry(lastRow, i) / tol;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.MatrixUtils <204, 204>
m.setEntry(i, i, diagonal[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.MatrixUtils <223, 223>
m.setEntry(i, i, diagonal[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <715, 715>
sum += getEntry(row, i) * v.getEntry(i);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <715, 715>
doubleVar += getEntry(intVar, intVar) * RealVector.getEntry(intVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <768, 768>
sum += getEntry(i, col) * v.getEntry(i);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <768, 768>
doubleVar += getEntry(intVar, intVar) * RealVector.getEntry(intVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <299, 299>
diag[j] = Math.max(diag[j], jacNorm[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <334, 334>
diag[j] = Math.max(diag[j], jacNorm[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <809, 809>
gamma += jacobian[j][pk] * jacobian[j][permutation[k + dk]];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <809, 809>
doubleVar += double[][]Var[intVar][intVar] * double[][]Var[intVar][int[]Var[intVar + intVar]];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <813, 813>
jacobian[j][permutation[k + dk]] -= gamma * jacobian[j][pk];

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <813, 813>
double[][]Var[intVar][int[]Var[intVar + intVar]] -= doubleVar * double[][]Var[intVar][intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <296, 296>
sum = sum.add(dataRow[i].multiply(m.data[i][col]));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <471, 471>
sum = sum.add(dataRow[i].multiply(m.data[i][col]));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <206, 211>
if (nearest < 0.5*(n-i+1)) {
                value += c[nearest];    // fork down
            } else {
                nearest--;
                value += d[nearest];    // fork up
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm <206, 211>
if (intVar < 0.5*(intVar-intVar+1)) {
                doubleVar += double[]Var[intVar];    // fork down
            } else {
                intVar--;
                doubleVar += double[]Var[intVar];    // fork up
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <73, 77>
if (x[i]  >= x[i + 1]) {
                throw MathRuntimeException.createIllegalArgumentException(
                      "points {0} and {1} are not strictly increasing ({2} >= {3})",
                      i, i+1, x[i], x[i+1]);
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <73, 77>
if (doubleVar[intVar]  >= doubleVar[intVar + 1]) {
                throw MathRuntimeException.createIllegalArgumentException(
                      "points {0} and {1} are not strictly increasing ({2} >= {3})",
                      intVar, intVar+1, doubleVar[intVar], doubleVar[intVar+1]);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.Array2DRowFieldMatrix <459, 459>
sum = sum.add(data[i][col].multiply(v[i]));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.FieldLUDecompositionImpl <103, 103>
sum = sum.subtract(luRow[i].multiply(lu[i][col]));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.FieldLUDecompositionImpl <114, 114>
sum = sum.subtract(luRow[i].multiply(lu[i][col]));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.FieldLUDecompositionImpl <395, 395>
bpI[j] = bpI[j].subtract(bpCol[j].multiply(luICol));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.FieldLUDecompositionImpl <411, 411>
bpI[j] = bpI[j].subtract(bpCol[j].multiply(luICol));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1039, 1039>
sum = sum.add(data[row][i].multiply(v[i]));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1080, 1080>
sum = sum.add(data[i][col].multiply(v[i]));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1245, 1245>
sum = sum.subtract(luRow[i].multiply(lu[i][col]));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1257, 1257>
sum = sum.subtract(luRow[i].multiply(lu[i][col]));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <305, 305>
System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockRealMatrix <305, 305>
System.arraycopy(doubleVar[intVar], 0, AbstractRealMatrix.doubleVar[intVar], 0, blocks[i].length);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockFieldMatrix <315, 315>
System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.AbstractIntegrator <212, 216>
if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {
            throw new IntegratorException(
                    "too small integration interval: length = {0}",
                    Math.abs(t - t0));
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.AbstractIntegrator <212, 216>
if (Math.abs(doubleVar - doubleVar) <= 1.0e-12 * Math.max(Math.abs(doubleVar), Math.abs(doubleVar))) {
            throw new IntegratorException(
                    "too small integration interval: length = {0}",
                    Math.abs(doubleVar - doubleVar));
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <585, 589>
for (int j = 0; j < n; j++) {
                    p = z[j][i];
                    z[j][i] = z[j][k];
                    z[j][k] = p;
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <585, 589>
for (int intVar = 0; intVar < intVar; intVar++) {
                    doubleVar = double[][]Var[intVar][intVar];
                    double[][]Var[intVar][intVar] = double[][]Var[intVar][intVar];
                    double[][]Var[intVar][intVar] = doubleVar;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.MultiDirectional <100, 100>
converged &= checker.converged(iter, original[i], simplex[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <302, 302>
converged &= checker.converged(iterations, previous[i], simplex[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolator <86, 86>
xSplineYZ[i] = bsi.interpolate(yval, zval, fval[i]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolator <93, 93>
ySplineZX[j] = bsi.interpolate(zval, xval, fvalZX[j]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.ranking.NaturalRanking <266, 269>
for (int k = i + 1; k < ranks.length; k++) {
                    ranks[k] = new IntDoublePair(
                            ranks[k].getValue(), ranks[k].getPosition() - 1);
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <273, 273>
polynoms[6][i] = 16 * (yMidDots[2][i] - ph2 + polynoms[4][i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <273, 273>
double[][]Var[6][intVar] = 16 * (double[][]Var[2][intVar] - doubleVar + double[][]Var[4][intVar]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <719, 721>
for (int i = 0; i < dimensionSize.length - 1; i++) {
                lastDimension = (Object[]) lastDimension[vector[i]];
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <161, 161>
sum += getEntry(row, i) * m.getEntry(i, col);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <161, 161>
doubleVar += getEntry(intVar, intVar) * RealMatrix.getEntry(intVar, intVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.HighamHall54Integrator <118, 120>
final double tol = (vecAbsoluteTolerance == null) ?
                         (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                         (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.HighamHall54Integrator <118, 120>
final double doubleVar = (double[]Var == null) ?
                         (doubleVar + doubleVar * doubleVar) :
                         (double[]Var[intVar] + double[]Var[intVar] * doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.HighamHall54Integrator <118, 120>
final double tol = (vecAbsoluteTolerance == null) ?
                         (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                         (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <240, 242>
final double tol = (vecAbsoluteTolerance == null) ?
                                       (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                                       (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <240, 242>
final double doubleVar = (double[]Var == null) ?
                                       (doubleVar + doubleVar * doubleVar) :
                                       (double[]Var[intVar] + double[]Var[intVar] * doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <240, 242>
final double tol = (vecAbsoluteTolerance == null) ?
                                       (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                                       (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <333, 333>
interpolatedDerivatives[i] = dot1 * p1 + dot2 * p2 + dot3 * p3;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <333, 333>
double[]Var[intVar] = doubleVar * doubleVar + doubleVar * doubleVar + doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolator <108, 114>
for (int j = 0; j < yLen; j++) {
                final int nJ = nextIndex(j, yLen);
                final int pJ = previousIndex(j);
                d2FdXdY[i][j] = (fval[nI][nJ] - fval[nI][pJ] -
                                 fval[pI][nJ] + fval[pI][pJ]) /
                    ((xval[nI] - xval[pI]) * (yval[nJ] - yval[pJ]));
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SmoothingBicubicSplineInterpolator <137, 143>
for (int j = 0; j < yLen; j++) {
                final int nJ = nextIndex(j, yLen);
                final int pJ = previousIndex(j);
                dZdXdY[i][j] = (zY_2[nI][nJ] - zY_2[nI][pJ] -
                                zY_2[pI][nJ] + zY_2[pI][pJ]) /
                    ((xval[nI] - xval[pI]) * (yval[nJ] - yval[pJ]));
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <771, 775>
if (vector[i] < dimensionSize[i]) {
                        break;
                    } else {
                        vector[i] = 0;
                    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.CholeskyDecompositionImpl <318, 324>
for (int i = j + 1; i < m; i++) {
                    final double[] xI = x[i];
                    final double lJI = lJ[i];
                    for (int k = 0; k < nColB; ++k) {
                        xI[k] -= xJ[k] * lJI;
                    }
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.CholeskyDecompositionImpl <318, 324>
for (int i = j + 1; i < m; i++) {
                    final double[] xI = x[i];
                    final double lJI = lJ[i];
                    for (int k = 0; k < nColB; ++k) {
                        xI[k] -= xJ[k] * lJI;
                    }
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <241, 241>
final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <241, 241>
final double doubleVar = (intVar == 0) ? doubleVar : doubleVar + RandomGenerator.nextDouble() * (doubleVar - doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <241, 241>
final double bound1 = (i == 0) ? min : min + RandomGenerator.nextDouble() * (max - min);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <242, 242>
final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <242, 242>
final double doubleVar = (intVar == 0) ? doubleVar : doubleVar + RandomGenerator.nextDouble() * (doubleVar - doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <242, 242>
final double bound2 = (i == 0) ? max : min + RandomGenerator.nextDouble() * (max - min);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <696, 696>
lmDiag[j] = jacobian[j][permutation[j]];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <697, 697>
jacobian[j][permutation[j]] = lmDir[j];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.MatrixUtils <378, 380>
for (int i = 0; i < nCols; ++i) {
            data[0][i] = new BigDecimal(rowData[i]);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.MatrixUtils <416, 418>
for (int i = 0; i < nCols; ++i) {
            data[0][i] = new BigDecimal(rowData[i]);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.QRDecompositionImpl <427, 433>
for (int i = 0; i < j; ++i) {
                        final double rIJ  = qrtJ[i];
                        final double[] yI = y[i];
                        for (int k = 0; k < kWidth; ++k) {
                            yI[k] -= yJ[k] * rIJ;
                        }
                    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.QRDecompositionImpl <427, 433>
for (int i = 0; i < j; ++i) {
                        final double rIJ  = qrtJ[i];
                        final double[] yI = y[i];
                        for (int k = 0; k < kWidth; ++k) {
                            yI[k] -= yJ[k] * rIJ;
                        }
                    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <277, 277>
polynoms[7][i] = 16 * (yMidDots[3][i] - ph3 + 3 * polynoms[5][i]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <277, 277>
double[][]Var[7][intVar] = 16 * (double[][]Var[3][intVar] - doubleVar + 3 * double[][]Var[5][intVar]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <108, 108>
doubleVar[intVar] = (doubleVar[intVar + 1] - doubleVar[intVar]) / doubleVar[intVar] - doubleVar[intVar] * (doubleVar[intVar + 1] + 2d * doubleVar[intVar]) / 3d;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <548, 551>
for (int i = 0; i < last.length; ++i) {
      // Aitken-Neville's recursive formula
      last[i] = diag[0][i] + coeff[k+offset][k-1] * (diag[0][i] - last[i]);
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <269, 273>
if (xval[i] - xval[ileft] > xval[iright] - xval[i]) {
                    edge = ileft;
                } else {
                    edge = iright;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.CholeskyDecompositionImpl <115, 125>
for (int j = i + 1; j < order; ++j) {
                final double[] lJ = lTData[j];
                final double lIJ = lI[j];
                final double lJI = lJ[i];
                final double maxDelta =
                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
                if (Math.abs(lIJ - lJI) > maxDelta) {
                    throw new NotSymmetricMatrixException();
                }
                lJ[i] = 0;
           }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.CholeskyDecompositionImpl <115, 125>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                final double[] lJ = double[][]Var[intVar];
                final double lIJ = double[]Var[intVar];
                final double lJI = lJ[intVar];
                final double maxDelta =
                    doubleVar * Math.max(Math.abs(lIJ), Math.abs(lJI));
                if (Math.abs(lIJ - lJI) > maxDelta) {
                    throw new NotSymmetricMatrixException();
                }
                lJ[intVar] = 0;
           }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.CholeskyDecompositionImpl <115, 125>
for (int j = i + 1; j < order; ++j) {
                final double[] lJ = lTData[j];
                final double lIJ = lI[j];
                final double lJI = lJ[i];
                final double maxDelta =
                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
                if (Math.abs(lIJ - lJI) > maxDelta) {
                    throw new NotSymmetricMatrixException();
                }
                lJ[i] = 0;
           }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <190, 190>
v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <190, 190>
double[]Var[intVar] = doubleVar * doubleVar + doubleVar * doubleVar + doubleVar * doubleVar + doubleVar * doubleVar + doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <343, 345>
for (int i = n - k + 1; i <= n; i++) {
            logSum += Math.log(i);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <343, 345>
for (int intVar = intVar - intVar + 1; intVar <= intVar; intVar++) {
            doubleVar += Math.log(intVar);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.ranking.NaturalRanking <226, 240>
for (int i = 1; i < ranks.length; i++) {
            if (Double.compare(ranks[i].getValue(), ranks[i - 1].getValue()) > 0) {
                // tie sequence has ended (or had length 1)
                pos = i + 1;
                if (tiesTrace.size() > 1) {  // if seq is nontrivial, resolve
                    resolveTie(out, tiesTrace);
                }
                tiesTrace = new ArrayList<Integer>();
                tiesTrace.add(ranks[i].getPosition());
            } else {
                // tie sequence continues
                tiesTrace.add(ranks[i].getPosition());
            }
            out[ranks[i].getPosition()] = pos;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.UnitSphereRandomVectorGenerator <66, 70>
for (int i = 0; i < dimension; i++) {
                final double comp = 2 * rand.nextDouble() - 1;
                v[i] = comp;
                normSq += comp * comp;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.UnitSphereRandomVectorGenerator <66, 70>
for (int intVar = 0; intVar < intVar; intVar++) {
                final double comp = 2 * RandomGenerator.nextDouble() - 1;
                double[]Var[intVar] = comp;
                doubleVar += comp * comp;
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.UnitSphereRandomVectorGenerator <66, 70>
for (int i = 0; i < dimension; i++) {
                final double comp = 2 * RandomGenerator.nextDouble() - 1;
                v[i] = comp;
                normSq += comp * comp;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <193, 195>
for (int i = 0; i < data.length; i++) {
            addData(data[i][0], data[i][1]);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <476, 479>
for (int i = 0; i < n - 1; i++) {
            realEigenvalues[i] = main[i];
            e[i] = secondary[i];
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.FieldLUDecompositionImpl <284, 286>
for (int i = col + 1; i < m; i++) {
                    bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.FieldLUDecompositionImpl <330, 332>
for (int i = col + 1; i < m; i++) {
                        bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));
                    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <504, 513>
for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double sum = 0;
                for (int i = 0; i < j; ++i) {
                    sum += jacobian[i][pj] * work1[permutation[i]];
                }
                double s = (work1[pj] - sum) / diagR[pj];
                work1[pj] = s;
                sum2 += s * s;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <504, 513>
for (int intVar = 0; intVar < intVar; ++intVar) {
                int pj = int[]Var[intVar];
                double sum = 0;
                for (int i = 0; i < intVar; ++i) {
                    sum += double[][]Var[i][pj] * double[]Var[int[]Var[i]];
                }
                double s = (double[]Var[pj] - sum) / double[]Var[pj];
                double[]Var[pj] = s;
                doubleVar += s * s;
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <504, 513>
for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double sum = 0;
                for (int i = 0; i < j; ++i) {
                    sum += jacobian[i][pj] * work1[permutation[i]];
                }
                double s = (work1[pj] - sum) / diagR[pj];
                work1[pj] = s;
                sum2 += s * s;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer <263, 268>
if (Double.isNaN(optima[i])) {
                optima[i] = optima[--lastNaN];
                optima[lastNaN + 1] = Double.NaN;
                optimaValues[i] = optimaValues[--lastNaN];
                optimaValues[lastNaN + 1] = Double.NaN;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <466, 472>
if (i >= 1 && xval[i - 1] >= xval[i]) {
                throw new MathException(
                        "the abscissae array must be sorted in a strictly " +
                        "increasing order, but the {0}-th element is {1} " +
                        "whereas {2}-th is {3}",
                        i - 1, xval[i - 1], i, xval[i]);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateRealOptimizer <187, 188>
optima[i] = optimizer.optimize(f, goalType,
                                               (i == 0) ? startPoint : generator.nextVector());

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartMultivariateRealOptimizer <176, 177>
optima[i] = optimizer.optimize(f, goalType,
                                               (i == 0) ? startPoint : generator.nextVector());

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <462, 464>
for (int j = 0; j < rank; ++j) {
            lmDir[permutation[j]] = qy[j];
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <499, 501>
for (int j = 0; j < rank; ++j) {
      lmDir[permutation[j]] = qy[j];
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <702, 704>
for (int i = 0; i < k; i++) {
            result[i] = objects[index[i]];
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <283, 285>
for (int i = 1; i <= k; i++) {
             result *= (double)(n - k + i) / (double)i;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <283, 285>
for (int intVar = 1; intVar <= intVar; intVar++) {
             doubleVar *= (double)(intVar - intVar + intVar) / (double)intVar;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <283, 285>
for (int i = 1; i <= k; i++) {
             result *= (double)(n - k + i) / (double)i;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <353, 356>
for (int i = k + 1; i < m; ++i) {
                    final double c = householderVectors[i][k];
                    xNormSqr += c * c;
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <353, 356>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                    final double c = doubleVar[intVar][intVar];
                    doubleVar += c * c;
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <353, 356>
for (int i = k + 1; i < m; ++i) {
                    final double c = householderVectors[i][k];
                    xNormSqr += c * c;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <872, 878>
for (int i = 1; i < absN; i++) {
          omegaReal[i] =
            omegaReal[i-1] * cosT + omegaImaginaryForward[i-1] * sinT;
          omegaImaginaryForward[i] =
             omegaImaginaryForward[i-1] * cosT - omegaReal[i-1] * sinT;
          omegaImaginaryInverse[i] = -omegaImaginaryForward[i];
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <872, 878>
for (int intVar = 1; intVar < intVar; intVar++) {
          double[]Var[intVar] =
            double[]Var[intVar-1] * doubleVar + double[]Var[intVar-1] * doubleVar;
          double[]Var[intVar] =
             double[]Var[intVar-1] * doubleVar - double[]Var[intVar-1] * doubleVar;
          double[]Var[intVar] = -double[]Var[intVar];
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <724, 726>
for (int j = 0; j < lmDir.length; ++j) {
            lmDir[permutation[j]] = work[j];
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <768, 770>
for (int j = 0; j < lmDir.length; ++j) {
      lmDir[permutation[j]] = work[j];
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <657, 659>
for (int j = 0; j < selectedColumns.length; j++) {
                    subI[j] = dataSelectedI[selectedColumns[j]];
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SingularValueDecompositionImpl <91, 97>
for (int j = i; j < n; j++) {
                matATA[i][j] = 0.0;
                for (int k = 0; k < m; k++) {
                    matATA[i][j] += localcopy[k][i] * localcopy[k][j];
                }
                matATA[j][i]=matATA[i][j];
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SingularValueDecompositionImpl <105, 111>
for (int j = i; j < m; j++) {
                matAAT[i][j] = 0.0;
                for (int k = 0; k < n; k++) {
                    matAAT[i][j] += localcopy[i][k] * localcopy[j][k];
                }
                matAAT[j][i]=matAAT[i][j];
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <574, 577>
for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                work1[pj] = work3[pj] * diag[pj] / dxNorm;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <574, 577>
for (int intVar = 0; intVar < intVar; ++intVar) {
                int pj = int[]Var[intVar];
                double[]Var[pj] = double[]Var[pj] * double[]Var[pj] / doubleVar;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <617, 620>
for (int j = 0; j < solvedCols; ++j) {
       int pj = permutation[j];
        work1[pj] = work3[pj] * diag[pj] / dxNorm;
      }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <617, 620>
for (int intVar = 0; intVar < intVar; ++intVar) {
       int pj = int[]Var[intVar];
        double[]Var[pj] = double[]Var[pj] * double[]Var[pj] / doubleVar;
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <509, 514>
for (m = j; m < n - 1; m++) {
                    double delta = Math.abs(realEigenvalues[m]) + Math.abs(realEigenvalues[m + 1]);
                    if (Math.abs(e[m]) + delta == delta) {
                        break;
                    }
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <509, 514>
for (m = j; m < n - 1; m++) {
                    double delta = Math.abs(realEigenvalues[m]) + Math.abs(realEigenvalues[m + 1]);
                    if (Math.abs(e[m]) + delta == delta) {
                        break;
                    }
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <300, 303>
for (int i = 0; i < currentState.length; ++i) {
        final double e = polynoms[currentDegree][i] / scale[i];
        error += e * e;
      }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <300, 303>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
        final double e = double[][]Var[intVar][intVar] / double[]Var[intVar];
        doubleVar += e * e;
      }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <300, 303>
for (int i = 0; i < currentState.length; ++i) {
        final double e = polynoms[currentDegree][i] / scale[i];
        error += e * e;
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <358, 362>
if (in[i].length != in[0].length) {
                throw MathRuntimeException.createIllegalArgumentException(
                      "some rows have length {0} while others have length {1}",
                      in[i].length, in[0].length);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealVectorFormat <321, 323>
for (int i = 0; i < data.length; ++i) {
            data[i] = components.get(i).doubleValue();
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorFormat <321, 323>
for (int i = 0; i < data.length; ++i) {
            data[i] = components.get(i).doubleValue();
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <404, 408>
if (nextRight < xval.length && xval[nextRight] - xval[i] < xval[i] - xval[left]) {
            int nextLeft = nextNonzero(weights, bandwidthInterval[0]);
            bandwidthInterval[0] = nextLeft;
            bandwidthInterval[1] = nextRight;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <874, 876>
System.arraycopy(subMatrix[i - row], jStart - column,
                                     block, (i - firstRow) * jWidth + (jStart - firstColumn),
                                     jLength);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockFieldMatrix <848, 850>
System.arraycopy(subMatrix[i - row], jStart - column,
                                     block, (i - firstRow) * jWidth + (jStart - firstColumn),
                                     jLength);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <467, 471>
for (int i = 0; i < dimension; ++i) {
      yDotKLast[0][i] = in.readDouble();
      yDotKLast[1][i] = in.readDouble();
      yDotKLast[2][i] = in.readDouble();
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <499, 502>
for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                work1[pj] *= diag[pj] / dxNorm;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <499, 502>
for (int intVar = 0; intVar < intVar; ++intVar) {
                int pj = int[]Var[intVar];
                double[]Var[pj] *= double[]Var[pj] / doubleVar;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <549, 552>
for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                work1[pj] = sPar * diag[pj];
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <549, 552>
for (int intVar = 0; intVar < intVar; ++intVar) {
                int pj = int[]Var[intVar];
                double[]Var[pj] = doubleVar * double[]Var[pj];
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <538, 541>
for (int j = 0; j < solvedCols; ++j) {
        int pj = permutation[j];
        work1[pj] *= diag[pj] / dxNorm;
      }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <538, 541>
for (int intVar = 0; intVar < intVar; ++intVar) {
        int pj = int[]Var[intVar];
        double[]Var[pj] *= double[]Var[pj] / doubleVar;
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <592, 595>
for (int j = 0; j < solvedCols; ++j) {
        int pj = permutation[j];
        work1[pj] = sPar * diag[pj];
      }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <592, 595>
for (int intVar = 0; intVar < intVar; ++intVar) {
        int pj = int[]Var[intVar];
        double[]Var[pj] = doubleVar * double[]Var[pj];
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <587, 590>
for (int j = 0; j < solvedCols; ++j) {
                double s = work1[permutation[j]];
                sum2 += s * s;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <587, 590>
for (int intVar = 0; intVar < intVar; ++intVar) {
                double s = double[]Var[int[]Var[intVar]];
                doubleVar += s * s;
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <587, 590>
for (int j = 0; j < solvedCols; ++j) {
                double s = work1[permutation[j]];
                sum2 += s * s;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <630, 633>
for (int j = 0; j < solvedCols; ++j) {
        double s = work1[permutation[j]];
        sum2 += s * s;
      }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <630, 633>
for (int intVar = 0; intVar < intVar; ++intVar) {
        double s = double[]Var[int[]Var[intVar]];
        doubleVar += s * s;
      }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <630, 633>
for (int j = 0; j < solvedCols; ++j) {
        double s = work1[permutation[j]];
        sum2 += s * s;
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.TriDiagonalTransformer <212, 215>
for (int j = k + 1; j < m; ++j) {
                final double c = hK[j];
                xNormSqr += c * c;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.TriDiagonalTransformer <212, 215>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                final double c = double[]Var[intVar];
                doubleVar += c * c;
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.TriDiagonalTransformer <212, 215>
for (int j = k + 1; j < m; ++j) {
                final double c = hK[j];
                xNormSqr += c * c;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <289, 292>
for (int j = k + 1; j < n; ++j) {
                    final double c = hK[j];
                    xNormSqr += c * c;
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <289, 292>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                    final double c = double[]Var[intVar];
                    doubleVar += c * c;
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <289, 292>
for (int j = k + 1; j < n; ++j) {
                    final double c = hK[j];
                    xNormSqr += c * c;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <332, 332>
interpolatedState[i] = p0 + theta * (p1 + oneMinusTheta * (p2 * theta + p3 * oneMinusTheta));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <332, 332>
double[]Var[intVar] = doubleVar + doubleVar * (doubleVar + doubleVar * (doubleVar * doubleVar + doubleVar * doubleVar));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.FieldLUDecompositionImpl <293, 295>
for (int i = 0; i < col; i++) {
                    bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.FieldLUDecompositionImpl <339, 341>
for (int i = 0; i < col; i++) {
                        bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));
                    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <264, 273>
for (int i = 0; i < lastI; i++) {
            for (int j = 0; j < lastJ; j++) {
                final BicubicSplineFunction f = splines[i][j];
                partialDerivatives[0][i][j] = f.partialDerivativeX();
                partialDerivatives[1][i][j] = f.partialDerivativeY();
                partialDerivatives[2][i][j] = f.partialDerivativeXX();
                partialDerivatives[3][i][j] = f.partialDerivativeYY();
                partialDerivatives[4][i][j] = f.partialDerivativeXY();
            }
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <341, 344>
for (int j = 0; j < solvedCols; ++j) {
          int pj = permutation[j];
          oldX[pj] = parameters[pj].getEstimate();
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiStartDifferentiableMultivariateVectorialOptimizer <191, 192>
optima[i] = optimizer.optimize(f, target, weights,
                                               (i == 0) ? startPoint : generator.nextVector());

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <758, 761>
for (int i = 0; i < jacobian.length; ++i) {
                double akk = jacobian[i][k];
                norm2 += akk * akk;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <758, 761>
for (int intVar = 0; intVar < double[][]Var.length; ++intVar) {
                double akk = double[][]Var[intVar][intVar];
                doubleVar += akk * akk;
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <758, 761>
for (int i = 0; i < jacobian.length; ++i) {
                double akk = jacobian[i][k];
                norm2 += akk * akk;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.CholeskyDecompositionImpl <176, 179>
for (int i = 0; i < lTData.length; ++i) {
            double lTii = lTData[i][i];
            determinant *= lTii * lTii;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.CholeskyDecompositionImpl <176, 179>
for (int intVar = 0; intVar < double[][]Var.length; ++intVar) {
            double lTii = double[][]Var[intVar][intVar];
            doubleVar *= lTii * lTii;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.CholeskyDecompositionImpl <176, 179>
for (int i = 0; i < lTData.length; ++i) {
            double lTii = lTData[i][i];
            determinant *= lTii * lTii;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.MidpointStepInterpolator <91, 96>
for (int i = 0; i < interpolatedState.length; ++i) {
      final double yDot1 = yDotK[0][i];
      final double yDot2 = yDotK[1][i];
      interpolatedState[i] = currentState[i] + coeff1 * yDot1 - coeff2 * yDot2;
      interpolatedDerivatives[i] = coeffDot1 * yDot1 + coeffDot2 * yDot2;
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.MidpointStepInterpolator <91, 96>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
      final double yDot1 = double[][]Var[0][intVar];
      final double yDot2 = double[][]Var[1][intVar];
      double[]Var[intVar] = double[]Var[intVar] + doubleVar * yDot1 - doubleVar * yDot2;
      double[]Var[intVar] = doubleVar * yDot1 + doubleVar * yDot2;
    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.MidpointStepInterpolator <91, 96>
for (int i = 0; i < interpolatedState.length; ++i) {
      final double yDot1 = yDotK[0][i];
      final double yDot2 = yDotK[1][i];
      interpolatedState[i] = currentState[i] + coeff1 * yDot1 - coeff2 * yDot2;
      interpolatedDerivatives[i] = coeffDot1 * yDot1 + coeffDot2 * yDot2;
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.direct.DirectSearchOptimizer <417, 421>
if (comparator.compare(simplex[i], pointValuePair) > 0) {
                RealPointValuePair tmp = simplex[i];
                simplex[i]         = pointValuePair;
                pointValuePair     = tmp;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1175, 1177>
for (int j = 0; j < nColB; j++) {
                    bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1191, 1193>
for (int j = 0; j < nColB; j++) {
                    bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));
                }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.correlation.Covariance <227, 231>
for (int i = 0; i < length; i++) {
                double xDev = xArray[i] - xMean;
                double yDev = yArray[i] - yMean;
                result += (xDev * yDev - result) / (i + 1);
            }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.correlation.Covariance <227, 231>
for (int intVar = 0; intVar < intVar; intVar++) {
                double xDev = double[]Var[intVar] - doubleVar;
                double yDev = double[]Var[intVar] - doubleVar;
                doubleVar += (xDev * yDev - doubleVar) / (intVar + 1);
            }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.correlation.Covariance <227, 231>
for (int i = 0; i < length; i++) {
                double xDev = xArray[i] - xMean;
                double yDev = yArray[i] - yMean;
                result += (xDev * yDev - result) / (i + 1);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastSineTransformer <233, 238>
for (int i = 1; i < (n >> 1); i++) {
            final double a = Math.sin(i * Math.PI / n) * (f[i] + f[n-i]);
            final double b = 0.5 * (f[i] - f[n-i]);
            x[i]     = a + b;
            x[n - i] = a - b;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastSineTransformer <233, 238>
for (int intVar = 1; intVar < (intVar >> 1); intVar++) {
            final double a = Math.sin(intVar * Math.PI / intVar) * (doubleVar[intVar] + doubleVar[intVar-intVar]);
            final double b = 0.5 * (doubleVar[intVar] - doubleVar[intVar-intVar]);
            double[]Var[intVar]     = a + b;
            double[]Var[intVar - intVar] = a - b;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastSineTransformer <233, 238>
for (int i = 1; i < (n >> 1); i++) {
            final double a = Math.sin(i * Math.PI / n) * (f[i] + f[n-i]);
            final double b = 0.5 * (f[i] - f[n-i]);
            x[i]     = a + b;
            x[n - i] = a - b;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.CorrelatedRandomVectorGenerator <230, 236>
for (int i = rank; i < order; ++i) {
                    if (c[index[i]][index[i]] < -small) {
                        // there is at least one sufficiently negative diagonal element,
                        // the covariance matrix is wrong
                        throw new NotPositiveDefiniteMatrixException();
                    }
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.CorrelatedRandomVectorGenerator <230, 236>
for (int intVar = intVar; intVar < intVar; ++intVar) {
                    if (double[][]Var[int[]Var[intVar]][int[]Var[intVar]] < -doubleVar) {
                        // there is at least one sufficiently negative diagonal element,
                        // the covariance matrix is wrong
                        throw new NotPositiveDefiniteMatrixException();
                    }
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <401, 406>
for (int j = 0; j < currentState.length; ++j) {
      s = K14_01 * yDotK[0][j]  + K14_06 * yDotK[5][j]  + K14_07 * yDotK[6][j] +
          K14_08 * yDotK[7][j]  + K14_09 * yDotK[8][j]  + K14_10 * yDotK[9][j] +
          K14_11 * yDotK[10][j] + K14_12 * yDotK[11][j] + K14_13 * yDotK[12][j];
      yTmp[j] = currentState[j] + h * s;
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <401, 406>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
      doubleVar = doubleVar * double[][]Var[0][intVar]  + doubleVar * double[][]Var[5][intVar]  + doubleVar * double[][]Var[6][intVar] +
          doubleVar * double[][]Var[7][intVar]  + doubleVar * double[][]Var[8][intVar]  + doubleVar * double[][]Var[9][intVar] +
          doubleVar * double[][]Var[10][intVar] + doubleVar * double[][]Var[11][intVar] + doubleVar * double[][]Var[12][intVar];
      double[]Var[intVar] = double[]Var[intVar] + doubleVar * doubleVar;
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <600, 603>
for (int i = 0; i < dimensionSize[d]; i++) {
                subVector[d] = i;
                mdcm.set(temp[i], subVector);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <306, 309>
for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    oldX[pj] = point[pj];
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <394, 397>
for (int j = 0; j < solvedCols; ++j) {
                        int pj = permutation[j];
                        point[pj] = oldX[pj];
                    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <431, 434>
for (int j = 0; j < solvedCols; ++j) {
            int pj = permutation[j];
            parameters[pj].setEstimate(oldX[pj]);
          }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolator <98, 106>
for (int i = 0; i < interpolatedState.length; ++i) {
            final double yDot1  = yDotK[0][i];
            final double yDot23 = yDotK[1][i] + yDotK[2][i];
            final double yDot4  = yDotK[3][i];
            interpolatedState[i] =
                currentState[i] + coeff1  * yDot1 + coeff23 * yDot23 + coeff4  * yDot4;
            interpolatedDerivatives[i] =
                coeffDot1 * yDot1 + coeffDot23 * yDot23 + coeffDot4 * yDot4;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolator <98, 106>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
            final double yDot1  = double[][]Var[0][intVar];
            final double yDot23 = double[][]Var[1][intVar] + double[][]Var[2][intVar];
            final double yDot4  = double[][]Var[3][intVar];
            double[]Var[intVar] =
                double[]Var[intVar] + doubleVar  * yDot1 + doubleVar * yDot23 + doubleVar  * yDot4;
            double[]Var[intVar] =
                doubleVar * yDot1 + doubleVar * yDot23 + doubleVar * yDot4;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolator <98, 106>
for (int i = 0; i < interpolatedState.length; ++i) {
            final double yDot1  = yDotK[0][i];
            final double yDot23 = yDotK[1][i] + yDotK[2][i];
            final double yDot4  = yDotK[3][i];
            interpolatedState[i] =
                currentState[i] + coeff1  * yDot1 + coeff23 * yDot23 + coeff4  * yDot4;
            interpolatedDerivatives[i] =
                coeffDot1 * yDot1 + coeffDot23 * yDot23 + coeffDot4 * yDot4;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <684, 689>
for (int i = k + 1; i < solvedCols; ++i) {
                        double rik = jacobian[i][pk];
                        final double temp2 = cos * rik + sin * lmDiag[i];
                        lmDiag[i] = -sin * rik + cos * lmDiag[i];
                        jacobian[i][pk] = temp2;
                    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <684, 689>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                        double rik = double[][]Var[intVar][intVar];
                        final double temp2 = doubleVar * rik + doubleVar * double[]Var[intVar];
                        double[]Var[intVar] = -doubleVar * rik + doubleVar * double[]Var[intVar];
                        double[][]Var[intVar][intVar] = temp2;
                    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <684, 689>
for (int i = k + 1; i < solvedCols; ++i) {
                        double rik = jacobian[i][pk];
                        final double temp2 = cos * rik + sin * lmDiag[i];
                        lmDiag[i] = -sin * rik + cos * lmDiag[i];
                        jacobian[i][pk] = temp2;
                    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <410, 416>
for (int j = 0; j < currentState.length; ++j) {
     s = K15_01 * yDotK[0][j]  + K15_06 * yDotK[5][j]  + K15_07 * yDotK[6][j] +
         K15_08 * yDotK[7][j]  + K15_09 * yDotK[8][j]  + K15_10 * yDotK[9][j] +
         K15_11 * yDotK[10][j] + K15_12 * yDotK[11][j] + K15_13 * yDotK[12][j] +
         K15_14 * yDotKLast[0][j];
     yTmp[j] = currentState[j] + h * s;
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <410, 416>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
     doubleVar = doubleVar * double[][]Var[0][intVar]  + doubleVar * double[][]Var[5][intVar]  + doubleVar * double[][]Var[6][intVar] +
         doubleVar * double[][]Var[7][intVar]  + doubleVar * double[][]Var[8][intVar]  + doubleVar * double[][]Var[9][intVar] +
         doubleVar * double[][]Var[10][intVar] + doubleVar * double[][]Var[11][intVar] + doubleVar * double[][]Var[12][intVar] +
         doubleVar * double[][]Var[0][intVar];
     double[]Var[intVar] = double[]Var[intVar] + doubleVar * doubleVar;
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <344, 346>
v[0][i] = B_01 * yDot1  + B_06 * yDot6 + B_07 * yDot7 +
                    B_08 * yDot8  + B_09 * yDot9 + B_10 * yDot10 +
                    B_11 * yDot11 + B_12 * yDot12;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <344, 346>
double[][]Var[0][intVar] = doubleVar * doubleVar  + doubleVar * doubleVar + doubleVar * doubleVar +
                    doubleVar * doubleVar  + doubleVar * doubleVar + doubleVar * doubleVar +
                    doubleVar * doubleVar + doubleVar * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <268, 280>
if (observed1[i] == 0 && observed2[i] == 0) {
                throw MathRuntimeException.createIllegalArgumentException(
                      "observed counts are both zero for entry {0}", i);
            } else {
                obs1 = observed1[i];
                obs2 = observed2[i];
                if (unequalCounts) { // apply weights
                    dev = obs1/weight - obs2 * weight;
                } else {
                    dev = obs1 - obs2;
                }
                sumSq += (dev * dev) / (obs1 + obs2);
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <268, 280>
if (long[]Var[intVar] == 0 && long[]Var[intVar] == 0) {
                throw MathRuntimeException.createIllegalArgumentException(
                      "observed counts are both zero for entry {0}", intVar);
            } else {
                doubleVar = long[]Var[intVar];
                doubleVar = long[]Var[intVar];
                if (booleanVar) { // apply weights
                    doubleVar = doubleVar/doubleVar - doubleVar * doubleVar;
                } else {
                    doubleVar = doubleVar - doubleVar;
                }
                doubleVar += (doubleVar * doubleVar) / (doubleVar + doubleVar);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <355, 361>
for (int j = 0; j < solvedCols; ++j) {
          int pj = permutation[j];
          lmDir[pj] = -lmDir[pj];
          parameters[pj].setEstimate(oldX[pj] + lmDir[pj]);
          double s = diag[pj] * lmDir[pj];
          lmNorm  += s * s;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <355, 361>
for (int intVar = 0; intVar < intVar; ++intVar) {
          int pj = int[]Var[intVar];
          double[]Var[pj] = -double[]Var[pj];
          EstimatedParameter[]Var[pj].setEstimate(double[]Var[pj] + double[]Var[pj]);
          double s = double[]Var[pj] * double[]Var[pj];
          doubleVar  += s * s;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <355, 361>
for (int j = 0; j < solvedCols; ++j) {
          int pj = permutation[j];
          lmDir[pj] = -lmDir[pj];
          parameters[pj].setEstimate(oldX[pj] + lmDir[pj]);
          double s = diag[pj] * lmDir[pj];
          lmNorm  += s * s;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <263, 266>
for (int i = k; i < m; ++i) {
                final double c = householderVectors[i][k];
                xNormSqr += c * c;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <263, 266>
for (int intVar = intVar; intVar < intVar; ++intVar) {
                final double c = doubleVar[intVar][intVar];
                doubleVar += c * c;
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <263, 266>
for (int i = k; i < m; ++i) {
                final double c = householderVectors[i][k];
                xNormSqr += c * c;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <480, 485>
for (int j = 0; j < solvedCols; ++j) {
            int pj = permutation[j];
            double s = diag[pj] * lmDir[pj];
            work1[pj] = s;
            dxNorm += s * s;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <480, 485>
for (int intVar = 0; intVar < intVar; ++intVar) {
            int pj = int[]Var[intVar];
            double s = double[]Var[pj] * double[]Var[pj];
            double[]Var[pj] = s;
            doubleVar += s * s;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <480, 485>
for (int j = 0; j < solvedCols; ++j) {
            int pj = permutation[j];
            double s = diag[pj] * lmDir[pj];
            work1[pj] = s;
            dxNorm += s * s;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <556, 561>
for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = diag[pj] * lmDir[pj];
                work3[pj] = s;
                dxNorm += s * s;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <556, 561>
for (int intVar = 0; intVar < intVar; ++intVar) {
                int pj = int[]Var[intVar];
                double s = double[]Var[pj] * double[]Var[pj];
                double[]Var[pj] = s;
                doubleVar += s * s;
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <556, 561>
for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = diag[pj] * lmDir[pj];
                work3[pj] = s;
                dxNorm += s * s;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <519, 524>
for (int j = 0; j < solvedCols; ++j) {
      int pj = permutation[j];
      double s = diag[pj] * lmDir[pj];
      work1[pj] = s;
      dxNorm += s * s;
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <519, 524>
for (int intVar = 0; intVar < intVar; ++intVar) {
      int pj = int[]Var[intVar];
      double s = double[]Var[pj] * double[]Var[pj];
      double[]Var[pj] = s;
      doubleVar += s * s;
    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <519, 524>
for (int j = 0; j < solvedCols; ++j) {
      int pj = permutation[j];
      double s = diag[pj] * lmDir[pj];
      work1[pj] = s;
      dxNorm += s * s;
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <599, 604>
for (int j = 0; j < solvedCols; ++j) {
        int pj = permutation[j];
        double s = diag[pj] * lmDir[pj];
        work3[pj] = s;
        dxNorm += s * s;
      }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <599, 604>
for (int intVar = 0; intVar < intVar; ++intVar) {
        int pj = int[]Var[intVar];
        double s = double[]Var[pj] * double[]Var[pj];
        double[]Var[pj] = s;
        doubleVar += s * s;
      }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <599, 604>
for (int j = 0; j < solvedCols; ++j) {
        int pj = permutation[j];
        double s = diag[pj] * lmDir[pj];
        work3[pj] = s;
        dxNorm += s * s;
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastCosineTransformer <240, 247>
for (int i = 1; i < (n >> 1); i++) {
            final double a = 0.5 * (f[i] + f[n-i]);
            final double b = Math.sin(i * Math.PI / n) * (f[i] - f[n-i]);
            final double c = Math.cos(i * Math.PI / n) * (f[i] - f[n-i]);
            x[i] = a - b;
            x[n-i] = a + b;
            t1 += c;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastCosineTransformer <240, 247>
for (int intVar = 1; intVar < (intVar >> 1); intVar++) {
            final double a = 0.5 * (doubleVar[intVar] + doubleVar[intVar-intVar]);
            final double b = Math.sin(intVar * Math.PI / intVar) * (doubleVar[intVar] - doubleVar[intVar-intVar]);
            final double c = Math.cos(intVar * Math.PI / intVar) * (doubleVar[intVar] - doubleVar[intVar-intVar]);
            double[]Var[intVar] = a - b;
            double[]Var[intVar-intVar] = a + b;
            doubleVar += c;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastCosineTransformer <240, 247>
for (int i = 1; i < (n >> 1); i++) {
            final double a = 0.5 * (f[i] + f[n-i]);
            final double b = Math.sin(i * Math.PI / n) * (f[i] - f[n-i]);
            final double c = Math.cos(i * Math.PI / n) * (f[i] - f[n-i]);
            x[i] = a - b;
            x[n-i] = a + b;
            t1 += c;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <206, 210>
for (int i = 0; i < interpolatedState.length; ++i) {
      interpolatedState[i] =
          currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));
      interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <206, 210>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
      double[]Var[intVar] =
          double[]Var[intVar] - doubleVar * (double[]Var[intVar] - doubleVar * (double[]Var[intVar] + doubleVar * (double[]Var[intVar] + doubleVar * double[]Var[intVar])));
      double[]Var[intVar] = double[]Var[intVar] + doubleVar * double[]Var[intVar] + doubleVar * double[]Var[intVar] + doubleVar * double[]Var[intVar];
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <320, 326>
for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    lmDir[pj] = -lmDir[pj];
                    point[pj] = oldX[pj] + lmDir[pj];
                    double s = diag[pj] * lmDir[pj];
                    lmNorm  += s * s;
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <320, 326>
for (int intVar = 0; intVar < intVar; ++intVar) {
                    int pj = int[]Var[intVar];
                    double[]Var[pj] = -double[]Var[pj];
                    double[]Var[pj] = double[]Var[pj] + double[]Var[pj];
                    double s = double[]Var[pj] * double[]Var[pj];
                    doubleVar  += s * s;
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <320, 326>
for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    lmDir[pj] = -lmDir[pj];
                    point[pj] = oldX[pj] + lmDir[pj];
                    double s = diag[pj] * lmDir[pj];
                    lmNorm  += s * s;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GillStepInterpolator <111, 120>
for (int i = 0; i < interpolatedState.length; ++i) {
        final double yDot1 = yDotK[0][i];
        final double yDot2 = yDotK[1][i];
        final double yDot3 = yDotK[2][i];
        final double yDot4 = yDotK[3][i];
        interpolatedState[i] =
            currentState[i] - coeff1 * yDot1 - coeff2 * yDot2 - coeff3 * yDot3 - coeff4 * yDot4;
        interpolatedDerivatives[i] =
            coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;
     }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GillStepInterpolator <111, 120>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
        final double yDot1 = double[][]Var[0][intVar];
        final double yDot2 = double[][]Var[1][intVar];
        final double yDot3 = double[][]Var[2][intVar];
        final double yDot4 = double[][]Var[3][intVar];
        double[]Var[intVar] =
            double[]Var[intVar] - doubleVar * yDot1 - doubleVar * yDot2 - doubleVar * yDot3 - doubleVar * yDot4;
        double[]Var[intVar] =
            doubleVar * yDot1 + doubleVar * yDot2 + doubleVar * yDot3 + doubleVar * yDot4;
     }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GillStepInterpolator <111, 120>
for (int i = 0; i < interpolatedState.length; ++i) {
        final double yDot1 = yDotK[0][i];
        final double yDot2 = yDotK[1][i];
        final double yDot3 = yDotK[2][i];
        final double yDot4 = yDotK[3][i];
        interpolatedState[i] =
            currentState[i] - coeff1 * yDot1 - coeff2 * yDot2 - coeff3 * yDot3 - coeff4 * yDot4;
        interpolatedDerivatives[i] =
            coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;
     }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolator <102, 112>
for (int i = 0; i < interpolatedState.length; ++i) {
          final double yDot1 = yDotK[0][i];
          final double yDot2 = yDotK[1][i];
          final double yDot3 = yDotK[2][i];
          final double yDot4 = yDotK[3][i];
          interpolatedState[i] =
              currentState[i] - coeff1 * yDot1 - coeff2 * yDot2 - coeff3 * yDot3 - coeff4 * yDot4;
          interpolatedDerivatives[i] =
              coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;

      }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolator <102, 112>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
          final double yDot1 = double[][]Var[0][intVar];
          final double yDot2 = double[][]Var[1][intVar];
          final double yDot3 = double[][]Var[2][intVar];
          final double yDot4 = double[][]Var[3][intVar];
          double[]Var[intVar] =
              double[]Var[intVar] - doubleVar * yDot1 - doubleVar * yDot2 - doubleVar * yDot3 - doubleVar * yDot4;
          double[]Var[intVar] =
              doubleVar * yDot1 + doubleVar * yDot2 + doubleVar * yDot3 + doubleVar * yDot4;

      }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolator <102, 112>
for (int i = 0; i < interpolatedState.length; ++i) {
          final double yDot1 = yDotK[0][i];
          final double yDot2 = yDotK[1][i];
          final double yDot3 = yDotK[2][i];
          final double yDot4 = yDotK[3][i];
          interpolatedState[i] =
              currentState[i] - coeff1 * yDot1 - coeff2 * yDot2 - coeff3 * yDot3 - coeff4 * yDot4;
          interpolatedDerivatives[i] =
              coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;

      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator <138, 150>
for (int j = 0; j < y0.length; ++j) {
        final double errSum = E1 * yDotK[0][j] +  E3 * yDotK[2][j] +
                              E4 * yDotK[3][j] +  E5 * yDotK[4][j] +
                              E6 * yDotK[5][j] +  E7 * yDotK[6][j];

        final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
        final double tol = (vecAbsoluteTolerance == null) ?
                           (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                               (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
        final double ratio  = h * errSum / tol;
        error += ratio * ratio;

    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator <138, 150>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
        final double errSum = doubleVar * double[][]Var[0][intVar] +  doubleVar * double[][]Var[2][intVar] +
                              doubleVar * double[][]Var[3][intVar] +  doubleVar * double[][]Var[4][intVar] +
                              doubleVar * double[][]Var[5][intVar] +  doubleVar * double[][]Var[6][intVar];

        final double yScale = Math.max(Math.abs(double[]Var[intVar]), Math.abs(double[]Var[intVar]));
        final double tol = (double[]Var == null) ?
                           (doubleVar + doubleVar * yScale) :
                               (double[]Var[intVar] + double[]Var[intVar] * yScale);
        final double ratio  = doubleVar * errSum / tol;
        doubleVar += ratio * ratio;

    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator <138, 150>
for (int j = 0; j < y0.length; ++j) {
        final double errSum = E1 * yDotK[0][j] +  E3 * yDotK[2][j] +
                              E4 * yDotK[3][j] +  E5 * yDotK[4][j] +
                              E6 * yDotK[5][j] +  E7 * yDotK[6][j];

        final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
        final double tol = (vecAbsoluteTolerance == null) ?
                           (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                               (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
        final double ratio  = h * errSum / tol;
        error += ratio * ratio;

    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.LUDecompositionImpl <146, 150>
for (int i = 0; i < m; i++) {
                    tmp = luMax[i];
                    luMax[i] = luCol[i];
                    luCol[i] = tmp;
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.LUDecompositionImpl <146, 150>
for (int intVar = 0; intVar < intVar; intVar++) {
                    doubleVar = double[]Var[intVar];
                    double[]Var[intVar] = double[]Var[intVar];
                    double[]Var[intVar] = doubleVar;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolator <67, 77>
for (int j = 0; j < yLen; j++) {
                if (fval[i][j].length != zLen) {
                    throw new DimensionMismatchException(fval[i][j].length, zLen);
                }
                
                for (int k = 0; k < zLen; k++) {
                    final double v = fval[i][j][k];
                    fvalXY[k][i][j] = v;
                    fvalZX[j][k][i] = v;
                }
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolator <67, 77>
for (int j = 0; j < yLen; j++) {
                if (fval[i][j].length != zLen) {
                    throw new DimensionMismatchException(fval[i][j].length, zLen);
                }
                
                for (int k = 0; k < zLen; k++) {
                    final double v = fval[i][j][k];
                    fvalXY[k][i][j] = v;
                    fvalZX[j][k][i] = v;
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <151, 166>
for (int i = 0; i < randomBytes.length; i++) {
            Integer c = Integer.valueOf(randomBytes[i]);

            /*
             * Add 128 to byte value to make interval 0-255 before doing hex
             * conversion. This guarantees <= 2 hex digits from toHexString()
             * toHexString would otherwise add 2^32 to negative arguments.
             */
            String hex = Integer.toHexString(c.intValue() + 128);

            // Make sure we add 2 hex digits for each byte
            if (hex.length() == 1) {
                hex = "0" + hex;
            }
            outBuffer.append(hex);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <260, 275>
for (int i = 0; i < hash.length; i++) {
                Integer c = Integer.valueOf(hash[i]);

                /*
                 * Add 128 to byte value to make interval 0-255 This guarantees
                 * <= 2 hex digits from toHexString() toHexString would
                 * otherwise add 2^32 to negative arguments
                 */
                String hex = Integer.toHexString(c.intValue() + 128);

                // Keep strings uniform length -- guarantees 40 bytes
                if (hex.length() == 1) {
                    hex = "0" + hex;
                }
                outBuffer.append(hex);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <350, 353>
v[k+3][i] = D[k][0] * yDot1  + D[k][1]  * yDot6  + D[k][2]  * yDot7  +
                          D[k][3] * yDot8  + D[k][4]  * yDot9  + D[k][5]  * yDot10 +
                          D[k][6] * yDot11 + D[k][7]  * yDot12 + D[k][8]  * yDot13 +
                          D[k][9] * yDot14 + D[k][10] * yDot15 + D[k][11] * yDot16;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <350, 353>
double[][]Var[intVar+3][intVar] = double[][]Var[intVar][0] * doubleVar  + double[][]Var[intVar][1]  * doubleVar  + double[][]Var[intVar][2]  * doubleVar  +
                          double[][]Var[intVar][3] * doubleVar  + double[][]Var[intVar][4]  * doubleVar  + double[][]Var[intVar][5]  * doubleVar +
                          double[][]Var[intVar][6] * doubleVar + double[][]Var[intVar][7]  * doubleVar + double[][]Var[intVar][8]  * doubleVar +
                          double[][]Var[intVar][9] * doubleVar + double[][]Var[intVar][10] * doubleVar + double[][]Var[intVar][11] * doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <114, 120>
for (int i = 0; i < n; i++) {
            coefficients[0] = y[i];
            coefficients[1] = b[i];
            coefficients[2] = c[i];
            coefficients[3] = d[i];
            polynomials[i] = new PolynomialFunction(coefficients);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <114, 120>
for (int intVar = 0; intVar < intVar; intVar++) {
            doubleVar[0] = doubleVar[intVar];
            doubleVar[1] = doubleVar[intVar];
            doubleVar[2] = doubleVar[intVar];
            doubleVar[3] = doubleVar[intVar];
            PolynomialFunction[intVar] = new PolynomialFunction(doubleVar);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <721, 730>
for (int i = list.length - 1; i >= end; i--) {
            if (i == 0) {
                target = 0;
            } else {
                target = nextInt(0, i);
            }
            int temp = list[target];
            list[target] = list[i];
            list[i] = temp;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolator <89, 99>
for (int i = 0; i < interpolatedState.length; ++i) {
        final double yDot0 = yDotK[0][i];
        final double yDot2 = yDotK[2][i];
        final double yDot3 = yDotK[3][i];
        final double yDot4 = yDotK[4][i];
        final double yDot5 = yDotK[5][i];
        interpolatedState[i] =
            currentState[i] + b0 * yDot0 + b2 * yDot2 + b3 * yDot3 + b4 * yDot4 + b5 * yDot5;
        interpolatedDerivatives[i] =
            bDot0 * yDot0 + bDot2 * yDot2 + bDot3 * yDot3 + bDot4 * yDot4 + bDot5 * yDot5;
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolator <89, 99>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
        final double yDot0 = double[][]Var[0][intVar];
        final double yDot2 = double[][]Var[2][intVar];
        final double yDot3 = double[][]Var[3][intVar];
        final double yDot4 = double[][]Var[4][intVar];
        final double yDot5 = double[][]Var[5][intVar];
        double[]Var[intVar] =
            double[]Var[intVar] + doubleVar * yDot0 + doubleVar * yDot2 + doubleVar * yDot3 + doubleVar * yDot4 + doubleVar * yDot5;
        double[]Var[intVar] =
            doubleVar * yDot0 + doubleVar * yDot2 + doubleVar * yDot3 + doubleVar * yDot4 + doubleVar * yDot5;
    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolator <89, 99>
for (int i = 0; i < interpolatedState.length; ++i) {
        final double yDot0 = yDotK[0][i];
        final double yDot2 = yDotK[2][i];
        final double yDot3 = yDotK[3][i];
        final double yDot4 = yDotK[4][i];
        final double yDot5 = yDotK[5][i];
        interpolatedState[i] =
            currentState[i] + b0 * yDot0 + b2 * yDot2 + b3 * yDot3 + b4 * yDot4 + b5 * yDot5;
        interpolatedDerivatives[i] =
            bDot0 * yDot0 + bDot2 * yDot2 + bDot3 * yDot3 + bDot4 * yDot4 + bDot5 * yDot5;
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <175, 197>
for (int i = 0; i < maximalIterationCount; ++i) {

            // improve integral with a larger number of steps
            final double t = stage(f, min, max, n);

            // estimate error
            final double delta = Math.abs(t - oldt);
            final double limit =
                Math.max(absoluteAccuracy,
                         relativeAccuracy * (Math.abs(oldt) + Math.abs(t)) * 0.5);

            // check convergence
            if ((i + 1 >= minimalIterationCount) && (delta <= limit)) {
                setResult(t, i);
                return result;
            }

            // prepare next iteration
            double ratio = Math.min(4, Math.pow(delta / limit, 0.5 / abscissas.length));
            n = Math.max((int) (ratio * n), n + 1);
            oldt = t;

        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <175, 197>
for (int intVar = 0; intVar < intVar; ++intVar) {

            // improve integral with a larger number of steps
            final double t = stage(UnivariateRealFunction, doubleVar, doubleVar, intVar);

            // estimate error
            final double delta = Math.abs(t - doubleVar);
            final double limit =
                Math.max(doubleVar,
                         doubleVar * (Math.abs(doubleVar) + Math.abs(t)) * 0.5);

            // check convergence
            if ((intVar + 1 >= intVar) && (delta <= limit)) {
                setResult(t, intVar);
                return doubleVar;
            }

            // prepare next iteration
            double ratio = Math.min(4, Math.pow(delta / limit, 0.5 / double[]Var.length));
            intVar = Math.max((int) (ratio * intVar), intVar + 1);
            doubleVar = t;

        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.integration.LegendreGaussIntegrator <175, 197>
for (int i = 0; i < maximalIterationCount; ++i) {

            // improve integral with a larger number of steps
            final double t = stage(UnivariateRealFunction, min, max, n);

            // estimate error
            final double delta = Math.abs(t - oldt);
            final double limit =
                Math.max(absoluteAccuracy,
                         relativeAccuracy * (Math.abs(oldt) + Math.abs(t)) * 0.5);

            // check convergence
            if ((i + 1 >= minimalIterationCount) && (delta <= limit)) {
                setResult(t, i);
                return result;
            }

            // prepare next iteration
            double ratio = Math.min(4, Math.pow(delta / limit, 0.5 / abscissas.length));
            n = Math.max((int) (ratio * n), n + 1);
            oldt = t;

        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.TricubicSplineInterpolator <150, 168>
for (int i = 0; i < xLen ; i++) {
            final int nI = nextIndex(i, xLen);
            final int pI = previousIndex(i);
            for (int j = 0; j < yLen; j++) {
                final int nJ = nextIndex(j, yLen);
                final int pJ = previousIndex(j);
                for (int k = 0; k < zLen; k++) {
                    final int nK = nextIndex(k, zLen);
                    final int pK = previousIndex(k);
                    
                    // XXX Not sure about this formula
                    d3FdXdYdZ[i][j][k] = (fval[nI][nJ][nK] - fval[nI][pJ][nK] -
                                          fval[pI][nJ][nK] + fval[pI][pJ][nK] -
                                          fval[nI][nJ][pK] + fval[nI][pJ][pK] +
                                          fval[pI][nJ][pK] - fval[pI][pJ][pK]) /
                        ((xval[nI] - xval[pI]) * (yval[nJ] - yval[pJ]) * (zval[nK] - zval[pK])) ;
                }
            }
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <94, 95>
doubleVar[intVar] = (3d * (doubleVar[intVar + 1] * doubleVar[intVar - 1] - doubleVar[intVar] * (doubleVar[intVar + 1] - doubleVar[intVar - 1])+ doubleVar[intVar - 1] * doubleVar[intVar]) /
                    (doubleVar[intVar - 1] * doubleVar[intVar]) - doubleVar[intVar - 1] * doubleVar[intVar - 1]) / doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.CholeskyDecompositionImpl <328, 341>
for (int j = m - 1; j >= 0; j--) {
                final double lJJ = lTData[j][j];
                final double[] xJ = x[j];
                for (int k = 0; k < nColB; ++k) {
                    xJ[k] /= lJJ;
                }
                for (int i = 0; i < j; i++) {
                    final double[] xI = x[i];
                    final double lIJ = lTData[i][j];
                    for (int k = 0; k < nColB; ++k) {
                        xI[k] -= xJ[k] * lIJ;
                    }
                }
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.CholeskyDecompositionImpl <328, 341>
for (int j = m - 1; j >= 0; j--) {
                final double lJJ = lTData[j][j];
                final double[] xJ = x[j];
                for (int k = 0; k < nColB; ++k) {
                    xJ[k] /= lJJ;
                }
                for (int i = 0; i < j; i++) {
                    final double[] xI = x[i];
                    final double lIJ = lTData[i][j];
                    for (int k = 0; k < nColB; ++k) {
                        xI[k] -= xJ[k] * lIJ;
                    }
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.FieldLUDecompositionImpl <133, 137>
for (int i = 0; i < m; i++) {
                    tmp = lu[nonZero][i];
                    lu[nonZero][i] = lu[col][i];
                    lu[col][i] = tmp;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1277, 1281>
for (int i = 0; i < nCols; i++) {
                    tmp = lu[max][i];
                    lu[max][i] = lu[col][i];
                    lu[col][i] = tmp;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator <252, 270>
for (int j = 0; j < y0.length; ++j) {
      final double errSum1 = E1_01 * yDotK[0][j]  + E1_06 * yDotK[5][j] +
                             E1_07 * yDotK[6][j]  + E1_08 * yDotK[7][j] +
                             E1_09 * yDotK[8][j]  + E1_10 * yDotK[9][j] +
                             E1_11 * yDotK[10][j] + E1_12 * yDotK[11][j];
      final double errSum2 = E2_01 * yDotK[0][j]  + E2_06 * yDotK[5][j] +
                             E2_07 * yDotK[6][j]  + E2_08 * yDotK[7][j] +
                             E2_09 * yDotK[8][j]  + E2_10 * yDotK[9][j] +
                             E2_11 * yDotK[10][j] + E2_12 * yDotK[11][j];

      final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
      final double tol = (vecAbsoluteTolerance == null) ?
                         (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                         (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
      final double ratio1  = errSum1 / tol;
      error1        += ratio1 * ratio1;
      final double ratio2  = errSum2 / tol;
      error2        += ratio2 * ratio2;
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator <252, 270>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
      final double errSum1 = doubleVar * double[][]Var[0][intVar]  + doubleVar * double[][]Var[5][intVar] +
                             doubleVar * double[][]Var[6][intVar]  + doubleVar * double[][]Var[7][intVar] +
                             doubleVar * double[][]Var[8][intVar]  + doubleVar * double[][]Var[9][intVar] +
                             doubleVar * double[][]Var[10][intVar] + doubleVar * double[][]Var[11][intVar];
      final double errSum2 = doubleVar * double[][]Var[0][intVar]  + doubleVar * double[][]Var[5][intVar] +
                             doubleVar * double[][]Var[6][intVar]  + doubleVar * double[][]Var[7][intVar] +
                             doubleVar * double[][]Var[8][intVar]  + doubleVar * double[][]Var[9][intVar] +
                             doubleVar * double[][]Var[10][intVar] + doubleVar * double[][]Var[11][intVar];

      final double yScale = Math.max(Math.abs(double[]Var[intVar]), Math.abs(double[]Var[intVar]));
      final double tol = (double[]Var == null) ?
                         (doubleVar + doubleVar * yScale) :
                         (double[]Var[intVar] + double[]Var[intVar] * yScale);
      final double ratio1  = errSum1 / tol;
      doubleVar        += ratio1 * ratio1;
      final double ratio2  = errSum2 / tol;
      doubleVar        += ratio2 * ratio2;
    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator <252, 270>
for (int j = 0; j < y0.length; ++j) {
      final double errSum1 = E1_01 * yDotK[0][j]  + E1_06 * yDotK[5][j] +
                             E1_07 * yDotK[6][j]  + E1_08 * yDotK[7][j] +
                             E1_09 * yDotK[8][j]  + E1_10 * yDotK[9][j] +
                             E1_11 * yDotK[10][j] + E1_12 * yDotK[11][j];
      final double errSum2 = E2_01 * yDotK[0][j]  + E2_06 * yDotK[5][j] +
                             E2_07 * yDotK[6][j]  + E2_08 * yDotK[7][j] +
                             E2_09 * yDotK[8][j]  + E2_10 * yDotK[9][j] +
                             E2_11 * yDotK[10][j] + E2_12 * yDotK[11][j];

      final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
      final double tol = (vecAbsoluteTolerance == null) ?
                         (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                         (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
      final double ratio1  = errSum1 / tol;
      error1        += ratio1 * ratio1;
      final double ratio2  = errSum2 / tol;
      error2        += ratio2 * ratio2;
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialsUtils <250, 255>
for (int i = 1; i < k; ++i) {
                final BigFraction ckPrev = ck;
                ck     = coefficients.get(startK + i);
                ckm1   = coefficients.get(startKm1 + i);
                coefficients.add(ck.multiply(ai[0]).add(ckPrev.multiply(ai[1])).subtract(ckm1.multiply(ai[2])));
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <371, 383>
for (int i = 0; i < interpolatedState.length; ++i) {
      interpolatedState[i] = currentState[i] -
                             oneMinusThetaH * (v[0][i] -
                                               theta * (v[1][i] +
                                                        theta * (v[2][i] +
                                                                 eta * (v[3][i] +
                                                                        theta * (v[4][i] +
                                                                                 eta * (v[5][i] +
                                                                                        theta * (v[6][i])))))));
      interpolatedDerivatives[i] =  v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] +
                                    dot3 * v[3][i] + dot4 * v[4][i] +
                                    dot5 * v[5][i] + dot6 * v[6][i];
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <371, 383>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
      double[]Var[intVar] = double[]Var[intVar] -
                             doubleVar * (double[][]Var[0][intVar] -
                                               doubleVar * (double[][]Var[1][intVar] +
                                                        doubleVar * (double[][]Var[2][intVar] +
                                                                 doubleVar * (double[][]Var[3][intVar] +
                                                                        doubleVar * (double[][]Var[4][intVar] +
                                                                                 doubleVar * (double[][]Var[5][intVar] +
                                                                                        doubleVar * (double[][]Var[6][intVar])))))));
      double[]Var[intVar] =  double[][]Var[0][intVar] + doubleVar * double[][]Var[1][intVar] + doubleVar * double[][]Var[2][intVar] +
                                    doubleVar * double[][]Var[3][intVar] + doubleVar * double[][]Var[4][intVar] +
                                    doubleVar * double[][]Var[5][intVar] + doubleVar * double[][]Var[6][intVar];
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics <122, 130>
for (int i = 0; i < k; ++i) {
            sumImpl[i]     = new Sum();
            sumSqImpl[i]   = new SumOfSquares();
            minImpl[i]     = new Min();
            maxImpl[i]     = new Max();
            sumLogImpl[i]  = new SumOfLogs();
            geoMeanImpl[i] = new GeometricMean();
            meanImpl[i]    = new Mean();
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.OpenIntToDoubleHashMap <455, 461>
if (oldStates[i] == FULL) {
                final int key = oldKeys[i];
                final int index = findInsertionIndex(newKeys, newStates, key, newMask);
                newKeys[index]   = key;
                newValues[index] = oldValues[i];
                newStates[index] = FULL;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.OpenIntToFieldHashMap <467, 473>
if (oldStates[i] == FULL) {
                final int key = oldKeys[i];
                final int index = findInsertionIndex(newKeys, newStates, key, newMask);
                newKeys[index]   = key;
                newValues[index] = oldValues[i];
                newStates[index] = FULL;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.CorrelatedRandomVectorGenerator <205, 211>
for (int i = rank + 1; i < order; ++i) {
                int ii  = index[i];
                int isi = index[swap[i]];
                if (c[ii][ii] > c[isi][isi]) {
                    swap[rank] = i;
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.CholeskyDecompositionImpl <141, 147>
for (int q = order - 1; q > i; --q) {
                ltI[q] *= inverse;
                final double[] ltQ = lTData[q];
                for (int p = q; p < order; ++p) {
                    ltQ[p] -= ltI[q] * ltI[p];
                }
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.CholeskyDecompositionImpl <141, 147>
for (int intVar = intVar - 1; intVar > intVar; --intVar) {
                double[]Var[intVar] *= doubleVar;
                final double[] ltQ = double[][]Var[intVar];
                for (int p = intVar; p < intVar; ++p) {
                    ltQ[p] -= double[]Var[intVar] * double[]Var[p];
                }
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.CholeskyDecompositionImpl <141, 147>
for (int q = order - 1; q > i; --q) {
                ltI[q] *= inverse;
                final double[] ltQ = lTData[q];
                for (int p = q; p < order; ++p) {
                    ltQ[p] -= ltI[q] * ltI[p];
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics <345, 353>
for (int i = 0; i < k; ++i) {
            minImpl[i].clear();
            maxImpl[i].clear();
            sumImpl[i].clear();
            sumLogImpl[i].clear();
            sumSqImpl[i].clear();
            geoMeanImpl[i].clear();
            meanImpl[i].clear();
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.LaguerreSolver <338, 342>
for (int j = n-1; j >= 0; j--) {
                d2v = dv.add(z.multiply(d2v));
                dv = pv.add(z.multiply(dv));
                pv = coefficients[j].add(z.multiply(pv));
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.NewtonSolver <118, 128>
while (i < maximalIterationCount) {

                x1 = x0 - (f.value(x0) / derivative.value(x0));
                if (Math.abs(x1 - x0) <= absoluteAccuracy) {
                    setResult(x1, i);
                    return x1;
                }

                x0 = x1;
                ++i;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.solvers.NewtonSolver <118, 128>
while (intVar < intVar) {

                doubleVar = doubleVar - (UnivariateRealFunction.value(doubleVar) / UnivariateRealFunction.value(doubleVar));
                if (Math.abs(doubleVar - doubleVar) <= doubleVar) {
                    setResult(doubleVar, intVar);
                    return doubleVar;
                }

                doubleVar = doubleVar;
                ++intVar;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic <151, 167>
for (int i = begin; i < begin + length; i++) {
            if (Double.isNaN(weights[i])) {
                throw MathRuntimeException.createIllegalArgumentException(
                        "NaN weight at index {0}", i);
            }
            if (Double.isInfinite(weights[i])) {
                throw MathRuntimeException.createIllegalArgumentException(
                        "Infinite weight at index {0}", i);
            }
            if (weights[i] < 0) {
                throw MathRuntimeException.createIllegalArgumentException(
                      "negative weight {0} at index {1} ", weights[i], i);
            }
            if (!containsPositiveWeight && weights[i] > 0.0) {
                containsPositiveWeight = true;
            }
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics <147, 156>
for (int i = 0; i < k; ++i) {
            double v = value[i];
            sumImpl[i].increment(v);
            sumSqImpl[i].increment(v);
            minImpl[i].increment(v);
            maxImpl[i].increment(v);
            sumLogImpl[i].increment(v);
            geoMeanImpl[i].increment(v);
            meanImpl[i].increment(v);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics <147, 156>
for (int i = 0; i < k; ++i) {
            double v = value[i];
            sumImpl[i].increment(v);
            sumSqImpl[i].increment(v);
            minImpl[i].increment(v);
            maxImpl[i].increment(v);
            sumLogImpl[i].increment(v);
            geoMeanImpl[i].increment(v);
            meanImpl[i].increment(v);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <140, 150>
for (int j = 0; j < lastJ; j++) {
                final int jp1 = j + 1;
                final double[] beta = new double[] {
                    f[i][j], f[ip1][j], f[i][jp1], f[ip1][jp1],
                    dFdX[i][j], dFdX[ip1][j], dFdX[i][jp1], dFdX[ip1][jp1],
                    dFdY[i][j], dFdY[ip1][j], dFdY[i][jp1], dFdY[ip1][jp1],
                    d2FdXdY[i][j], d2FdXdY[ip1][j], d2FdXdY[i][jp1], d2FdXdY[ip1][jp1]
                };

                splines[i][j] = new BicubicSplineFunction(computeSplineCoefficients(beta));
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolatingFunction <140, 150>
for (int j = 0; j < lastJ; j++) {
                final int jp1 = j + 1;
                final double[] beta = new double[] {
                    f[i][j], f[ip1][j], f[i][jp1], f[ip1][jp1],
                    dFdX[i][j], dFdX[ip1][j], dFdX[i][jp1], dFdX[ip1][jp1],
                    dFdY[i][j], dFdY[ip1][j], dFdY[i][jp1], dFdY[ip1][jp1],
                    d2FdXdY[i][j], d2FdXdY[ip1][j], d2FdXdY[i][jp1], d2FdXdY[ip1][jp1]
                };

                splines[i][j] = new BicubicSplineFunction(computeSplineCoefficients(beta));
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <372, 379>
for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {
            final double[] outBlock = out.blocks[blockIndex];
            final double[] tBlock   = blocks[blockIndex];
            final double[] mBlock   = m.blocks[blockIndex];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] + mBlock[k];
            }
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockRealMatrix <372, 379>
for (int intVar = 0; intVar < AbstractRealMatrix.doubleVar.length; ++intVar) {
            final double[] outBlock = AbstractRealMatrix.doubleVar[intVar];
            final double[] tBlock   = doubleVar[intVar];
            final double[] mBlock   = AbstractRealMatrix.doubleVar[intVar];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] + mBlock[k];
            }
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BlockRealMatrix <372, 379>
for (int blockIndex = 0; blockIndex < AbstractRealMatrix.blocks.length; ++blockIndex) {
            final double[] outBlock = AbstractRealMatrix.blocks[blockIndex];
            final double[] tBlock   = blocks[blockIndex];
            final double[] mBlock   = AbstractRealMatrix.blocks[blockIndex];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] + mBlock[k];
            }
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <445, 452>
for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {
            final double[] outBlock = out.blocks[blockIndex];
            final double[] tBlock   = blocks[blockIndex];
            final double[] mBlock   = m.blocks[blockIndex];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] - mBlock[k];
            }
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockRealMatrix <445, 452>
for (int intVar = 0; intVar < AbstractRealMatrix.doubleVar.length; ++intVar) {
            final double[] outBlock = AbstractRealMatrix.doubleVar[intVar];
            final double[] tBlock   = doubleVar[intVar];
            final double[] mBlock   = AbstractRealMatrix.doubleVar[intVar];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] - mBlock[k];
            }
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BlockRealMatrix <445, 452>
for (int blockIndex = 0; blockIndex < AbstractRealMatrix.blocks.length; ++blockIndex) {
            final double[] outBlock = AbstractRealMatrix.blocks[blockIndex];
            final double[] tBlock   = blocks[blockIndex];
            final double[] mBlock   = AbstractRealMatrix.blocks[blockIndex];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] - mBlock[k];
            }
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.OpenMapRealMatrix <209, 210>
final double outValue =
                        out.entries.get(outKey) + value * m.entries.get(rightKey);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.OpenMapRealMatrix <209, 210>
final double doubleVar =
                        AbstractRealMatrix.OpenIntToDoubleHashMap.get(intVar) + doubleVar * AbstractRealMatrix.OpenIntToDoubleHashMap.get(intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.OpenMapRealMatrix <209, 210>
final double outValue =
                        AbstractRealMatrix.OpenIntToDoubleHashMap.get(outKey) + value * AbstractRealMatrix.OpenIntToDoubleHashMap.get(rightKey);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <466, 472>
for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {
            final double[] outBlock = out.blocks[blockIndex];
            final double[] tBlock   = blocks[blockIndex];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] + d;
            }
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockRealMatrix <466, 472>
for (int intVar = 0; intVar < AbstractRealMatrix.doubleVar.length; ++intVar) {
            final double[] outBlock = AbstractRealMatrix.doubleVar[intVar];
            final double[] tBlock   = doubleVar[intVar];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] + doubleVar;
            }
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BlockRealMatrix <466, 472>
for (int blockIndex = 0; blockIndex < AbstractRealMatrix.blocks.length; ++blockIndex) {
            final double[] outBlock = AbstractRealMatrix.blocks[blockIndex];
            final double[] tBlock   = blocks[blockIndex];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] + d;
            }
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <486, 492>
for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {
            final double[] outBlock = out.blocks[blockIndex];
            final double[] tBlock   = blocks[blockIndex];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] * d;
            }
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockRealMatrix <486, 492>
for (int intVar = 0; intVar < AbstractRealMatrix.doubleVar.length; ++intVar) {
            final double[] outBlock = AbstractRealMatrix.doubleVar[intVar];
            final double[] tBlock   = doubleVar[intVar];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] * doubleVar;
            }
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BlockRealMatrix <486, 492>
for (int blockIndex = 0; blockIndex < AbstractRealMatrix.blocks.length; ++blockIndex) {
            final double[] outBlock = AbstractRealMatrix.blocks[blockIndex];
            final double[] tBlock   = blocks[blockIndex];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] * d;
            }
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockFieldMatrix <382, 389>
for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {
            final T[] outBlock = out.blocks[blockIndex];
            final T[] tBlock   = blocks[blockIndex];
            final T[] mBlock   = m.blocks[blockIndex];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k].add(mBlock[k]);
            }
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockFieldMatrix <455, 462>
for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {
            final T[] outBlock = out.blocks[blockIndex];
            final T[] tBlock   = blocks[blockIndex];
            final T[] mBlock   = m.blocks[blockIndex];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k].subtract(mBlock[k]);
            }
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <727, 727>
final int      outIndex = iBlock * out.blockColumns + jBlock;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockFieldMatrix <702, 702>
final int      outIndex = iBlock * out.blockColumns + jBlock;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockFieldMatrix <476, 482>
for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {
            final T[] outBlock = out.blocks[blockIndex];
            final T[] tBlock   = blocks[blockIndex];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k].add(d);
            }
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockFieldMatrix <496, 502>
for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {
            final T[] outBlock = out.blocks[blockIndex];
            final T[] tBlock   = blocks[blockIndex];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k].multiply(d);
            }
        }

