---patch code ori--- org.apache.commons.math.util.MathUtils <412, 414>
if ((u == 0) || (v == 0)) {
            return (Math.abs(u) + Math.abs(v));
        }

---fix ingredient(SameMethod)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <412, 414>
if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }

---patch code 0--- org.apache.commons.math.util.MathUtils <412, 414>
if ((intVar == 0) || (intVar == 0)) {
            return (Math.abs(intVar) + Math.abs(intVar));
        }

---fix ingredient(SameMethod)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <412, 414>
if (intVar * intVar == 0) {
            return (Math.abs(intVar) + Math.abs(intVar));
        }

---patch code 1--- org.apache.commons.math.util.MathUtils <412, 414>
if ((u == 0) || (v == 0)) {
            return (Math.abs(u) + Math.abs(v));
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <381, 391>
if (vecAbsoluteTolerance == null) {
      for (int i = 0; i < scale.length; ++i) {
        final double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));
        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * yi;
      }
    } else {
      for (int i = 0; i < scale.length; ++i) {
        final double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));
        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yi;
      }
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.AbstractIntegrator <157, 162>
if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {
            throw new IntegratorException("too small integration interval: length = {0}",
                                          new Object[] {
                                              Double.valueOf(Math.abs(t - t0))
                                          });
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.AbstractIntegrator <157, 162>
if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {
            throw new IntegratorException("too small integration interval: length = {0}",
                                          new Object[] {
                                              Double.valueOf(Math.abs(t - t0))
                                          });
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <553, 556>
if ((Math.abs(fp) <= 0.1 * delta) ||
          ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {
        return;
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <300, 302>
if (Math.abs(sumXX) < 10 * Double.MIN_VALUE) {
            return Double.NaN; //not enough variation in x
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <234, 238>
final double h1 = (maxInv2 < 1.0e-15) ?
                      Math.max(1.0e-6, 0.001 * Math.abs(h)) :
                      Math.pow(0.01 / maxInv2, 1.0 / order);
h = Math.min(100.0 * Math.abs(h), h1);
h = Math.max(h, 1.0e-12 * Math.abs(t0));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.Fraction <142, 146>
if (Math.abs(a0 - value) < epsilon) {
            this.numerator = (int) a0;
            this.denominator = 1;
            return;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.fraction.Fraction <142, 146>
if (Math.abs(a0 - value) < epsilon) {
            Number.numerator = (int) a0;
            Number.denominator = 1;
            return;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <81, 84>
if (Math.abs(sumExpected - sumObserved) > 10E-6) {
            ratio = sumObserved / sumExpected;
            rescale = true;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.complex.Complex <756, 760>
if (real == 0.0 && imaginary == 0.0) {
            return createComplex(0.0, 0.0);
        }
empty line
double t = Math.sqrt((Math.abs(real) + abs()) / 2.0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.HighamHall54Integrator <112, 127>
for (int j = 0; j < y0.length; ++j) {
      double errSum = staticE[0] * yDotK[0][j];
      for (int l = 1; l < staticE.length; ++l) {
        errSum += staticE[l] * yDotK[l][j];
      }

      final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
      final double tol = (vecAbsoluteTolerance == null) ?
                         (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                         (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
      final double ratio  = h * errSum / tol;
      error += ratio * ratio;

    }
empty line
return Math.sqrt(error / y0.length);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.HighamHall54Integrator <112, 127>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
      double errSum = double[]Var[0] * double[][]Var[0][intVar];
      for (int l = 1; l < double[]Var.length; ++l) {
        errSum += double[]Var[l] * double[][]Var[l][intVar];
      }

      final double yScale = Math.max(Math.abs(double[]Var[intVar]), Math.abs(double[]Var[intVar]));
      final double tol = (double[]Var == null) ?
                         (doubleVar + doubleVar * yScale) :
                         (double[]Var[intVar] + double[]Var[intVar] * yScale);
      final double ratio  = doubleVar * errSum / tol;
      doubleVar += ratio * ratio;

    }
empty line
return Math.sqrt(doubleVar / double[]Var.length);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.HighamHall54Integrator <112, 127>
for (int j = 0; j < y0.length; ++j) {
      double errSum = staticE[0] * yDotK[0][j];
      for (int l = 1; l < staticE.length; ++l) {
        errSum += staticE[l] * yDotK[l][j];
      }

      final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
      final double tol = (vecAbsoluteTolerance == null) ?
                         (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                         (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
      final double ratio  = h * errSum / tol;
      error += ratio * ratio;

    }
empty line
return Math.sqrt(error / y0.length);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1741, 1748>
for (int i = 0, sixI = 0; i < m - 1; ++i, sixI += 6) {
            final double g = work[sixI] + d[i] * work[sixI + 9] / work[sixI + 10];
            final double absG = Math.abs(g);
            if (absG < minG) {
                r = i;
                minG = absG;
            }
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <1741, 1748>
for (int intVar = 0, intVar = 0; intVar < intVar - 1; ++intVar, intVar += 6) {
            final double doubleVar = double[]Var[intVar] + double[]Var[intVar] * double[]Var[intVar + 9] / double[]Var[intVar + 10];
            final double absG = Math.abs(doubleVar);
            if (absG < doubleVar) {
                intVar = intVar;
                doubleVar = absG;
            }
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1741, 1748>
for (int i = 0, sixI = 0; i < m - 1; ++i, sixI += 6) {
            final double g = work[sixI] + d[i] * work[sixI + 9] / work[sixI + 10];
            final double absG = Math.abs(g);
            if (absG < minG) {
                r = i;
                minG = absG;
            }
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator <139, 153>
for (int j = 0; j < y0.length; ++j) {
        final double errSum = e1 * yDotK[0][j] +  e3 * yDotK[2][j] +
                              e4 * yDotK[3][j] +  e5 * yDotK[4][j] +
                              e6 * yDotK[5][j] +  e7 * yDotK[6][j];

        final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
        final double tol = (vecAbsoluteTolerance == null) ?
                           (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                               (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
        final double ratio  = h * errSum / tol;
        error += ratio * ratio;

    }
empty line
return Math.sqrt(error / y0.length);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator <139, 153>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
        final double errSum = doubleVar * double[][]Var[0][intVar] +  doubleVar * double[][]Var[2][intVar] +
                              doubleVar * double[][]Var[3][intVar] +  doubleVar * double[][]Var[4][intVar] +
                              doubleVar * double[][]Var[5][intVar] +  doubleVar * double[][]Var[6][intVar];

        final double yScale = Math.max(Math.abs(double[]Var[intVar]), Math.abs(double[]Var[intVar]));
        final double tol = (double[]Var == null) ?
                           (doubleVar + doubleVar * yScale) :
                               (double[]Var[intVar] + double[]Var[intVar] * yScale);
        final double ratio  = doubleVar * errSum / tol;
        doubleVar += ratio * ratio;

    }
empty line
return Math.sqrt(doubleVar / double[]Var.length);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator <139, 153>
for (int j = 0; j < y0.length; ++j) {
        final double errSum = e1 * yDotK[0][j] +  e3 * yDotK[2][j] +
                              e4 * yDotK[3][j] +  e5 * yDotK[4][j] +
                              e6 * yDotK[5][j] +  e7 * yDotK[6][j];

        final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
        final double tol = (vecAbsoluteTolerance == null) ?
                           (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                               (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
        final double ratio  = h * errSum / tol;
        error += ratio * ratio;

    }
empty line
return Math.sqrt(error / y0.length);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealVectorImpl <994, 1002>
throws IllegalArgumentException {
checkVectorDimensions(v.length);
double sum = 0;
for (int i = 0; i < data.length; ++i) {
            final double delta = data[i] - v[i];
            sum += Math.abs(delta);
        }
return sum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <994, 1002>
throws IllegalArgumentException {
checkVectorDimensions(double[]Var.length);
double doubleVar = 0;
for (int intVar = 0; intVar < doubleVar.length; ++intVar) {
            final double delta = doubleVar[intVar] - double[]Var[intVar];
            doubleVar += Math.abs(delta);
        }
return doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <994, 1002>
throws IllegalArgumentException {
checkVectorDimensions(v.length);
double sum = 0;
for (int i = 0; i < data.length; ++i) {
            final double delta = data[i] - v[i];
            sum += Math.abs(delta);
        }
return sum;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.BrentSolver <171, 183>
if (Math.abs(yMin) <= functionValueAccuracy) {
                setResult(min, 0);
                ret = min;
            } else if (Math.abs(yMax) <= functionValueAccuracy) {
                setResult(max, 0);
                ret = max;
            } else {
                // neither value is close to zero and min and max do not bracket root.
                throw new IllegalArgumentException
                ("Function values at endpoints do not have different signs." +
                        "  Endpoints: [" + min + "," + max + "]" + 
                        "  Values: [" + yMin + "," + yMax + "]");
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <695, 707>
for (int i = 0; i < secondary.length; ++i) {
            final double absDPrevious = absDCurrent;
            absDCurrent = Math.abs(main[i + 1]);
            final double max = splitTolerance * Math.sqrt(absDPrevious * absDCurrent);
            if (Math.abs(secondary[i]) <= max) {
                list.add(i + 1);
                secondary[i] = 0;
                squaredSecondary[i] = 0;
            }
        }
empty line
list.add(secondary.length + 1);
return list;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <695, 707>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
            final double absDPrevious = doubleVar;
            doubleVar = Math.abs(double[]Var[intVar + 1]);
            final double max = doubleVar * Math.sqrt(absDPrevious * doubleVar);
            if (Math.abs(double[]Var[intVar]) <= max) {
                ListVar.add(intVar + 1);
                double[]Var[intVar] = 0;
                double[]Var[intVar] = 0;
            }
        }
empty line
ListVar.add(double[]Var.length + 1);
return ListVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <695, 707>
for (int i = 0; i < secondary.length; ++i) {
            final double absDPrevious = absDCurrent;
            absDCurrent = Math.abs(main[i + 1]);
            final double max = splitTolerance * Math.sqrt(absDPrevious * absDCurrent);
            if (Math.abs(secondary[i]) <= max) {
                list.add(i + 1);
                secondary[i] = 0;
                squaredSecondary[i] = 0;
            }
        }
empty line
list.add(secondary.length + 1);
return list;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.BrentSolver <103, 106>
if (Math.abs(yInitial) <= functionValueAccuracy) {
            setResult(initial, 0);
            return result;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.BrentSolver <110, 113>
if (Math.abs(yMin) <= functionValueAccuracy) {
            setResult(yMin, 0);
            return result;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.BrentSolver <122, 125>
if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(yMax, 0);
            return result;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator <274, 278>
if (den <= 0.0) {
      den = 1.0;
    }
empty line
return Math.abs(h) * error1 / Math.sqrt(y0.length * den);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealVectorImpl <981, 989>
try {
            return getL1Distance((RealVectorImpl) v);
        } catch (ClassCastException cce) {
            checkVectorDimensions(v);
            double sum = 0;
            for (int i = 0; i < data.length; ++i) {
                final double delta = data[i] - v.getEntry(i); 
                sum += Math.abs(delta);
            }
            return sum;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <981, 989>
try {
            return getL1Distance((RealVectorImpl) RealVector);
        } catch (ClassCastException cce) {
            checkVectorDimensions(v);
            double sum = 0;
            for (int i = 0; i < data.length; ++i) {
                final double delta = data[i] - v.getEntry(i); 
                sum += Math.abs(delta);
            }
            return sum;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <266, 278>
if (cost != 0) {
        for (int j = 0; j < solvedCols; ++j) {
          int    pj = permutation[j];
          double s  = jacNorm[pj];
          if (s != 0) {
            double sum = 0;
            for (int i = 0, index = pj; i <= j; ++i, index += cols) {
              sum += jacobian[index] * residuals[i];
            }
            maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
          }
        }
      }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <266, 278>
if (cost != 0) {
        for (int j = 0; j < solvedCols; ++j) {
          int    pj = permutation[j];
          double s  = jacNorm[pj];
          if (s != 0) {
            double sum = 0;
            for (int i = 0, index = pj; i <= j; ++i, index += cols) {
              sum += jacobian[index] * residuals[i];
            }
            maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
          }
        }
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <424, 430>
if (n + omegaCount == 0) {
            for (int i = 0; i < Math.abs(omegaCount); i++) {
                omega[i] = omega[i].conjugate();
            }
            omegaCount = n;
            return;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <424, 430>
if (intVar + intVar == 0) {
            for (int i = 0; i < Math.abs(intVar); i++) {
                Complex[i] = Complex[i].conjugate();
            }
            intVar = intVar;
            return;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <424, 430>
if (n + omegaCount == 0) {
            for (int i = 0; i < Math.abs(omegaCount); i++) {
                Complex[i] = Complex[i].conjugate();
            }
            omegaCount = n;
            return;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealVectorImpl <1040, 1048>
throws IllegalArgumentException {
checkVectorDimensions(v.length);
double max = 0;
for (int i = 0; i < data.length; ++i) {
            final double delta = data[i] - v[i];
            max = Math.max(max, Math.abs(delta));
        }
return max;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <1040, 1048>
throws IllegalArgumentException {
checkVectorDimensions(double[]Var.length);
double doubleVar = 0;
for (int intVar = 0; intVar < doubleVar.length; ++intVar) {
            final double delta = doubleVar[intVar] - double[]Var[intVar];
            doubleVar = Math.max(doubleVar, Math.abs(delta));
        }
return doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <1040, 1048>
throws IllegalArgumentException {
checkVectorDimensions(v.length);
double max = 0;
for (int i = 0; i < data.length; ++i) {
            final double delta = data[i] - v[i];
            max = Math.max(max, Math.abs(delta));
        }
return max;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.geometry.Rotation <439, 443>
if (normProduct == 0) {
      throw new IllegalArgumentException("zero norm for rotation defining vector");
    }
empty line
double dot = Vector3D.dotProduct(u, v);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <645, 648>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.abs(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <645, 648>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.abs(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.TTestImpl <996, 1000>
throws MathException {
double t = Math.abs(t(m, mu, v, n));
distribution.setDegreesOfFreedom(n - 1);
return 2.0 * distribution.cumulativeProbability(-t);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealVectorImpl <1027, 1035>
try {
            return getLInfDistance((RealVectorImpl) v);
        } catch (ClassCastException cce) {
            checkVectorDimensions(v);
            double max = 0;
            for (int i = 0; i < data.length; ++i) {
                final double delta = data[i] - v.getEntry(i); 
                max = Math.max(max, Math.abs(delta));
            }
            return max;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <1027, 1035>
try {
            return getLInfDistance((RealVectorImpl) RealVector);
        } catch (ClassCastException cce) {
            checkVectorDimensions(v);
            double max = 0;
            for (int i = 0; i < data.length; ++i) {
                final double delta = data[i] - v.getEntry(i); 
                max = Math.max(max, Math.abs(delta));
            }
            return max;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <816, 825>
if (useInterpolationError) {
            // use the interpolation error to limit stepsize
            final double interpError = AbstractStepInterpolator.estimateError(scale);
            hInt = Math.abs(stepSize / Math.max(Math.pow(interpError, 1.0 / (mu+4)),
                                                0.01));
            if (interpError > 10.0) {
              hNew = hInt;
              reject = true;
            }
          }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.complex.Complex <761, 766>
if (real >= 0.0) {
            return createComplex(t, imaginary / (2.0 * t));
        } else {
            return createComplex(Math.abs(imaginary) / (2.0 * t),
                MathUtils.indicator(imaginary) * t);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.TTestImpl <1044, 1049>
throws MathException {
double t = Math.abs(homoscedasticT(m1, m2, v1, v2, n1, n2));
double degreesOfFreedom = (double) (n1 + n2 - 2);
distribution.setDegreesOfFreedom(degreesOfFreedom);
return 2.0 * distribution.cumulativeProbability(-t);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.fraction.ProperFractionFormat <98, 102>
if (intVar != 0) {
            getWholeFormat().format(intVar, StringBuffer, FieldPosition);
            StringBuffer.append(' ');
            intVar = Math.abs(intVar);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.MullerSolver <172, 176>
x = isSequence(x0, xplus, x2) ? xplus : xminus;
y = f.value(x);
empty line
// check for convergence
tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);

---fix ingredient(SameMethod)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <420, 422>
if (u > 0) {
            u = -u;
        }

---fix ingredient(SameMethod)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <420, 422>
if (intVar > 0) {
            intVar = -intVar;
        }

---fix ingredient(SameMethod)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <423, 425>
if (intVar > 0) {
            intVar = -intVar;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.special.Gamma <166, 184>
} else {
// calculate series
double n = 0.0;
double an = 1.0 / a;
double sum = an;
while (Math.abs(an) > epsilon && n < maxIterations) {
                // compute next element in the series
                n = n + 1.0;
                an = an * (x / (a + n));

                // update partial sum
                sum = sum + an;
            }
if (n >= maxIterations) {
                throw new MaxIterationsExceededException(maxIterations);
            } else {
                ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.TTestImpl <1019, 1025>
throws MathException {
double t = Math.abs(t(m1, m2, v1, v2, n1, n2));
double degreesOfFreedom = 0;
degreesOfFreedom = df(v1, v2, n1, n2);
distribution.setDegreesOfFreedom(degreesOfFreedom);
return 2.0 * distribution.cumulativeProbability(-t);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <559, 566>
for (int intVar = 0; intVar < BigMatrixImpl.getColumnDimension(); intVar++) {
            BigDecimal sum = BigDecimal;
            for (int row = 0; row < BigMatrixImpl.getRowDimension(); row++) {
                sum = sum.add(BigDecimal[row][intVar].abs());
            }
            BigDecimal = BigDecimal.max(sum);
        }
return BigDecimal;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <559, 566>
for (int col = 0; col < BigMatrixImpl.getColumnDimension(); col++) {
            BigDecimal sum = BigDecimal;
            for (int row = 0; row < BigMatrixImpl.getRowDimension(); row++) {
                sum = sum.add(BigDecimal[row][col].abs());
            }
            BigDecimal = BigDecimal.max(sum);
        }
return BigDecimal;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.Frequency <319, 321>
if (c.compare(v, freqTable.firstKey()) < 0) {
            return 0;  // v is comparable, but less than first value
        }

---fix ingredient(SameMethod)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <442, 459>
do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
return -u * (1 << k);

---fix ingredient(SameMethod)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <442, 459>
do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((intVar & 1) == 0) { // while t is even..
                intVar /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (intVar > 0) {
                intVar = -intVar;
            } else {
                intVar = intVar;
            }
            // B6/B3. at this point both u and v should be odd.
            intVar = (intVar - intVar) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (intVar != 0);
return -intVar * (1 << intVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.Frequency <330, 334>
if (c.compare(v, nextValue) > 0) {
                result += getCount(nextValue);
            } else {
                return result;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.Frequency <195, 203>
try { 
            Long count =  (Long) freqTable.get(v);
            if (count != null) {
                result = count.longValue();
            }
        } catch (ClassCastException ex) {
            // ignore and return 0 -- ClassCastException will be thrown if value is not comparable
        }
return result;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <136, 141>
if (v == null) {
        v = new double[7][];
        for (int k = 0; k < 7; ++k) {
          v[k] = new double[interpolatedState.length];
        }
      }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <1032, 1035>
for (int intVar = 0; intVar < BigDecimal.length; intVar++) {
            BigDecimal[intVar] = new BigDecimal(double[]Var[intVar]);
        }
return operate(BigDecimal);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <1032, 1035>
for (int i = 0; i < BigDecimal.length; i++) {
            BigDecimal[i] = new BigDecimal(v[i]);
        }
return operate(BigDecimal);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <384, 398>
/**
     * {@inheritDoc}<p>
     * <strong>Algorithm Description</strong>: scales the output of
     * Random.nextDouble(), but rejects 0 values (i.e., will generate another
     * random double if Random.nextDouble() returns 0).
     * This is necessary to provide a symmetric output interval
     * (both endpoints excluded).</p>
     * 
     * @param lower the lower bound.
     * @param upper the upper bound.
     * @return a uniformly distributed random value from the interval (lower, upper)
     */
    public double nextUniform(double lower, double upper) {
        if (lower >= upper) {
            throw new IllegalArgumentException
            ("lower bound must be < upper bound");
        }
        RandomGenerator rand = getRan();

        // ensure nextDouble() isn't 0.0
        double u = rand.nextDouble();
        while(u <= 0.0){
            u = rand.nextDouble();
        }

        return lower + u * (upper - lower);
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealVectorImpl <871, 878>
try {
            return dotProduct((RealVectorImpl) v);
        } catch (ClassCastException cce) {
            checkVectorDimensions(v);
            double dot = 0;
            for (int i = 0; i < data.length; i++) {
                dot += data[i] * v.getEntry(i);
            }
            return dot;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <871, 878>
try {
            return dotProduct((RealVectorImpl) RealVector);
        } catch (ClassCastException cce) {
            checkVectorDimensions(v);
            double dot = 0;
            for (int i = 0; i < data.length; i++) {
                dot += data[i] * v.getEntry(i);
            }
            return dot;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealVectorImpl <883, 890>
throws IllegalArgumentException {
checkVectorDimensions(v.length);
double dot = 0;
for (int i = 0; i < data.length; i++) {
            dot += data[i] * v[i];
        }
return dot;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <883, 890>
throws IllegalArgumentException {
checkVectorDimensions(double[]Var.length);
double doubleVar = 0;
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            doubleVar += doubleVar[intVar] * double[]Var[intVar];
        }
return doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <883, 890>
throws IllegalArgumentException {
checkVectorDimensions(v.length);
double dot = 0;
for (int i = 0; i < data.length; i++) {
            dot += data[i] * v[i];
        }
return dot;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.SingularValueDecompositionImpl <345, 352>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
                final double si = double[]Var[intVar];
                if (si == 0) {
                    throw new SingularMatrixException();
                }
                double[]Var[intVar] /= si;
            }
return RealMatrix.operate(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.SingularValueDecompositionImpl <345, 352>
for (int i = 0; i < singularValues.length; ++i) {
                final double si = singularValues[i];
                if (si == 0) {
                    throw new SingularMatrixException();
                }
                w[i] /= si;
            }
return RealMatrix.operate(w);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <236, 239>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
                double[]Var[intVar] = doubleVar[intVar] + RealVector.getEntry(intVar);
            }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <236, 239>
for (int i = 0; i < data.length; i++) {
                out[i] = data[i] + RealVector.getEntry(i);
            }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <273, 276>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
                double[]Var[intVar] = doubleVar[intVar] - RealVector.getEntry(intVar);
            }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <273, 276>
for (int i = 0; i < data.length; i++) {
                out[i] = data[i] - RealVector.getEntry(i);
            }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <786, 789>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
                double[]Var[intVar] = doubleVar[intVar] * RealVector.getEntry(intVar);
            }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <786, 789>
for (int i = 0; i < data.length; i++) {
                out[i] = data[i] * RealVector.getEntry(i);
            }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <823, 826>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
                double[]Var[intVar] = doubleVar[intVar] / RealVector.getEntry(intVar);
            }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <823, 826>
for (int i = 0; i < data.length; i++) {
                out[i] = data[i] / RealVector.getEntry(i);
            }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <248, 251>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = doubleVar[intVar] + double[]Var[intVar];
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <248, 251>
for (int i = 0; i < data.length; i++) {
            out[i] = data[i] + v[i];
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <285, 288>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = doubleVar[intVar] - double[]Var[intVar];
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <285, 288>
for (int i = 0; i < data.length; i++) {
            out[i] = data[i] - v[i];
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <798, 801>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = doubleVar[intVar] * double[]Var[intVar];
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <798, 801>
for (int i = 0; i < data.length; i++) {
            out[i] = data[i] * v[i];
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <835, 838>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
                double[]Var[intVar] = doubleVar[intVar] / double[]Var[intVar];
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <835, 838>
for (int i = 0; i < data.length; i++) {
                out[i] = data[i] / v[i];
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.SingularValueDecompositionImpl <372, 379>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
                final double si = double[]Var[intVar];
                if (si == 0) {
                    throw new SingularMatrixException();
                }
                RealVector.set(intVar, RealVector.getEntry(intVar) / si);
            }
return RealMatrix.operate(RealVector);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.SingularValueDecompositionImpl <372, 379>
for (int i = 0; i < singularValues.length; ++i) {
                final double si = singularValues[i];
                if (si == 0) {
                    throw new SingularMatrixException();
                }
                RealVector.set(i, RealVector.getEntry(i) / si);
            }
return RealMatrix.operate(RealVector);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealVectorImpl <935, 943>
try {
            return getDistance((RealVectorImpl) v);
        } catch (ClassCastException cce) {
            checkVectorDimensions(v);
            double sum = 0;
            for (int i = 0; i < data.length; ++i) {
                final double delta = data[i] - v.getEntry(i); 
                sum += delta * delta;
            }
            return Math.sqrt(sum);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <935, 943>
try {
            return getDistance((RealVectorImpl) RealVector);
        } catch (ClassCastException cce) {
            checkVectorDimensions(v);
            double sum = 0;
            for (int i = 0; i < data.length; ++i) {
                final double delta = data[i] - v.getEntry(i); 
                sum += delta * delta;
            }
            return Math.sqrt(sum);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealVectorImpl <948, 956>
throws IllegalArgumentException {
checkVectorDimensions(v.length);
double sum = 0;
for (int i = 0; i < data.length; ++i) {
            final double delta = data[i] - v[i];
            sum += delta * delta;
        }
return Math.sqrt(sum);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <948, 956>
throws IllegalArgumentException {
checkVectorDimensions(double[]Var.length);
double doubleVar = 0;
for (int intVar = 0; intVar < doubleVar.length; ++intVar) {
            final double delta = doubleVar[intVar] - double[]Var[intVar];
            doubleVar += delta * delta;
        }
return Math.sqrt(doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <948, 956>
throws IllegalArgumentException {
checkVectorDimensions(v.length);
double sum = 0;
for (int i = 0; i < data.length; ++i) {
            final double delta = data[i] - v[i];
            sum += delta * delta;
        }
return Math.sqrt(sum);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <1117, 1122>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
                for (int j = 0; j < doubleVar.length; j++) {
                    RealMatrix.setEntry(intVar, j, doubleVar[intVar] * RealVector.getEntry(j));
                }
            }
return RealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <1117, 1122>
for (int i = 0; i < data.length; i++) {
                for (int j = 0; j < data.length; j++) {
                    RealMatrix.setEntry(i, j, data[i] * RealVector.getEntry(j));
                }
            }
return RealMatrix;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <1143, 1148>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            for (int j = 0; j < doubleVar.length; j++) {
                RealMatrix.setEntry(intVar, j, doubleVar[intVar] * double[]Var[j]);
            }
        }
return RealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <1143, 1148>
for (int i = 0; i < data.length; i++) {
            for (int j = 0; j < data.length; j++) {
                RealMatrix.setEntry(i, j, data[i] * v[j]);
            }
        }
return RealMatrix;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <722, 730>
for (int row = 0; row < nRows; ++row) {
            double sum = 0;
            for (int i = 0; i < nCols; ++i) {
                sum += getEntry(row, i) * v[i];
            }
            out[row] = sum;
        }
empty line
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <722, 730>
for (int intVar = 0; intVar < intVar; ++intVar) {
            double sum = 0;
            for (int i = 0; i < intVar; ++i) {
                sum += getEntry(intVar, i) * double[]Var[i];
            }
            double[]Var[intVar] = sum;
        }
empty line
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <722, 730>
for (int row = 0; row < nRows; ++row) {
            double sum = 0;
            for (int i = 0; i < nCols; ++i) {
                sum += getEntry(row, i) * v[i];
            }
            out[row] = sum;
        }
empty line
return out;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <778, 786>
for (int col = 0; col < nCols; ++col) {
            double sum = 0;
            for (int i = 0; i < nRows; ++i) {
                sum += getEntry(i, col) * v[i];
            }
            out[col] = sum;
        }
empty line
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <778, 786>
for (int intVar = 0; intVar < intVar; ++intVar) {
            double sum = 0;
            for (int i = 0; i < intVar; ++i) {
                sum += getEntry(i, intVar) * double[]Var[i];
            }
            double[]Var[intVar] = sum;
        }
empty line
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <778, 786>
for (int col = 0; col < nCols; ++col) {
            double sum = 0;
            for (int i = 0; i < nRows; ++i) {
                sum += getEntry(i, col) * v[i];
            }
            out[col] = sum;
        }
empty line
return out;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <751, 759>
for (int row = 0; row < nRows; ++row) {
                double sum = 0;
                for (int i = 0; i < nCols; ++i) {
                    sum += getEntry(row, i) * v.getEntry(i);
                }
                out[row] = sum;
            }
empty line
return new RealVectorImpl(out, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <751, 759>
for (int intVar = 0; intVar < intVar; ++intVar) {
                double sum = 0;
                for (int i = 0; i < intVar; ++i) {
                    sum += getEntry(intVar, i) * RealVector.getEntry(i);
                }
                double[]Var[intVar] = sum;
            }
empty line
return new RealVectorImpl(double[]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <751, 759>
for (int row = 0; row < nRows; ++row) {
                double sum = 0;
                for (int i = 0; i < nCols; ++i) {
                    sum += getEntry(row, i) * RealVector.getEntry(i);
                }
                out[row] = sum;
            }
empty line
return new RealVectorImpl(out, false);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SingularValueDecompositionImpl <399, 409>
for (int i = 0; i < singularValues.length; ++i) {
                final double si  = singularValues[i];
                if (si == 0) {
                    throw new SingularMatrixException();
                }
                final double inv = 1.0 / si;
                for (int j = 0; j < b.getColumnDimension(); ++j) {
                    w.multiplyEntry(i, j, inv);
                }
            }
return v.multiply(w);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.SingularValueDecompositionImpl <399, 409>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
                final double si  = double[]Var[intVar];
                if (si == 0) {
                    throw new SingularMatrixException();
                }
                final double inv = 1.0 / si;
                for (int j = 0; j < RealMatrix.getColumnDimension(); ++j) {
                    RealMatrix.multiplyEntry(intVar, j, inv);
                }
            }
return RealMatrix.multiply(RealMatrix);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.SingularValueDecompositionImpl <399, 409>
for (int i = 0; i < singularValues.length; ++i) {
                final double si  = singularValues[i];
                if (si == 0) {
                    throw new SingularMatrixException();
                }
                final double inv = 1.0 / si;
                for (int j = 0; j < RealMatrix.getColumnDimension(); ++j) {
                    RealMatrix.multiplyEntry(i, j, inv);
                }
            }
return RealMatrix.multiply(RealMatrix);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <808, 816>
for (int col = 0; col < nCols; ++col) {
                double sum = 0;
                for (int i = 0; i < nRows; ++i) {
                    sum += getEntry(i, col) * v.getEntry(i);
                }
                out[col] = sum;
            }
empty line
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <808, 816>
for (int intVar = 0; intVar < intVar; ++intVar) {
                double sum = 0;
                for (int i = 0; i < intVar; ++i) {
                    sum += getEntry(i, intVar) * RealVector.getEntry(i);
                }
                double[]Var[intVar] = sum;
            }
empty line
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <808, 816>
for (int col = 0; col < nCols; ++col) {
                double sum = 0;
                for (int i = 0; i < nRows; ++i) {
                    sum += getEntry(i, col) * RealVector.getEntry(i);
                }
                out[col] = sum;
            }
empty line
return new RealVectorImpl(out);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.PolynomialSplineFunction <134, 149>
/**
     * Compute the value for the function.
     * <p>
     * Throws FunctionEvaluationException if v is outside of the domain of the
     * function.  The domain is [smallest knot, largest knot].</p>
     * <p>
     * See {@link PolynomialSplineFunction} for details on the algorithm for
     * computing the value of the function.</p>
     * 
     * @param v the point for which the function value should be computed
     * @return the value
     * @throws ArgumentOutsideDomainException if v is outside of the domain of
     * of the spline function (less than the smallest knot point or greater
     * than the largest knot point)
     */
    public double value(double v) throws ArgumentOutsideDomainException {
        if (v < knots[0] || v > knots[n]) {
            throw new ArgumentOutsideDomainException(v, knots[0], knots[n]);
        }
        int i = Arrays.binarySearch(knots, v);
        if (i < 0) {
            i = -i - 2;
        }
        //This will handle the case where v is the last knot value
        //There are only n-1 polynomials, so if v is the last knot
        //then we will use the last polynomial to calculate the value.
        if ( i >= polynomials.length ) {
            i--;
        }
        return polynomials[i].value(v - knots[i]);
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <450, 458>
for (int col = 0; col < nCols; ++col) {
            double sum = 0;
            for (int i = 0; i < nRows; ++i) {
                sum += data[i][col] * v[i];
            }
            out[col] = sum;
        }
empty line
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <450, 458>
for (int intVar = 0; intVar < intVar; ++intVar) {
            double sum = 0;
            for (int i = 0; i < intVar; ++i) {
                sum += doubleVar[i][intVar] * double[]Var[i];
            }
            double[]Var[intVar] = sum;
        }
empty line
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealMatrixImpl <450, 458>
for (int col = 0; col < nCols; ++col) {
            double sum = 0;
            for (int i = 0; i < nRows; ++i) {
                sum += data[i][col] * v[i];
            }
            out[col] = sum;
        }
empty line
return out;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <424, 432>
for (int row = 0; row < nRows; row++) {
            final double[] dataRow = data[row];
            double sum = 0;
            for (int i = 0; i < nCols; i++) {
                sum += dataRow[i] * v[i];
            }
            out[row] = sum;
        }
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <424, 432>
for (int intVar = 0; intVar < intVar; intVar++) {
            final double[] dataRow = doubleVar[intVar];
            double sum = 0;
            for (int i = 0; i < intVar; i++) {
                sum += dataRow[i] * double[]Var[i];
            }
            double[]Var[intVar] = sum;
        }
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealMatrixImpl <424, 432>
for (int row = 0; row < nRows; row++) {
            final double[] dataRow = data[row];
            double sum = 0;
            for (int i = 0; i < nCols; i++) {
                sum += dataRow[i] * v[i];
            }
            out[row] = sum;
        }
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <1013, 1020>
for (int intVar = 0; intVar < intVar; intVar++) {
            BigDecimal sum = BigDecimal;
            for (int i = 0; i < intVar; i++) {
                sum = sum.add(BigDecimal[intVar][i].multiply(BigDecimal[]Var[i]));
            }
            BigDecimal[]Var[intVar] = sum;
        }
return BigDecimal[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <1013, 1020>
for (int row = 0; row < nRows; row++) {
            BigDecimal sum = BigDecimal;
            for (int i = 0; i < nCols; i++) {
                sum = sum.add(BigDecimal[row][i].multiply(v[i]));
            }
            out[row] = sum;
        }
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <1052, 1059>
for (int intVar = 0; intVar < intVar; intVar++) {
            BigDecimal sum = BigDecimal;
            for (int i = 0; i < intVar; i++) {
                sum = sum.add(BigDecimal[i][intVar].multiply(BigDecimal[]Var[i]));
            }
            BigDecimal[]Var[intVar] = sum;
        }
return BigDecimal[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <1052, 1059>
for (int col = 0; col < nCols; col++) {
            BigDecimal sum = BigDecimal;
            for (int i = 0; i < nRows; i++) {
                sum = sum.add(BigDecimal[i][col].multiply(v[i]));
            }
            out[col] = sum;
        }
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <452, 461>
for (int intVar = 0; intVar < intVar; ++intVar) {
                final RealVectorImpl v = RealVectorImpl[]Var[intVar];
                final double[] vData = v.getDataRef();
                final double s = v.dotProduct(RealVector) / double[]Var[intVar];
                for (int j = 0; j < intVar; ++j) {
                    double[]Var[j] += s * vData[j];
                }
            }
empty line
return new RealVectorImpl(double[]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <452, 461>
for (int i = 0; i < m; ++i) {
                final RealVectorImpl v = eigenvectors[i];
                final double[] vData = v.getDataRef();
                final double s = v.dotProduct(RealVector) / realEigenvalues[i];
                for (int j = 0; j < m; ++j) {
                    bp[j] += s * vData[j];
                }
            }
empty line
return new RealVectorImpl(bp, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <418, 427>
for (int intVar = 0; intVar < intVar; ++intVar) {
                final RealVectorImpl v = RealVectorImpl[]Var[intVar];
                final double[] vData = v.getDataRef();
                final double s = v.dotProduct(double[]Var) / double[]Var[intVar];
                for (int j = 0; j < intVar; ++j) {
                    double[]Var[j] += s * vData[j];
                }
            }
empty line
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <418, 427>
for (int i = 0; i < m; ++i) {
                final RealVectorImpl v = eigenvectors[i];
                final double[] vData = v.getDataRef();
                final double s = v.dotProduct(b) / realEigenvalues[i];
                for (int j = 0; j < m; ++j) {
                    bp[j] += s * vData[j];
                }
            }
empty line
return bp;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <487, 502>
for (int k = 0; k < nColB; ++k) {
                for (int i = 0; i < m; ++i) {
                    final RealVectorImpl v = eigenvectors[i];
                    final double[] vData = v.getDataRef();
                    double s = 0;
                    for (int j = 0; j < m; ++j) {
                        s += v.getEntry(j) * b.getEntry(j, k);
                    }
                    s /= realEigenvalues[i];
                    for (int j = 0; j < m; ++j) {
                        bp[j][k] += s * vData[j];
                    }
                }
            }
empty line
return MatrixUtils.createRealMatrix(bp);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <487, 502>
for (int intVar = 0; intVar < intVar; ++intVar) {
                for (int i = 0; i < intVar; ++i) {
                    final RealVectorImpl v = RealVectorImpl[]Var[i];
                    final double[] vData = v.getDataRef();
                    double s = 0;
                    for (int j = 0; j < intVar; ++j) {
                        s += v.getEntry(j) * RealMatrix.getEntry(j, intVar);
                    }
                    s /= double[]Var[i];
                    for (int j = 0; j < intVar; ++j) {
                        double[][]Var[j][intVar] += s * vData[j];
                    }
                }
            }
empty line
return MatrixUtils.createRealMatrix(double[][]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <487, 502>
for (int k = 0; k < nColB; ++k) {
                for (int i = 0; i < m; ++i) {
                    final RealVectorImpl v = eigenvectors[i];
                    final double[] vData = v.getDataRef();
                    double s = 0;
                    for (int j = 0; j < m; ++j) {
                        s += v.getEntry(j) * RealMatrix.getEntry(j, k);
                    }
                    s /= realEigenvalues[i];
                    for (int j = 0; j < m; ++j) {
                        bp[j][k] += s * vData[j];
                    }
                }
            }
empty line
return MatrixUtils.createRealMatrix(bp);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.Fraction <480, 482>
if (numerator == 0 || fraction.numerator == 0) {
            return ZERO;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.fraction.Fraction <480, 482>
if (intVar == 0 || Number.intVar == 0) {
            return Number;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Variance <163, 173>
if (moment.n == 0) {
                return Double.NaN;
            } else if (moment.n == 1) {
                return 0d;
            } else {
                if (isBiasCorrected) {
                    return moment.m2 / ((double) moment.n - 1d);
                } else {
                    return moment.m2 / ((double) moment.n);
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.Fraction <208, 215>
if (den < 0) {
            if (num == Integer.MIN_VALUE || den == Integer.MIN_VALUE) {
                throw MathRuntimeException.createArithmeticException("overflow in fraction {0}/{1}, cannot negate",
                                                                     new Object[] { num, den});
            }
            num = -num;
            den = -den;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.fraction.Fraction <208, 215>
if (intVar < 0) {
            if (intVar == Integer.MIN_VALUE || intVar == Integer.MIN_VALUE) {
                throw MathRuntimeException.createArithmeticException("overflow in fraction {0}/{1}, cannot negate",
                                                                     new Object[] { intVar, intVar});
            }
            intVar = -intVar;
            intVar = -intVar;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.Fraction <536, 544>
if (denominator < 0) {
            if (numerator==Integer.MIN_VALUE ||
                    denominator==Integer.MIN_VALUE) {
                throw MathRuntimeException.createArithmeticException("overflow in fraction {0}/{1}, cannot negate",
                                                                     new Object[] { numerator, denominator});
            }
            numerator = -numerator;
            denominator = -denominator;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.fraction.Fraction <536, 544>
if (intVar < 0) {
            if (intVar==Integer.MIN_VALUE ||
                    intVar==Integer.MIN_VALUE) {
                throw MathRuntimeException.createArithmeticException("overflow in fraction {0}/{1}, cannot negate",
                                                                     new Object[] { intVar, intVar});
            }
            intVar = -intVar;
            intVar = -intVar;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.rank.Percentile <200, 202>
if (intVar == 0) {
            return Double.NaN;
        }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <680, 684>
if (Double.isNaN(d) || Double.isInfinite(d)) {
                return d;
        } else if (d == 0) {
                return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.CompositeFormat <148, 161>
if (startIndex == endIndex) {
            // try parsing special numbers
            final double[] special = {
                Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY
            };
            for (int i = 0; i < special.length; ++i) {
                Number = parseNumber(source, special[i], ParsePosition);
                if (Number != null) {
                    break;
                }
            }
        }
empty line
return Number;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.ResizableDoubleArray <721, 730>
if (intVar > 0) {
            synchronized(this) {
                ResizableDoubleArray.intVar = intVar;
            }
            } else {
            String msg =
                "The initial capacity supplied: " + intVar +
                "must be a positive integer";
            throw new IllegalArgumentException(msg);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <148, 156>
if (intVar < intVar) {
                    if (intVar > 0) {
                        RealMatrix.setEntry(intVar, intVar - 1, double[]Var[intVar - 1]);
                    }
                } else {
                    if (intVar < double[]Var.length - 1) {
                        RealMatrix.setEntry(intVar, intVar + 1, double[]Var[intVar]);
                    }
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.UnivariateRealSolverImpl <299, 301>
double f1 = f.value(lower);
double f2 = f.value(upper);
return ((f1 > 0 && f2 < 0) || (f1 < 0 && f2 > 0));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <700, 706>
if (vector != null && vector.length != dimensionSize.length) {
                throw MathRuntimeException.createIllegalArgumentException("some dimensions don't math: {0} != {1}",
                                                                          new Object[] {
                                                                              vector.length,
                                                                              dimensionSize.length
                                                                          });
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <729, 735>
if (vector != null && vector.length != dimensionSize.length) {
                throw MathRuntimeException.createIllegalArgumentException("some dimensions don't math: {0} != {1}",
                                                                          new Object[] {
                                                                              vector.length,
                                                                              dimensionSize.length
                                                                          });
            }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.ResizableDoubleArray <455, 466>
if (intVar > intVar) {
            String msg = "Cannot discard more elements than are" +
            "contained in this array.";
            throw new IllegalArgumentException(msg);
        } else if (intVar < 0) {
            String msg = "Cannot discard a negative number of elements.";
            throw new IllegalArgumentException(msg);
        } else {
            // "Subtract" this number of discarded from numElements 
            intVar -= intVar;
            if (booleanVar) intVar += intVar;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <632, 634>
if (doubleVar != 0) {
        Arrays.fill(double[]Var, intVar + 1, double[]Var.length, 0);
      }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.TriDiagonalTransformer <150, 167>
if (RealMatrix == null) {

            final int m = main.length;
            RealMatrix = MatrixUtils.createRealMatrix(m, m);
            for (int i = 0; i < m; ++i) {
                RealMatrix.setEntry(i, i, main[i]);
                if (i > 0) {
                    RealMatrix.setEntry(i, i - 1, secondary[i - 1]);
                }
                if (i < main.length - 1) {
                    RealMatrix.setEntry(i, i + 1, secondary[i]);
                }
            }

        }
empty line
// return the cached matrix
return RealMatrix;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.PolynomialFunctionLagrangeForm <255, 265>
if (d == 0.0) {
                // This happens only when two abscissas are identical.
                for (int k = 0; k < n; ++k) {
                    if ((i != k) && (x[i] == x[k])) {
                        throw MathRuntimeException.createArithmeticException("identical abscissas x[{0}] == x[{1}] == {2} cause division by zero",
                                                                             new Object[] {
                                                                                 i, k, x[i]
                                                                             });
                    }
                }
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.PolynomialFunctionLagrangeForm <255, 265>
if (d == 0.0) {
                // This happens only when two abscissas are identical.
                for (int k = 0; k < n; ++k) {
                    if ((i != k) && (x[i] == x[k])) {
                        throw MathRuntimeException.createArithmeticException("identical abscissas x[{0}] == x[{1}] == {2} cause division by zero",
                                                                             new Object[] {
                                                                                 i, k, x[i]
                                                                             });
                    }
                }
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <690, 692>
if ((double[]Var[intVar] == 0) && (intVar == intVar)) {
        intVar = intVar;
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <323, 330>
if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    new Object[] {
                        destination.length, destination[0].length,
                        rowsCount, columnsCount
                    });
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <323, 330>
if ((double[][]Var.length < intVar) || (destination[0].length < intVar)) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    new Object[] {
                        double[][]Var.length, destination[0].length,
                        intVar, intVar
                    });
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.Fraction <136, 138>
if (a0 > overflow) {
            throw new FractionConversionException(value, a0, 1l);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1619, 1621>
if (dMin1 == dN1) {
                    tau = 0.5 * dMin1;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.geometry.Rotation <540, 545>
if (squaredSine == 0) {
      return new Vector3D(1, 0, 0);
    } else if (q0 < 0) {
      double inverse = 1 / Math.sqrt(squaredSine);
      return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <357, 361>
if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
            tmp = 0.1;
          }
delta = tmp * Math.min(delta, 10.0 * lmNorm);
lmPar /= tmp;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.HypergeometricDistributionImpl <194, 200>
if(intVar < int[]Var[0] || intVar > int[]Var[1]){
            doubleVar = 0.0;
        } else {
            doubleVar = probability(intVar, intVar, intVar, intVar);
        }
empty line
return doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.LUDecompositionImpl <215, 224>
if (singular) {
            return 0;
        } else {
            final int m = pivot.length;
            double determinant = even ? 1 : -1;
            for (int i = 0; i < m; i++) {
                determinant *= lu[i][i];
            }
            return determinant;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.LUDecompositionImpl <215, 224>
if (singular) {
            return 0;
        } else {
            final int m = pivot.length;
            double determinant = even ? 1 : -1;
            for (int i = 0; i < m; i++) {
                determinant *= lu[i][i];
            }
            return determinant;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <97, 99>
final int intVar    = (intVar >= intVar) ? 0 : 1;
final double[] double[]Var = (intVar >= intVar) ? double[]Var : double[]Var;
RealMatrix = MatrixUtils.createRealMatrix(intVar, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <97, 99>
final int diagOffset    = (m >= n) ? 0 : 1;
final double[] diagonal = (m >= n) ? main : secondary;
RealMatrix = MatrixUtils.createRealMatrix(m, m);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <178, 180>
final int intVar    = (intVar >= intVar) ? 1 : 0;
final double[] double[]Var = (intVar >= intVar) ? double[]Var : double[]Var;
RealMatrix = MatrixUtils.createRealMatrix(intVar, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BiDiagonalTransformer <178, 180>
final int diagOffset    = (m >= n) ? 1 : 0;
final double[] diagonal = (m >= n) ? secondary : main;
RealMatrix = MatrixUtils.createRealMatrix(n, n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <131, 137>
for (int r = 1; r < nRows; r++) {
                if (d[r].length != nCols) {
                    throw MathRuntimeException.createIllegalArgumentException("some rows have length {0} while" +
                                                                              " others have length {1}",
                                                                              new Object[] { nCols, d[r].length });
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <449, 463>
if (performTest && (j <= maxChecks) && (k < maxIter)) {
        double initialNorm = 0.0;
        for (int l = 0; l < y0.length; ++l) {
          final double ratio = f[0][l] / scale[l];
          initialNorm += ratio * ratio;
        }
        double deltaNorm = 0.0;
        for (int l = 0; l < y0.length; ++l) {
          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];
          deltaNorm += ratio * ratio;
        }
        if (deltaNorm > 4 * Math.max(1.0e-15, initialNorm)) {
          return false;
        }
      }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <449, 463>
if (booleanVar && (intVar <= intVar) && (intVar < intVar)) {
        double initialNorm = 0.0;
        for (int l = 0; l < double[]Var.length; ++l) {
          final double ratio = double[][]Var[0][l] / double[]Var[l];
          initialNorm += ratio * ratio;
        }
        double deltaNorm = 0.0;
        for (int l = 0; l < double[]Var.length; ++l) {
          final double ratio = (double[][]Var[intVar+1][l] - double[][]Var[0][l]) / double[]Var[l];
          deltaNorm += ratio * ratio;
        }
        if (deltaNorm > 4 * Math.max(1.0e-15, initialNorm)) {
          return false;
        }
      }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <449, 463>
if (performTest && (j <= maxChecks) && (k < maxIter)) {
        double initialNorm = 0.0;
        for (int l = 0; l < y0.length; ++l) {
          final double ratio = f[0][l] / scale[l];
          initialNorm += ratio * ratio;
        }
        double deltaNorm = 0.0;
        for (int l = 0; l < y0.length; ++l) {
          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];
          deltaNorm += ratio * ratio;
        }
        if (deltaNorm > 4 * Math.max(1.0e-15, initialNorm)) {
          return false;
        }
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <88, 100>
if (n > 1) {
            double c = 1.0 / (n * (isBiasCorrected ? (n - 1) : n));
            int k = 0;
            for (int i = 0; i < dimension; ++i) {
                for (int j = 0; j <= i; ++j) {
                    double e = c * (n * productsSums[k++] - sums[i] * sums[j]);
                    result.setEntry(i, j, e);
                    result.setEntry(j, i, e);
                }
            }
        }
empty line
return result;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <88, 100>
if (n > 1) {
            double c = 1.0 / (n * (isBiasCorrected ? (n - 1) : n));
            int k = 0;
            for (int i = 0; i < dimension; ++i) {
                for (int j = 0; j <= i; ++j) {
                    double e = c * (n * productsSums[k++] - sums[i] * sums[j]);
                    RealMatrix.setEntry(i, j, e);
                    RealMatrix.setEntry(j, i, e);
                }
            }
        }
empty line
return RealMatrix;

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <179, 181>
if ((intVar == intVar) || (intVar == 0)) {
            return 1;
        }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <247, 249>
if ((n == k) || (k == 0)) {
            return 0;
        }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <247, 249>
if ((intVar == intVar) || (intVar == 0)) {
            return 0;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <263, 278>
if (RealMatrix == null) {

            if (eigenvectors == null) {
                findEigenVectors();
            }

            final int m = eigenvectors.length;
            RealMatrix = MatrixUtils.createRealMatrix(m, m);
            for (int k = 0; k < m; ++k) {
                RealMatrix.setColumnVector(k, eigenvectors[k]);
            }

        }
empty line
// return the cached matrix
return RealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <296, 311>
if (RealMatrix == null) {

            if (eigenvectors == null) {
                findEigenVectors();
            }

            final int m = eigenvectors.length;
            RealMatrix = MatrixUtils.createRealMatrix(m, m);
            for (int k = 0; k < m; ++k) {
                RealMatrix.setRowVector(k, eigenvectors[k]);
            }

        }
empty line
// return the cached matrix
return RealMatrix;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Kurtosis <105, 117>
if (moment.getN() > 3) {
            double variance = moment.m2 / (double) (moment.n - 1);
                if (moment.n <= 3 || variance < 10E-20) {
                    kurtosis = 0.0;
                } else {
                    double n = (double) moment.n;
                    kurtosis =
                        (n * (n + 1) * moment.m4 -
                                3 * moment.m2 * moment.m2 * (n - 1)) /
                                ((n - 1) * (n -2) * (n -3) * variance * variance);
                }
        }
return kurtosis;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.summary.SumOfLogs <87, 91>
if (intVar > 0) {
            return doubleVar;
        } else {
            return Double.NaN;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.ZipfDistributionImpl <177, 180>
for (int k = n; k > 0; --k) {
            value += 1.0 / Math.pow(k, m);
        }
return value;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.ZipfDistributionImpl <177, 180>
for (int intVar = intVar; intVar > 0; --intVar) {
            doubleVar += 1.0 / Math.pow(intVar, doubleVar);
        }
return doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.distribution.ZipfDistributionImpl <177, 180>
for (int k = n; k > 0; --k) {
            value += 1.0 / Math.pow(k, m);
        }
return value;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.LUDecompositionImpl <197, 204>
if ((RealMatrix == null) && !singular) {
            final int m = pivot.length;
            RealMatrix = MatrixUtils.createRealMatrix(m, m);
            for (int i = 0; i < m; ++i) {
                RealMatrix.setEntry(i, pivot[i], 1.0);
            }
        }
return RealMatrix;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.Fraction <506, 509>
if (fraction.numerator == 0) {
            throw MathRuntimeException.createArithmeticException("the fraction to divide by must not be zero: {0}/{1}",
                                                                 new Object[] { fraction.numerator, fraction.denominator });
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.fraction.Fraction <506, 509>
if (Number.intVar == 0) {
            throw MathRuntimeException.createArithmeticException("the fraction to divide by must not be zero: {0}/{1}",
                                                                 new Object[] { Number.intVar, Number.intVar });
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <154, 161>
if ((vecAbsoluteTolerance != null) && (vecAbsoluteTolerance.length != y0.length)) {
          throw new IntegratorException("dimensions mismatch: state vector has dimension {0}," +
                                        " absolute tolerance vector has dimension {1}",
                                        new Object[] {
                                          Integer.valueOf(y0.length),
                                          Integer.valueOf(vecAbsoluteTolerance.length)
                                        });
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator <163, 170>
if ((vecRelativeTolerance != null) && (vecRelativeTolerance.length != y0.length)) {
          throw new IntegratorException("dimensions mismatch: state vector has dimension {0}," +
                                        " relative tolerance vector has dimension {1}",
                                        new Object[] {
                                          Integer.valueOf(y0.length),
                                          Integer.valueOf(vecRelativeTolerance.length)
                                        });
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.ZipfDistributionImpl <116, 120>
if (x <= 0 || x > getNumberOfElements()) {
            return 0.0;
        }
empty line
return (1.0 / Math.pow(x, exponent)) / generalizedHarmonic(numberOfElements, exponent);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.ZipfDistributionImpl <116, 120>
if (intVar <= 0 || intVar > getNumberOfElements()) {
            return 0.0;
        }
empty line
return (1.0 / Math.pow(intVar, doubleVar)) / generalizedHarmonic(intVar, doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.QRDecompositionImpl <231, 245>
if (RealMatrix == null) {

            final int n = qrt.length;
            final int m = qrt[0].length;
            RealMatrix = MatrixUtils.createRealMatrix(m, n);
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < Math.min(i + 1, n); ++j) {
                    RealMatrix.setEntry(i, j, qrt[j][i] / -rDiag[j]);
                }
            }

        }
empty line
// return the cached matrix
return RealMatrix;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.MatrixUtils <74, 77>
for (int intVar = 0; intVar < intVar; ++intVar) {
            RealMatrix.setEntry(intVar, intVar, 1.0);
        }
return RealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.MatrixUtils <74, 77>
for (int i = 0; i < dimension; ++i) {
            RealMatrix.setEntry(i, i, 1.0);
        }
return RealMatrix;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1455, 1468>
if (gap1 > 0.0 && gap1 > b1) {
                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);
                        tType = -2;
                    } else {
                        double s = 0.0;
                        if (dN > b1) {
                            s = dN - b1;
                        }
                        if (a2 > (b1 + b2)) {
                            s = Math.min(s, a2 - (b1 + b2));
                        }
                        tau   = Math.max(s, 0.333 * dMin);
                        tType = -3;
                    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <322, 332>
if (denseOutput) {
      // step size sequence: 2, 6, 10, 14, ...
      for (int k = 0; k < size; ++k) {
        sequence[k] = 4 * k + 2;
      }
    } else {
      // step size sequence: 2, 4, 6, 8, ...
      for (int k = 0; k < size; ++k) {
        sequence[k] = 2 * (k + 1); 
      }
    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <322, 332>
if (denseOutput) {
      // step size sequence: 2, 6, 10, 14, ...
      for (int k = 0; k < size; ++k) {
        sequence[k] = 4 * k + 2;
      }
    } else {
      // step size sequence: 2, 4, 6, 8, ...
      for (int k = 0; k < size; ++k) {
        sequence[k] = 2 * (k + 1); 
      }
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <132, 144>
if (maxDegree <= 4) {
        errfac = null;
      } else {
        errfac = new double[maxDegree - 4];
        for (int i = 0; i < errfac.length; ++i) {
          final int ip5 = i + 5;
          errfac[i] = 1.0 / (ip5 * ip5);
          final double e = 0.5 * Math.sqrt (((double) (i + 1)) / ip5);
          for (int j = 0; j <= i; ++j) {
            errfac[i] *= e / (j + 1);
          }
        }
      }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <132, 144>
if (maxDegree <= 4) {
        errfac = null;
      } else {
        errfac = new double[maxDegree - 4];
        for (int i = 0; i < errfac.length; ++i) {
          final int ip5 = i + 5;
          errfac[i] = 1.0 / (ip5 * ip5);
          final double e = 0.5 * Math.sqrt (((double) (i + 1)) / ip5);
          for (int j = 0; j <= i; ++j) {
            errfac[i] *= e / (j + 1);
          }
        }
      }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.ResizableDoubleArray <538, 546>
if (index >= numElements) {
            throw MathRuntimeException.createArrayIndexOutOfBoundsException("the index specified: {0} is larger than the current maximal index {1}",
                                                                            new Object[] { index, numElements - 1 });
        } else if (index >= 0) {
            return internalArray[startIndex + index];
        } else {
            throw MathRuntimeException.createArrayIndexOutOfBoundsException("elements cannot be retrieved from a negative array index {0}",
                                                                            new Object[] { index });
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.ResizableDoubleArray <538, 546>
if (intVar >= intVar) {
            throw MathRuntimeException.createArrayIndexOutOfBoundsException("the index specified: {0} is larger than the current maximal index {1}",
                                                                            new Object[] { intVar, intVar - 1 });
        } else if (intVar >= 0) {
            return double[]Var[intVar + intVar];
        } else {
            throw MathRuntimeException.createArrayIndexOutOfBoundsException("elements cannot be retrieved from a negative array index {0}",
                                                                            new Object[] { intVar });
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <696, 699>
if (vector == null && dimensionSize.length > 1) {
                throw MathRuntimeException.createIllegalArgumentException("some dimensions don't math: {0} != {1}",
                                                                          new Object[] { 0, dimensionSize.length });
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <725, 728>
if (vector == null && dimensionSize.length > 1) {
                throw MathRuntimeException.createIllegalArgumentException("some dimensions don't math: {0} != {1}",
                                                                          new Object[] { 0, dimensionSize.length });
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.PolynomialFunction <118, 121>
for (int intVar = intVar -2; intVar >=0; intVar--) {
            doubleVar = doubleVar * doubleVar + double[]Var[intVar];
        }
return doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.PolynomialFunction <118, 121>
for (int j = n -2; j >=0; j--) {
            result = argument * result + coefficients[j];
        }
return result;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.MullerSolver <98, 98>
if (f.value(min) == 0.0) { return min; }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.MullerSolver <99, 99>
if (f.value(max) == 0.0) { return max; }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.MullerSolver <100, 100>
if (f.value(initial) == 0.0) { return initial; }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.RiddersSolver <96, 96>
if (f.value(min) == 0.0) { return min; }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.RiddersSolver <97, 97>
if (f.value(max) == 0.0) { return max; }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.RiddersSolver <98, 98>
if (f.value(initial) == 0.0) { return initial; }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.LaguerreSolver <122, 122>
if (f.value(min) == 0.0) { return min; }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.LaguerreSolver <123, 123>
if (f.value(max) == 0.0) { return max; }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.LaguerreSolver <124, 124>
if (f.value(initial) == 0.0) { return initial; }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.LaguerreSolver <165, 165>
if (f.value(min) == 0.0) { return min; }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.LaguerreSolver <166, 166>
if (f.value(max) == 0.0) { return max; }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.DirectSearchOptimizer <363, 365>
if (intVar > 0) {
                System.arraycopy(double[]Var, 0, double[]Var, 0, intVar);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.CauchyDistributionImpl <99, 109>
if (p < 0.0 || p > 1.0) {
            throw new IllegalArgumentException
                ("probability argument must be between 0 and 1 (inclusive)");
        } else if (p == 0) {
            ret = Double.NEGATIVE_INFINITY;
        } else  if (p == 1) {
            ret = Double.POSITIVE_INFINITY;
        } else {
            ret = median + scale * Math.tan(Math.PI * (p - .5));
        }
return ret;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.HypergeometricDistributionImpl <272, 280>
if (intVar < int[]Var[0]) {
            doubleVar = 1.0;
        } else if(intVar > int[]Var[1]) {
            doubleVar = 0.0;
        } else {
            doubleVar = innerCumulativeProbability(int[]Var[1], intVar, -1, intVar, intVar, intVar);
        }
empty line
return doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.DenseRealMatrix <740, 757>
if (widthExcess > 0) {
                        // the submatrix block spans on two blocks columns from the original matrix
                        final int width2 = blockWidth(qBlock + 1);
                        copyBlockPart(blocks[index], width,
                                      rowsShift, iHeight + rowsShift,
                                      columnsShift, BLOCK_SIZE,
                                      outBlock, jWidth, 0, 0);
                        copyBlockPart(blocks[index + 1], width2,
                                      rowsShift, iHeight + rowsShift,
                                      0, widthExcess,
                                      outBlock, jWidth, 0, jWidth - widthExcess);
                    } else {
                        // the submatrix block spans on one block column from the original matrix
                        copyBlockPart(blocks[index], width,
                                      rowsShift, iHeight + rowsShift,
                                      columnsShift, jWidth + columnsShift,
                                      outBlock, jWidth, 0, 0);
                    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.DenseRealMatrix <740, 757>
if (intVar > 0) {
                        // the submatrix block spans on two blocks columns from the original matrix
                        final int width2 = blockWidth(intVar + 1);
                        copyBlockPart(doubleVar[intVar], intVar,
                                      intVar, intVar + intVar,
                                      intVar, intVar,
                                      double[]Var, intVar, 0, 0);
                        copyBlockPart(doubleVar[intVar + 1], width2,
                                      intVar, intVar + intVar,
                                      0, intVar,
                                      double[]Var, intVar, 0, intVar - intVar);
                    } else {
                        // the submatrix block spans on one block column from the original matrix
                        copyBlockPart(doubleVar[intVar], intVar,
                                      intVar, intVar + intVar,
                                      intVar, intVar + intVar,
                                      double[]Var, intVar, 0, 0);
                    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.OLSMultipleLinearRegression <104, 115>
for (int i = 0; i < n; i++) {
            for (int j =0; j < n; j++) {
                if (i == j && i < p) {
                    augIData[i][j] = 1d;
                } else {
                    augIData[i][j] = 0d;
                }
            }
        }
empty line
// Compute and return Hat matrix
return Q.multiply(augI).multiply(Q.transpose());

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.OLSMultipleLinearRegression <104, 115>
for (int intVar = 0; intVar < intVar; intVar++) {
            for (int j =0; j < intVar; j++) {
                if (intVar == j && intVar < intVar) {
                    double[][]Var[intVar][j] = 1d;
                } else {
                    double[][]Var[intVar][j] = 0d;
                }
            }
        }
empty line
// Compute and return Hat matrix
return Q.multiply(AbstractRealMatrix).multiply(Q.transpose());

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.OLSMultipleLinearRegression <104, 115>
for (int i = 0; i < n; i++) {
            for (int j =0; j < n; j++) {
                if (i == j && i < p) {
                    augIData[i][j] = 1d;
                } else {
                    augIData[i][j] = 0d;
                }
            }
        }
empty line
// Compute and return Hat matrix
return Q.multiply(null).multiply(Q.transpose());

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <1277, 1291>
if (BigDecimal != null) {
            for (int i = 0; i < BigDecimal.length; i++) {
                if (i > 0) {
                    StringBuffer.append(",");
                }
                StringBuffer.append("{");
                for (int j = 0; j < data[0].length; j++) {
                    if (j > 0) {
                        StringBuffer.append(",");
                    }
                    StringBuffer.append(BigDecimal[i][j]);
                } 
                StringBuffer.append("}");
            } 
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <293, 298>
for (int j = k + 1; j < n; ++j) {
                    final double c = hK[j];
                    xNormSqr += c * c;
                }
final double b = (hK[k + 1] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);
secondary[k] = b;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <293, 298>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                    final double c = double[]Var[intVar];
                    doubleVar += c * c;
                }
final double doubleVar = (double[]Var[intVar + 1] > 0) ? -Math.sqrt(doubleVar) : Math.sqrt(doubleVar);
double[]Var[intVar] = doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.MatrixUtils <182, 185>
for (int intVar = 0; intVar < intVar; ++intVar) {
            RealMatrix.setEntry(0, intVar, double[]Var[intVar]);
        }
return RealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.MatrixUtils <182, 185>
for (int i = 0; i < nCols; ++i) {
            RealMatrix.setEntry(0, i, rowData[i]);
        }
return RealMatrix;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.MatrixUtils <252, 255>
for (int intVar = 0; intVar < intVar; ++intVar) {
            RealMatrix.setEntry(intVar, 0, double[]Var[intVar]);
        }
return RealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.MatrixUtils <252, 255>
for (int i = 0; i < nRows; ++i) {
            RealMatrix.setEntry(i, 0, columnData[i]);
        }
return RealMatrix;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.NormalDistributionImpl <129, 133>
if (x > (mean + 20 * standardDeviation)) {
                return 1.0d;
            } else {
                throw ex;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <243, 262>
if (booleanVar) {

        // scale the variables according to the norms of the columns
        // of the initial jacobian
        doubleVar = 0;
        for (int intVar = 0; intVar < intVar; ++intVar) {
          double dk = double[]Var[intVar];
          if (dk == 0) {
            dk = 1.0;
          }
          double xk = dk * EstimatedParameter[]Var[intVar].getEstimate();
          doubleVar  += xk * xk;
          double[]Var[intVar] = dk;
        }
        doubleVar = Math.sqrt(doubleVar);
        
        // initialize the step bound delta
        doubleVar = (doubleVar == 0) ? doubleVar : (doubleVar * doubleVar);
 
      }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <243, 262>
if (firstIteration) {

        // scale the variables according to the norms of the columns
        // of the initial jacobian
        xNorm = 0;
        for (int k = 0; k < cols; ++k) {
          double dk = jacNorm[k];
          if (dk == 0) {
            dk = 1.0;
          }
          double xk = dk * parameters[k].getEstimate();
          xNorm  += xk * xk;
          diag[k] = dk;
        }
        xNorm = Math.sqrt(xNorm);
        
        // initialize the step bound delta
        delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
 
      }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.PolynomialFunction <141, 144>
for (int intVar = intVar - 1; intVar  > 0; intVar--) {
            double[]Var[intVar - 1] = (double) intVar * double[]Var[intVar];
        }
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.PolynomialFunction <141, 144>
for (int i = n - 1; i  > 0; i--) {
            result[i - 1] = (double) i * coefficients[i];
        }
return result;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <601, 607>
for (int i = startRow; i <= endRow; i++) {
            System.arraycopy(data[i], startColumn,
                             subMatrixData[i - startRow], 0,
                             endColumn - startColumn + 1);
        }
empty line
return new BigMatrixImpl(subMatrixData, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <601, 607>
for (int intVar = intVar; intVar <= intVar; intVar++) {
            System.arraycopy(BigDecimal[intVar], intVar,
                             BigDecimal[][]Var[intVar - intVar], 0,
                             intVar - intVar + 1);
        }
empty line
return new BigMatrixImpl(BigDecimal[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.QRDecompositionImpl <154, 172>
if (RealMatrix == null) {

            // R is supposed to be m x n
            final int n = qrt.length;
            final int m = qrt[0].length;
            RealMatrix = MatrixUtils.createRealMatrix(m, n);

            // copy the diagonal from rDiag and the upper triangle of qr
            for (int row = Math.min(m, n) - 1; row >= 0; row--) {
                RealMatrix.setEntry(row, row, rDiag[row]);
                for (int col = row + 1; col < n; col++) {
                    RealMatrix.setEntry(row, col, qrt[col][row]);
                }
            }

        }
empty line
// return the cached matrix
return RealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.LUDecompositionImpl <164, 175>
if ((RealMatrix == null) && !singular) {
            final int m = pivot.length;
            RealMatrix = MatrixUtils.createRealMatrix(m, m);
            for (int i = 0; i < m; ++i) {
                final double[] luI = lu[i];
                for (int j = 0; j < i; ++j) {
                    RealMatrix.setEntry(i, j, luI[j]);
                }
                RealMatrix.setEntry(i, i, 1.0);
            }
        }
return RealMatrix;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics <331, 333>
if (intVar > 0) {
                StringBuffer.append(StringVar);
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorFormat <215, 217>
if (intVar > 0) {
                StringBuffer.append(StringVar);
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <297, 304>
if (currentDegree >= 5) {
      for (int i = 0; i < currentState.length; ++i) {
        final double e = polynoms[currentDegree][i] / scale[i];
        error += e * e;
      }
      error = Math.sqrt(error / currentState.length) * errfac[currentDegree-5];
    }
return error;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.OLSMultipleLinearRegression <201, 209>
for (int i = 0; i < length; i++) {
            int index = length - 1 - i;
            double sum = 0;
            for (int j = index + 1; j < length; j++) {
                sum += coefficients.getEntry(index, j) * x[j];
            }
            x[index] = (constants.getEntry(index, 0) - sum) / coefficients.getEntry(index, index);
        }
return new RealMatrixImpl(x);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.OLSMultipleLinearRegression <201, 209>
for (int intVar = 0; intVar < intVar; intVar++) {
            int index = intVar - 1 - intVar;
            double sum = 0;
            for (int j = index + 1; j < intVar; j++) {
                sum += RealMatrix.getEntry(index, j) * doubleVar[j];
            }
            doubleVar[index] = (RealMatrix.getEntry(index, 0) - sum) / RealMatrix.getEntry(index, index);
        }
return new RealMatrixImpl(doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.OLSMultipleLinearRegression <201, 209>
for (int i = 0; i < length; i++) {
            int index = length - 1 - i;
            double sum = 0;
            for (int j = index + 1; j < length; j++) {
                sum += RealMatrix.getEntry(index, j) * x[j];
            }
            x[index] = (RealMatrix.getEntry(index, 0) - sum) / RealMatrix.getEntry(index, index);
        }
return new RealMatrixImpl(x);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.special.Gamma <90, 106>
if (Double.isNaN(x) || (x <= 0.0)) {
            ret = Double.NaN;
        } else {
            double g = 607.0 / 128.0;
            
            double sum = 0.0;
            for (int i = lanczos.length - 1; i > 0; --i) {
                sum = sum + (lanczos[i] / (x + i));
            }
            sum = sum + lanczos[0];

            double tmp = x + g + .5;
            ret = ((x + .5) * Math.log(tmp)) - tmp +
                HALF_LOG_2_PI + Math.log(sum / x);
        }
empty line
return ret;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.special.Gamma <90, 106>
if (Double.isNaN(x) || (x <= 0.0)) {
            ret = Double.NaN;
        } else {
            double g = 607.0 / 128.0;
            
            double sum = 0.0;
            for (int i = lanczos.length - 1; i > 0; --i) {
                sum = sum + (lanczos[i] / (x + i));
            }
            sum = sum + lanczos[0];

            double tmp = x + g + .5;
            ret = ((x + .5) * Math.log(tmp)) - tmp +
                HALF_LOG_2_PI + Math.log(sum / x);
        }
empty line
return ret;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <160, 170>
for (int row = 0; row < nRows; ++row) {
            for (int col = 0; col < nCols; ++col) {
                double sum = 0;
                for (int i = 0; i < nSum; ++i) {
                    sum += getEntry(row, i) * m.getEntry(i, col);
                }
                out.setEntry(row, col, sum);
            }
        }
empty line
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <160, 170>
for (int intVar = 0; intVar < intVar; ++intVar) {
            for (int col = 0; col < intVar; ++col) {
                double sum = 0;
                for (int i = 0; i < intVar; ++i) {
                    sum += getEntry(intVar, i) * RealMatrix.getEntry(i, col);
                }
                RealMatrix.setEntry(intVar, col, sum);
            }
        }
empty line
return RealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <160, 170>
for (int row = 0; row < nRows; ++row) {
            for (int col = 0; col < nCols; ++col) {
                double sum = 0;
                for (int i = 0; i < nSum; ++i) {
                    sum += getEntry(row, i) * RealMatrix.getEntry(i, col);
                }
                RealMatrix.setEntry(row, col, sum);
            }
        }
empty line
return RealMatrix;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.Fraction <427, 429>
if (fraction.numerator == 0) {
            return this;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.fraction.Fraction <427, 429>
if (Number.intVar == 0) {
            return this;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.Fraction <529, 531>
if (numerator==0) {
            return ZERO; // normalize zero.
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.fraction.Fraction <529, 531>
if (intVar==0) {
            return Number; // normalize zero.
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <123, 129>
for (int intVar = 0; intVar < intVar; ++intVar) {
            for (int col = 0; col < intVar; ++col) {
                RealMatrix.setEntry(intVar, col, getEntry(intVar, col) + doubleVar);
            }
        }
empty line
return RealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <123, 129>
for (int row = 0; row < rowCount; ++row) {
            for (int col = 0; col < columnCount; ++col) {
                RealMatrix.setEntry(row, col, getEntry(row, col) + d);
            }
        }
empty line
return RealMatrix;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <139, 145>
for (int intVar = 0; intVar < intVar; ++intVar) {
            for (int col = 0; col < intVar; ++col) {
                RealMatrix.setEntry(intVar, col, getEntry(intVar, col) * doubleVar);
            }
        }
empty line
return RealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <139, 145>
for (int row = 0; row < rowCount; ++row) {
            for (int col = 0; col < columnCount; ++col) {
                RealMatrix.setEntry(row, col, getEntry(row, col) * d);
            }
        }
empty line
return RealMatrix;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <299, 312>
if (b != 0.0) {
                    hK[k + 1] -= b;
                    for (int i = k + 1; i < m; ++i) {
                        final double[] hI = householderVectors[i];
                        double beta = 0;
                        for (int j = k + 1; j < n; ++j) {
                            beta -= hI[j] * hK[j];
                        }
                        beta /= b * hK[k + 1];
                        for (int j = k + 1; j < n; ++j) {
                            hI[j] -= beta * hK[j];
                        }
                    }
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1131, 1141>
if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
            // flip array
            for (int i = 0, j = 4 * n - 1; i < j; i += 4, j -= 4) {
                for (int k = 0; k < 4; k += step) {
                    final double tmp = work[i + k];
                    work[i + k] = work[j - k];
                    work[j - k] = tmp;
                }
            }
            return true;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.DenseRealMatrix <811, 816>
if (subRow.length != refLength) {
                throw MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}",
                                                                          new Object[] {
                                                                              refLength, subRow.length
                                                                          }); 
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.DenseRealMatrix <708, 737>
if (widthExcess > 0) {
                        // the submatrix block spans on two blocks columns from the original matrix
                        final int width2 = blockWidth(qBlock + 1);
                        copyBlockPart(blocks[index], width,
                                      rowsShift, BLOCK_SIZE,
                                      columnsShift, BLOCK_SIZE,
                                      outBlock, jWidth, 0, 0);
                        copyBlockPart(blocks[index + 1], width2,
                                      rowsShift, BLOCK_SIZE,
                                      0, widthExcess,
                                      outBlock, jWidth, 0, jWidth - widthExcess);
                        copyBlockPart(blocks[index + blockColumns], width,
                                      0, heightExcess,
                                      columnsShift, BLOCK_SIZE,
                                      outBlock, jWidth, iHeight - heightExcess, 0);
                        copyBlockPart(blocks[index + blockColumns + 1], width2,
                                      0, heightExcess,
                                      0, widthExcess,
                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);
                    } else {
                        // the submatrix block spans on one block column from the original matrix
                        copyBlockPart(blocks[index], width,
                                      rowsShift, BLOCK_SIZE,
                                      columnsShift, jWidth + columnsShift,
                                      outBlock, jWidth, 0, 0);
                        copyBlockPart(blocks[index + blockColumns], width,
                                      0, heightExcess,
                                      columnsShift, jWidth + columnsShift,
                                      outBlock, jWidth, iHeight - heightExcess, 0);
                    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.DenseRealMatrix <708, 737>
if (intVar > 0) {
                        // the submatrix block spans on two blocks columns from the original matrix
                        final int width2 = blockWidth(intVar + 1);
                        copyBlockPart(doubleVar[intVar], intVar,
                                      intVar, intVar,
                                      intVar, intVar,
                                      double[]Var, intVar, 0, 0);
                        copyBlockPart(doubleVar[intVar + 1], width2,
                                      intVar, intVar,
                                      0, intVar,
                                      double[]Var, intVar, 0, intVar - intVar);
                        copyBlockPart(doubleVar[intVar + intVar], intVar,
                                      0, intVar,
                                      intVar, intVar,
                                      double[]Var, intVar, intVar - intVar, 0);
                        copyBlockPart(doubleVar[intVar + intVar + 1], width2,
                                      0, intVar,
                                      0, intVar,
                                      double[]Var, intVar, intVar - intVar, intVar - intVar);
                    } else {
                        // the submatrix block spans on one block column from the original matrix
                        copyBlockPart(doubleVar[intVar], intVar,
                                      intVar, intVar,
                                      intVar, intVar + intVar,
                                      double[]Var, intVar, 0, 0);
                        copyBlockPart(doubleVar[intVar + intVar], intVar,
                                      0, intVar,
                                      intVar, intVar + intVar,
                                      double[]Var, intVar, intVar - intVar, 0);
                    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.HypergeometricDistributionImpl <82, 90>
if (x < domain[0]) {
            ret = 0.0;
        } else if(x >= domain[1]) {
            ret = 1.0;
        } else {
            ret = innerCumulativeProbability(domain[0], x, 1, n, m, k);
        }
empty line
return ret;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.HypergeometricDistributionImpl <82, 90>
if (intVar < int[]Var[0]) {
            doubleVar = 0.0;
        } else if(intVar >= int[]Var[1]) {
            doubleVar = 1.0;
        } else {
            doubleVar = innerCumulativeProbability(int[]Var[0], intVar, 1, intVar, intVar, intVar);
        }
empty line
return doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastHadamardTransformer <175, 198>
for (int j = 1; j < n; j <<= 1) {

            // switch columns
            final double[] yTmp = yCurrent;
            yCurrent  = yPrevious;
            yPrevious = yTmp;

            // iterate from top to bottom (row)
            for (int i = 0; i < halfN; ++i) { 
                // D<sub>top</sub>
                // The top part works with addition
                final int twoI = 2 * i;
                yCurrent[i] = yPrevious[twoI] + yPrevious[twoI + 1];
            }
            for (int i = halfN; i < n; ++i) { 
                // D<sub>bottom</sub>   
                // The bottom part works with subtraction
                final int twoI = 2 * i;
                yCurrent[i] = yPrevious[twoI - n] - yPrevious[twoI - n + 1];
            }
        }
empty line
// return the last computed output vector y
return yCurrent;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastHadamardTransformer <225, 248>
for (int j = 1; j < n; j <<= 1) {

            // switch columns
            final int[] yTmp = yCurrent;
            yCurrent  = yPrevious;
            yPrevious = yTmp;

            // iterate from top to bottom (row)
            for (int i = 0; i < halfN; ++i) { 
                // D<sub>top</sub>
                // The top part works with addition
                final int twoI = 2 * i;
                yCurrent[i] = yPrevious[twoI] + yPrevious[twoI + 1];
            }
            for (int i = halfN; i < n; ++i) { 
                // D<sub>bottom</sub>   
                // The bottom part works with subtraction
                final int twoI = 2 * i;
                yCurrent[i] = yPrevious[twoI - n] - yPrevious[twoI - n + 1];
            }
        }
empty line
// return the last computed output vector y
return yCurrent;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <697, 706>
if (nSing > 0) {
      for (int j = nSing - 1; j >= 0; --j) {
        int pj = permutation[j];
        double sum = 0;
        for (int i = j + 1; i < nSing; ++i) {
          sum += jacobian[i * cols + pj] * work[i];
        }
        work[j] = (work[j] - sum) / lmDiag[j];
      }
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <697, 706>
if (intVar > 0) {
      for (int intVar = intVar - 1; intVar >= 0; --intVar) {
        int pj = int[]Var[intVar];
        double sum = 0;
        for (int i = intVar + 1; i < intVar; ++i) {
          sum += double[]Var[i * intVar + pj] * double[]Var[i];
        }
        double[]Var[intVar] = (double[]Var[intVar] - sum) / double[]Var[intVar];
      }
    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <697, 706>
if (nSing > 0) {
      for (int j = nSing - 1; j >= 0; --j) {
        int pj = permutation[j];
        double sum = 0;
        for (int i = j + 1; i < nSing; ++i) {
          sum += jacobian[i * cols + pj] * work[i];
        }
        work[j] = (work[j] - sum) / lmDiag[j];
      }
    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <119, 128>
if (polynoms != null) {
        System.arraycopy(polynoms, 0, newPols, 0, polynoms.length);
        for (int i = polynoms.length; i < newPols.length; ++i) {
          newPols[i] = new double[currentState.length];
        }
      } else {
        for (int i = 0; i < newPols.length; ++i) {
          newPols[i] = new double[currentState.length];
        }
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealVectorImpl <628, 631>
for (int i = 0; i < data.length; i++) {
            out[i] = 1.0 / data[i];
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <628, 631>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = 1.0 / doubleVar[intVar];
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <628, 631>
for (int i = 0; i < data.length; i++) {
            out[i] = 1.0 / data[i];
        }
return new RealVectorImpl(out);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <211, 222>
if (AbstractStepInterpolator.polynoms == null) {
      polynoms = null;
      currentDegree = -1;
    } else {
      resetTables(AbstractStepInterpolator.currentDegree);
      for (int i = 0; i < polynoms.length; ++i) {
        polynoms[i] = new double[dimension];
        System.arraycopy(AbstractStepInterpolator.polynoms[i], 0,
                         polynoms[i], 0, dimension);
      }
      currentDegree = AbstractStepInterpolator.currentDegree;
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.QRDecompositionImpl <203, 219>
for (int minor = Math.min(m, n)-1; minor >= 0; minor--){
                final double[] qrtMinor = qrt[minor];
                cachedQT.setEntry(minor, minor, 1.0);
                if (qrtMinor[minor] != 0.0) {
                    for (int col = minor; col < m; col++) {
                        double alpha = 0;
                        for (int row = minor; row < m; row++) {
                            alpha -= cachedQT.getEntry(col, row) * qrtMinor[row];
                        }
                        alpha /= rDiag[minor] * qrtMinor[minor];

                        for (int row = minor; row < m; row++) {
                            cachedQT.addToEntry(col, row, -alpha * qrtMinor[row]);
                        }
                    }
                }
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.QRDecompositionImpl <203, 219>
for (int intVar = Math.min(intVar, intVar)-1; intVar >= 0; intVar--){
                final double[] qrtMinor = double[][]Var[intVar];
                RealMatrix.setEntry(intVar, intVar, 1.0);
                if (qrtMinor[intVar] != 0.0) {
                    for (int col = intVar; col < intVar; col++) {
                        double alpha = 0;
                        for (int row = intVar; row < intVar; row++) {
                            alpha -= RealMatrix.getEntry(col, row) * qrtMinor[row];
                        }
                        alpha /= double[]Var[intVar] * qrtMinor[intVar];

                        for (int row = intVar; row < intVar; row++) {
                            RealMatrix.addToEntry(col, row, -alpha * qrtMinor[row]);
                        }
                    }
                }
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.QRDecompositionImpl <203, 219>
for (int minor = Math.min(m, n)-1; minor >= 0; minor--){
                final double[] qrtMinor = qrt[minor];
                RealMatrix.setEntry(minor, minor, 1.0);
                if (qrtMinor[minor] != 0.0) {
                    for (int col = minor; col < m; col++) {
                        double alpha = 0;
                        for (int row = minor; row < m; row++) {
                            alpha -= RealMatrix.getEntry(col, row) * qrtMinor[row];
                        }
                        alpha /= rDiag[minor] * qrtMinor[minor];

                        for (int row = minor; row < m; row++) {
                            RealMatrix.addToEntry(col, row, -alpha * qrtMinor[row]);
                        }
                    }
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <176, 180>
if ((stabilityReduction < 0.0001) || (stabilityReduction > 0.9999)) {
      this.stabilityReduction = 0.5;
    } else {
      this.stabilityReduction = stabilityReduction;
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <367, 371>
if ((mudif <= 0) || (mudif >= 7)) {
      this.mudif = 4;
    } else {
      this.mudif = mudif;
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <367, 371>
if ((intVar <= 0) || (intVar >= 7)) {
      AdaptiveStepsizeIntegrator.intVar = 4;
    } else {
      AdaptiveStepsizeIntegrator.intVar = intVar;
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <474, 477>
for (int intVar = 0; intVar < intVar; intVar++) {
            doubleVar[intVar] = UnivariateRealFunction.value(doubleVar + intVar * doubleVar);
        }
return doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <474, 477>
for (int i = 0; i < n; i++) {
            s[i] = UnivariateRealFunction.value(min + i * h);
        }
return s;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <693, 695>
if (intVar < intVar) {
        double[]Var[intVar] = 0;
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.Fraction <424, 426>
if (numerator == 0) {
            return isAdd ? fraction : fraction.negate();
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.fraction.Fraction <424, 426>
if (intVar == 0) {
            return booleanVar ? Number : Number.negate();
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <434, 438>
for (int i = 0; i < nCols; ++i) {
            out.setEntry(0, i, getEntry(row, i));
        }
empty line
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <434, 438>
for (int intVar = 0; intVar < intVar; ++intVar) {
            RealMatrix.setEntry(0, intVar, getEntry(intVar, intVar));
        }
empty line
return RealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <434, 438>
for (int i = 0; i < nCols; ++i) {
            RealMatrix.setEntry(0, i, getEntry(row, i));
        }
empty line
return RealMatrix;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <470, 474>
for (int i = 0; i < nRows; ++i) {
            out.setEntry(i, 0, getEntry(i, column));
        }
empty line
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <470, 474>
for (int intVar = 0; intVar < intVar; ++intVar) {
            RealMatrix.setEntry(intVar, 0, getEntry(intVar, intVar));
        }
empty line
return RealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <470, 474>
for (int i = 0; i < nRows; ++i) {
            RealMatrix.setEntry(i, 0, getEntry(i, column));
        }
empty line
return RealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <661, 669>
if (chooseLeft) {
                    for (int i = 0; i < n; ++i) {
                        realEigenvalues[begin + i] = lambda + work[4 * i];
                    }
                } else {
                    for (int i = 0; i < n; ++i) {
                        realEigenvalues[begin + i] = lambda - work[4 * i];
                    }                    
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <1340, 1347>
for (int intVar = 0; intVar < intVar; intVar++) {
            final BigDecimal[] dataRow = BigDecimal[intVar];
            for (int col = 0; col < intVar; col++) {
                intVar = intVar * 31 + (11 * (intVar+1) + 17 * (col+1)) * 
                dataRow[col].hashCode();
            }
        }
return intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <1340, 1347>
for (int row = 0; row < nRows; row++) {
            final BigDecimal[] dataRow = BigDecimal[row];
            for (int col = 0; col < nCols; col++) {
                ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * 
                dataRow[col].hashCode();
            }
        }
return ret;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.DenseRealMatrix <1073, 1081>
for (int intVar = 0; intVar < intVar; ++intVar) {
            final int iHeight = blockHeight(intVar);
            final double[] block = doubleVar[intVar * intVar + intVar];
            for (int i = 0; i < iHeight; ++i) {
                double[]Var[intVar++] = block[i * intVar + intVar];
            }
        }
empty line
return new RealVectorImpl(double[]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.DenseRealMatrix <1073, 1081>
for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
            final int iHeight = blockHeight(iBlock);
            final double[] block = blocks[iBlock * blockColumns + jBlock];
            for (int i = 0; i < iHeight; ++i) {
                outData[outIndex++] = block[i * jWidth + jColumn];
            }
        }
empty line
return new RealVectorImpl(outData, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.LUDecompositionImpl <181, 191>
if ((RealMatrix == null) && !singular) {
            final int m = pivot.length;
            RealMatrix = MatrixUtils.createRealMatrix(m, m);
            for (int i = 0; i < m; ++i) {
                final double[] luI = lu[i];
                for (int j = i; j < m; ++j) {
                    RealMatrix.setEntry(i, j, luI[j]);
                }
            }
        }
return RealMatrix;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <325, 329>
if (intVar == 0) {
                throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column",
                                                                          null); 
            }
doubleVar = new double[double[][]Var.length][intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.DenseRealMatrix <956, 968>
for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
            final int iHeight = blockHeight(iBlock);
            final double[] block = blocks[iBlock * blockColumns + jBlock];
            for (int i = 0; i < iHeight; ++i) {
                if (outIndex >= outBlock.length) {
                    outBlock = out.blocks[++outBlockIndex];
                    outIndex = 0;
                }
                outBlock[outIndex++] = block[i * jWidth + jColumn];
            }
        }
empty line
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.DenseRealMatrix <956, 968>
for (int intVar = 0; intVar < intVar; ++intVar) {
            final int iHeight = blockHeight(intVar);
            final double[] block = doubleVar[intVar * intVar + intVar];
            for (int i = 0; i < iHeight; ++i) {
                if (intVar >= double[]Var.length) {
                    double[]Var = AbstractRealMatrix.doubleVar[++intVar];
                    intVar = 0;
                }
                double[]Var[intVar++] = block[i * intVar + intVar];
            }
        }
empty line
return AbstractRealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.DenseRealMatrix <956, 968>
for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
            final int iHeight = blockHeight(iBlock);
            final double[] block = blocks[iBlock * blockColumns + jBlock];
            for (int i = 0; i < iHeight; ++i) {
                if (outIndex >= outBlock.length) {
                    outBlock = AbstractRealMatrix.blocks[++outBlockIndex];
                    outIndex = 0;
                }
                outBlock[outIndex++] = block[i * jWidth + jColumn];
            }
        }
empty line
return null;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <330, 338>
for (int i = 0; i < data.length; ++i) {
                if (subMatrix[i].length != nCols) {
                    throw MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}",
                                                                              new Object[] {
                                                                                  nCols, subMatrix[i].length
                                                                              }); 
                }
                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <330, 338>
for (int intVar = 0; intVar < doubleVar.length; ++intVar) {
                if (subMatrix[i].length != intVar) {
                    throw MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}",
                                                                              new Object[] {
                                                                                  intVar, subMatrix[i].length
                                                                              }); 
                }
                System.arraycopy(double[][]Var[intVar], 0, doubleVar[intVar + intVar], intVar, intVar);
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealMatrixImpl <330, 338>
for (int i = 0; i < data.length; ++i) {
                if (subMatrix[i].length != nCols) {
                    throw MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}",
                                                                              new Object[] {
                                                                                  nCols, subMatrix[i].length
                                                                              }); 
                }
                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <619, 634>
} else {
int[] vector = new int[subVector.length + 1];
System.arraycopy(subVector, 0, vector, 0, subVector.length);
if (subVector.length == d) {
                //value is not important once the recursion is done.
                //then an fft will be applied along the dimension d.
                vector[d] = 0;
                mdfft(mdcm, forward, d, vector);
            } else {
                for (int i = 0; i < dimensionSize[subVector.length]; i++) {
                    vector[subVector.length] = i;
                    //further split along the next dimension
                    mdfft(mdcm, forward, d, vector);
                }
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <619, 634>
} else {
int[] int[]Var = new int[int[]Var.length + 1];
System.arraycopy(int[]Var, 0, int[]Var, 0, int[]Var.length);
if (int[]Var.length == intVar) {
                //value is not important once the recursion is done.
                //then an fft will be applied along the dimension d.
                int[]Var[intVar] = 0;
                mdfft(MultiDimensionalComplexMatrix, booleanVar, intVar, int[]Var);
            } else {
                for (int intVar = 0; intVar < int[]Var[int[]Var.length]; intVar++) {
                    int[]Var[int[]Var.length] = intVar;
                    //further split along the next dimension
                    mdfft(MultiDimensionalComplexMatrix, booleanVar, intVar, int[]Var);
                }
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <619, 634>
} else {
int[] vector = new int[subVector.length + 1];
System.arraycopy(subVector, 0, vector, 0, subVector.length);
if (subVector.length == d) {
                //value is not important once the recursion is done.
                //then an fft will be applied along the dimension d.
                vector[d] = 0;
                mdfft(MultiDimensionalComplexMatrix, forward, d, vector);
            } else {
                for (int i = 0; i < dimensionSize[subVector.length]; i++) {
                    vector[subVector.length] = i;
                    //further split along the next dimension
                    mdfft(MultiDimensionalComplexMatrix, forward, d, vector);
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <515, 518>
if (paru == 0) {
      // 2.2251e-308 is the smallest positive real for IEE754
      paru = 2.2251e-308 / Math.min(delta, 0.1);
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.PolynomialFunctionNewtonForm <164, 168>
for (int intVar = intVar-1; intVar >= 0; intVar--) {
            doubleVar = doubleVar[intVar] + (doubleVar - doubleVar[intVar]) * doubleVar;
        }
empty line
return doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.PolynomialFunctionNewtonForm <164, 168>
for (int i = n-1; i >= 0; i--) {
            value = a[i] + (z - c[i]) * value;
        }
empty line
return value;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.MatrixUtils <322, 327>
for (int intVar = 0; intVar < intVar; intVar++) {
            final BigDecimal[] dRow = BigDecimal[][]Var[intVar];
            Arrays.fill(dRow, BigMatrixImpl.ZERO);
            dRow[intVar] = BigMatrixImpl.ONE;
        }
return new BigMatrixImpl(BigDecimal[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.MatrixUtils <322, 327>
for (int row = 0; row < dimension; row++) {
            final BigDecimal[] dRow = d[row];
            Arrays.fill(dRow, BigMatrixImpl.ZERO);
            dRow[row] = BigMatrixImpl.ONE;
        }
return new BigMatrixImpl(d, false);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <188, 204>
for (int k = p - 1; k >= diagOffset; --k) {
                final double[] hK = householderVectors[k - diagOffset];
                cachedV.setEntry(k, k, 1);
                if (hK[k] != 0.0) {
                    for (int j = k; j < n; ++j) {
                        double beta = 0;
                        for (int i = k; i < n; ++i) {
                            beta -= cachedV.getEntry(i, j) * hK[i];
                        }
                        beta /= diagonal[k - diagOffset] * hK[k];

                        for (int i = k; i < n; ++i) {
                            cachedV.addToEntry(i, j, -beta * hK[i]);
                        }
                    }
                }
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <188, 204>
for (int intVar = intVar - 1; intVar >= intVar; --intVar) {
                final double[] hK = doubleVar[intVar - intVar];
                RealMatrix.setEntry(intVar, intVar, 1);
                if (hK[intVar] != 0.0) {
                    for (int j = intVar; j < intVar; ++j) {
                        double beta = 0;
                        for (int i = intVar; i < intVar; ++i) {
                            beta -= RealMatrix.getEntry(i, j) * hK[i];
                        }
                        beta /= double[]Var[intVar - intVar] * hK[intVar];

                        for (int i = intVar; i < intVar; ++i) {
                            RealMatrix.addToEntry(i, j, -beta * hK[i]);
                        }
                    }
                }
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics <243, 253>
if (getN() < 1) {
            Arrays.fill(stdDev, Double.NaN);
        } else if (getN() < 2) {
            Arrays.fill(stdDev, 0.0);
        } else {
            RealMatrix matrix = VectorialCovariance.getResult();
            for (int i = 0; i < k; ++i) {
                stdDev[i] = Math.sqrt(matrix.getEntry(i, i));
            }
        }
return stdDev;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator <79, 91>
if (AbstractStepInterpolator.currentState != null) {
      final int dimension = currentState.length;

      yDotK = new double[AbstractStepInterpolator.yDotK.length][];
      for (int k = 0; k < AbstractStepInterpolator.yDotK.length; ++k) {
        yDotK[k] = new double[dimension];
        System.arraycopy(AbstractStepInterpolator.yDotK[k], 0,
                         yDotK[k], 0, dimension);
      }

    } else {
      yDotK = null;
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.DenseRealMatrix <268, 280>
for (int intVar = 0, intVar = 0; intVar < intVar; ++intVar) {
            final int pStart  = intVar * intVar;
            final int pEnd    = Math.min(pStart + intVar, intVar);
            final int iHeight = pEnd - pStart;
            for (int jBlock = 0; jBlock < intVar; ++jBlock, ++intVar) {
                final int qStart = jBlock * intVar;
                final int qEnd   = Math.min(qStart + intVar, intVar);
                final int jWidth = qEnd - qStart;
                double[][]Var[intVar] = new double[iHeight * jWidth];
            }
        }
empty line
return double[][]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.DenseRealMatrix <268, 280>
for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
            final int pStart  = iBlock * BLOCK_SIZE;
            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);
            final int iHeight = pEnd - pStart;
            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {
                final int qStart = jBlock * BLOCK_SIZE;
                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);
                final int jWidth = qEnd - qStart;
                blocks[blockIndex] = new double[iHeight * jWidth];
            }
        }
empty line
return blocks;

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.ResizableDoubleArray <369, 373>
if (expansionFactor <= 1.0) {
            String msg =
                "The expansion factor must be a number greater than 1.0";
            throw new IllegalArgumentException(msg);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <928, 934>
} else {
BigDecimal BigDecimal = (intVar == 1) ? BigDecimal : ONE.negate();
for (int intVar = 0; intVar < BigMatrixImpl.getRowDimension(); intVar++) {
                BigDecimal = BigDecimal.multiply(BigDecimal[intVar][intVar]);
            }
return BigDecimal;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <928, 934>
} else {
BigDecimal BigDecimal = (parity == 1) ? BigDecimal : ONE.negate();
for (int i = 0; i < BigMatrixImpl.getRowDimension(); i++) {
                BigDecimal = BigDecimal.multiply(BigDecimal[i][i]);
            }
return BigDecimal;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <88, 94>
for (int intVar = 0; intVar < intVar; ++intVar) {
            for (int col = 0; col < intVar; ++col) {
                RealMatrix.setEntry(intVar, col, getEntry(intVar, col) + RealMatrix.getEntry(intVar, col));
            }  
        }
empty line
return RealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <88, 94>
for (int row = 0; row < rowCount; ++row) {
            for (int col = 0; col < columnCount; ++col) {
                RealMatrix.setEntry(row, col, getEntry(row, col) + RealMatrix.getEntry(row, col));
            }  
        }
empty line
return RealMatrix;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <107, 113>
for (int intVar = 0; intVar < intVar; ++intVar) {
            for (int col = 0; col < intVar; ++col) {
                RealMatrix.setEntry(intVar, col, getEntry(intVar, col) - RealMatrix.getEntry(intVar, col));
            }  
        }
empty line
return RealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <107, 113>
for (int row = 0; row < rowCount; ++row) {
            for (int col = 0; col < columnCount; ++col) {
                RealMatrix.setEntry(row, col, getEntry(row, col) - RealMatrix.getEntry(row, col));
            }  
        }
empty line
return RealMatrix;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <252, 264>
if (long[]Var[intVar] == 0 && long[]Var[intVar] == 0) {
                throw new IllegalArgumentException(
                        "observed counts must not both be zero");
            } else {
                doubleVar = (double) long[]Var[intVar];
                doubleVar = (double) long[]Var[intVar];
                if (booleanVar) { // apply weights
                    doubleVar = doubleVar/doubleVar - doubleVar * doubleVar;
                } else {
                    doubleVar = doubleVar - doubleVar;
                }
                doubleVar += (doubleVar * doubleVar) / (doubleVar + doubleVar);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <222, 229>
if (vecAbsoluteTolerance != null) {
            scale = vecAbsoluteTolerance;
          } else {
            scale = new double[y0.length];
            for (int i = 0; i < scale.length; ++i) {
              scale[i] = scalAbsoluteTolerance;
            }
          }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <222, 229>
if (double[]Var != null) {
            double[]Var = double[]Var;
          } else {
            double[]Var = new double[double[]Var.length];
            for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
              double[]Var[intVar] = doubleVar;
            }
          }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <222, 229>
if (vecAbsoluteTolerance != null) {
            scale = vecAbsoluteTolerance;
          } else {
            scale = new double[y0.length];
            for (int i = 0; i < scale.length; ++i) {
              scale[i] = scalAbsoluteTolerance;
            }
          }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.DenseRealMatrix <666, 671>
for (int intVar = 0; intVar < doubleVar.length; ++intVar) {
            for (final double entry : doubleVar[intVar]) {
                doubleVar += entry * entry;
            }
        }
return Math.sqrt(doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.DenseRealMatrix <666, 671>
for (int blockIndex = 0; blockIndex < blocks.length; ++blockIndex) {
            for (final double entry : blocks[blockIndex]) {
                sum2 += entry * entry;
            }
        }
return Math.sqrt(sum2);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.summary.Sum <117, 123>
if (test(values, begin, length)) {
            sum = 0.0;
            for (int i = begin; i < begin + length; i++) {
                sum += values[i];
            }
        }
return sum;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.summary.Product <117, 123>
if (test(values, begin, length)) {
            product = 1.0;
            for (int i = begin; i < begin + length; i++) {
                product *= values[i];
            }
        }
return product;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.DenseRealMatrix <1532, 1546>
for (int intVar = 0, intVar = 0; intVar < intVar; ++intVar) {
            final int pStart = intVar * intVar;
            final int pEnd   = Math.min(pStart + intVar, intVar);
            for (int jBlock = 0; jBlock < intVar; ++jBlock, ++intVar) {
                final int qStart = jBlock * intVar;
                final int qEnd   = Math.min(qStart + intVar, intVar);
                final double[] block = doubleVar[intVar];
                for (int p = pStart, k = 0; p < pEnd; ++p) {
                    for (int q = qStart; q < qEnd; ++q, ++k) {
                        RealMatrixPreservingVisitor.visit(p, q, block[k]);
                    }
                }
            }
        }
return RealMatrixPreservingVisitor.end();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.DenseRealMatrix <1532, 1546>
for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
            final int pStart = iBlock * BLOCK_SIZE;
            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);
            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {
                final int qStart = jBlock * BLOCK_SIZE;
                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);
                final double[] block = blocks[blockIndex];
                for (int p = pStart, k = 0; p < pEnd; ++p) {
                    for (int q = qStart; q < qEnd; ++q, ++k) {
                        RealMatrixPreservingVisitor.visit(p, q, block[k]);
                    }
                }
            }
        }
return RealMatrixPreservingVisitor.end();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <357, 362>
for (int i = k + 1; i < m; ++i) {
                    final double c = householderVectors[i][k];
                    xNormSqr += c * c;
                }
final double b = (hKp1[k] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);
secondary[k] = b;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <357, 362>
for (int intVar = intVar + 1; intVar < intVar; ++intVar) {
                    final double c = doubleVar[intVar][intVar];
                    doubleVar += c * c;
                }
final double doubleVar = (double[]Var[intVar] > 0) ? -Math.sqrt(doubleVar) : Math.sqrt(doubleVar);
double[]Var[intVar] = doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.RandomDataImpl <613, 616>
for (int intVar = 0; intVar < intVar; intVar++) {
            int[]Var[intVar] = intVar;
        }
return int[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.RandomDataImpl <613, 616>
for (int i = 0; i < n; i++) {
            natural[i] = i;
        }
return natural;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <701, 704>
for (int intVar = 0; intVar < intVar; ++intVar) {
            doubleVar += getEntry(intVar, intVar);
        }
return doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <701, 704>
for (int i = 0; i < nRows; ++i) {
            trace += getEntry(i, i);
        }
return trace;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.BetaDistributionImpl <104, 113>
if (x == 1) {
            if (beta < 1) {
                throw new MathException("Cannot compute beta density at 1 when beta = %.3g", new Double[]{beta});
            }
            return 0;
        } else {
            double logX = Math.log(x);
            double log1mX = Math.log1p(-x);
            return Math.exp((alpha - 1) * logX + (beta - 1) * log1mX - z);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <489, 492>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            doubleVar[intVar] *= doubleVar;
        }
return doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <489, 492>
for (int i = 0; i < f.length; i++) {
            f[i] *= d;
        }
return f;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <363, 377>
if (b != 0.0) {
                    hKp1[k] -= b;
                    for (int j = k + 1; j < n; ++j) {
                        double beta = 0;
                        for (int i = k + 1; i < m; ++i) {
                            final double[] hI = householderVectors[i];
                            beta -= hI[j] * hI[k];
                        }
                        beta /= b * hKp1[k];
                        for (int i = k + 1; i < m; ++i) {
                            final double[] hI = householderVectors[i];
                            hI[j] -= beta * hI[k];
                        }
                    }
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.DenseRealMatrix <297, 301>
for (int intVar = 0; intVar < doubleVar.length; ++intVar) {
            System.arraycopy(doubleVar[intVar], 0, AbstractRealMatrix.doubleVar[intVar], 0, blocks[i].length);
        }
empty line
return AbstractRealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.DenseRealMatrix <297, 301>
for (int i = 0; i < blocks.length; ++i) {
            System.arraycopy(blocks[i], 0, AbstractRealMatrix.blocks[i], 0, blocks[i].length);
        }
empty line
return null;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.PolynomialFunctionLagrangeForm <205, 210>
if (intVar < 0.5*(intVar-intVar+1)) {
                doubleVar += doubleVar[intVar];    // fork down
            } else {
                intVar--;
                doubleVar += doubleVar[intVar];    // fork up
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <185, 192>
for (int intVar = 0; intVar < double[][]Var.length; ++intVar) {
            final double[] dataI = double[][]Var[intVar];
            for (int j = 0; j < dataI.length; ++j) {
                dataI[j] = getEntry(intVar, j);
            }
        }
empty line
return double[][]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <185, 192>
for (int i = 0; i < data.length; ++i) {
            final double[] dataI = data[i];
            for (int j = 0; j < dataI.length; ++j) {
                dataI[j] = getEntry(i, j);
            }
        }
empty line
return data;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.DenseRealMatrix <1156, 1164>
for (int intVar = 0; intVar < intVar; ++intVar) {
            final int iHeight = blockHeight(intVar);
            final double[] block = doubleVar[intVar * intVar + intVar];
            for (int i = 0; i < iHeight; ++i) {
                double[]Var[intVar++] = block[i * intVar + intVar];
            }
        }
empty line
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.DenseRealMatrix <1156, 1164>
for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
            final int iHeight = blockHeight(iBlock);
            final double[] block = blocks[iBlock * blockColumns + jBlock];
            for (int i = 0; i < iHeight; ++i) {
                out[outIndex++] = block[i * jWidth + jColumn];
            }
        }
empty line
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.DenseRealMatrix <1511, 1525>
for (int intVar = 0, intVar = 0; intVar < intVar; ++intVar) {
            final int pStart = intVar * intVar;
            final int pEnd   = Math.min(pStart + intVar, intVar);
            for (int jBlock = 0; jBlock < intVar; ++jBlock, ++intVar) {
                final int qStart = jBlock * intVar;
                final int qEnd   = Math.min(qStart + intVar, intVar);
                final double[] block = doubleVar[intVar];
                for (int p = pStart, k = 0; p < pEnd; ++p) {
                    for (int q = qStart; q < qEnd; ++q, ++k) {
                        block[k] = RealMatrixChangingVisitor.visit(p, q, block[k]);
                    }
                }
            }
        }
return RealMatrixChangingVisitor.end();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.DenseRealMatrix <1511, 1525>
for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
            final int pStart = iBlock * BLOCK_SIZE;
            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);
            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {
                final int qStart = jBlock * BLOCK_SIZE;
                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);
                final double[] block = blocks[blockIndex];
                for (int p = pStart, k = 0; p < pEnd; ++p) {
                    for (int q = qStart; q < qEnd; ++q, ++k) {
                        block[k] = RealMatrixChangingVisitor.visit(p, q, block[k]);
                    }
                }
            }
        }
return RealMatrixChangingVisitor.end();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.DenseRealMatrix <1040, 1047>
for (int intVar = 0; intVar < intVar; ++intVar) {
            final int jWidth     = blockWidth(intVar);
            final double[] block = doubleVar[intVar * intVar + intVar];
            System.arraycopy(block, intVar * jWidth, double[]Var, intVar, jWidth);
            intVar += jWidth;
        }
empty line
return new RealVectorImpl(double[]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.DenseRealMatrix <1040, 1047>
for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
            final int jWidth     = blockWidth(jBlock);
            final double[] block = blocks[iBlock * blockColumns + jBlock];
            System.arraycopy(block, iRow * jWidth, outData, outIndex, jWidth);
            outIndex += jWidth;
        }
empty line
return new RealVectorImpl(outData, false);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1415, 1418>
for (int i = 0; i < nRows; i++) {
            System.arraycopy(data[i], 0, out[i], 0, data[i].length);
        }
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <1415, 1418>
for (int intVar = 0; intVar < intVar; intVar++) {
            System.arraycopy(BigDecimal[intVar], 0, BigDecimal[][]Var[intVar], 0, data[i].length);
        }
return BigDecimal[][]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <1415, 1418>
for (int i = 0; i < nRows; i++) {
            System.arraycopy(BigDecimal[i], 0, out[i], 0, data[i].length);
        }
return out;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <597, 600>
for (int i = 0; i < nRows; i++) {
            System.arraycopy(data[i], 0, out[i], 0, data[i].length);
        }
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <597, 600>
for (int intVar = 0; intVar < intVar; intVar++) {
            System.arraycopy(doubleVar[intVar], 0, double[][]Var[intVar], 0, data[i].length);
        }
return double[][]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealMatrixImpl <597, 600>
for (int i = 0; i < nRows; i++) {
            System.arraycopy(data[i], 0, out[i], 0, data[i].length);
        }
return out;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <274, 286>
for (int row = 0; row < nRows; row++) {
            final double[] dataRow    = data[row];
            final double[] outDataRow = outData[row];
            for (int col = 0; col < nCols; col++) {
                double sum = 0;
                for (int i = 0; i < nSum; i++) {
                    sum += dataRow[i] * m.data[i][col];
                }
                outDataRow[col] = sum;
            }
        }
empty line
return new RealMatrixImpl(outData, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <274, 286>
for (int intVar = 0; intVar < intVar; intVar++) {
            final double[] dataRow    = doubleVar[intVar];
            final double[] outDataRow = double[][]Var[intVar];
            for (int col = 0; col < intVar; col++) {
                double sum = 0;
                for (int i = 0; i < intVar; i++) {
                    sum += dataRow[i] * AbstractRealMatrix.doubleVar[i][col];
                }
                outDataRow[col] = sum;
            }
        }
empty line
return new RealMatrixImpl(double[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealMatrixImpl <274, 286>
for (int row = 0; row < nRows; row++) {
            final double[] dataRow    = data[row];
            final double[] outDataRow = outData[row];
            for (int col = 0; col < nCols; col++) {
                double sum = 0;
                for (int i = 0; i < nSum; i++) {
                    sum += dataRow[i] * AbstractRealMatrix.data[i][col];
                }
                outDataRow[col] = sum;
            }
        }
empty line
return new RealMatrixImpl(outData, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.MatrixUtils <90, 93>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
            RealMatrix.setEntry(intVar, intVar, double[]Var[intVar]);
        }
return RealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.MatrixUtils <90, 93>
for (int i = 0; i < diagonal.length; ++i) {
            RealMatrix.setEntry(i, i, diagonal[i]);
        }
return RealMatrix;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <107, 123>
for (int k = p - 1; k >= diagOffset; --k) {
                final double[] hK = householderVectors[k];
                cachedU.setEntry(k, k, 1);
                if (hK[k - diagOffset] != 0.0) {
                    for (int j = k; j < m; ++j) {
                        double alpha = 0;
                        for (int i = k; i < m; ++i) {
                            alpha -= cachedU.getEntry(i, j) * householderVectors[i][k - diagOffset];
                        }
                        alpha /= diagonal[k - diagOffset] * hK[k - diagOffset];

                        for (int i = k; i < m; ++i) {
                            cachedU.addToEntry(i, j, -alpha * householderVectors[i][k - diagOffset]);
                        }
                    }
                }
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BiDiagonalTransformer <107, 123>
for (int intVar = intVar - 1; intVar >= intVar; --intVar) {
                final double[] hK = doubleVar[intVar];
                RealMatrix.setEntry(intVar, intVar, 1);
                if (hK[intVar - intVar] != 0.0) {
                    for (int j = intVar; j < intVar; ++j) {
                        double alpha = 0;
                        for (int i = intVar; i < intVar; ++i) {
                            alpha -= RealMatrix.getEntry(i, j) * doubleVar[i][intVar - intVar];
                        }
                        alpha /= double[]Var[intVar - intVar] * hK[intVar - intVar];

                        for (int i = intVar; i < intVar; ++i) {
                            RealMatrix.addToEntry(i, j, -alpha * doubleVar[i][intVar - intVar]);
                        }
                    }
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.summary.SumOfSquares <117, 123>
if (test(values, begin, length)) {
            sumSq = 0.0;
            for (int i = begin; i < begin + length; i++) {
                sumSq += values[i] * values[i];
            }
        }
return sumSq;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.geometry.Rotation <554, 558>
if ((q0 < -0.1) || (q0 > 0.1)) {
      return 2 * Math.asin(Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3));
    } else if (q0 < 0) {
      return 2 * Math.acos(-q0);
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <556, 559>
if (lower >= upper) {
            throw MathRuntimeException.createIllegalArgumentException("endpoints do not specify an interval: [{0}, {1}]",
                                                                     new Object[] { lower, upper });
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <556, 559>
if (lower >= upper) {
            throw MathRuntimeException.createIllegalArgumentException("endpoints do not specify an interval: [{0}, {1}]",
                                                                     new Object[] { lower, upper });
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.StatUtils <571, 574>
for (int intVar = 0; intVar < intVar; intVar++) {
            doubleVar += double[]Var[intVar] - double[]Var[intVar];
        }
return doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.StatUtils <571, 574>
for (int i = 0; i < n; i++) {
            result += sample1[i] - sample2[i];
        }
return result;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.RandomDataImpl <542, 546>
for (int intVar = 0; intVar < intVar; intVar++) {
            int[]Var[intVar] = int[]Var[intVar - intVar - 1];
        }
empty line
return int[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.RandomDataImpl <542, 546>
for (int i = 0; i < k; i++) {
            result[i] = index[n - i - 1];
        }
empty line
return result;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <483, 489>
for (int intVar = 0; intVar < intVar; ++intVar) {
            final double[] rowI = doubleVar[intVar];
            for (int j = 0; j < intVar; ++j) {
                RealMatrixPreservingVisitor.visit(intVar, j, rowI[j]);
            }
        }
return RealMatrixPreservingVisitor.end();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealMatrixImpl <483, 489>
for (int i = 0; i < rows; ++i) {
            final double[] rowI = data[i];
            for (int j = 0; j < columns; ++j) {
                RealMatrixPreservingVisitor.visit(i, j, rowI[j]);
            }
        }
return RealMatrixPreservingVisitor.end();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <547, 552>
for (int intVar = 0; intVar < intVar; ++intVar) {
            for (int i = 0; i < intVar; ++i) {
                RealMatrixPreservingVisitor.visit(i, intVar, doubleVar[i][intVar]);
            }
        }
return RealMatrixPreservingVisitor.end();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealMatrixImpl <547, 552>
for (int j = 0; j < columns; ++j) {
            for (int i = 0; i < rows; ++i) {
                RealMatrixPreservingVisitor.visit(i, j, data[i][j]);
            }
        }
return RealMatrixPreservingVisitor.end();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.ContinuousOutputModel <244, 248>
if (locatePoint(time, StepInterpolator) <= 0) {
        index = iMin;
        StepInterpolator.setInterpolatedTime(time);
        return;
      }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.ContinuousOutputModel <249, 253>
if (locatePoint(time, StepInterpolator) >= 0) {
        index = iMax;
        StepInterpolator.setInterpolatedTime(time);
        return;
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <533, 544>
for (int i = 0; i < m; ++i) {
                final double[] invI = invData[i];
                for (int j = 0; j < m; ++j) {
                    double invIJ = 0;
                    for (int k = 0; k < m; ++k) {
                        final double[] vK = eigenvectors[k].getDataRef();
                        invIJ += vK[i] * vK[j] / realEigenvalues[k];
                    }
                    invI[j] = invIJ;
                }
            }
return MatrixUtils.createRealMatrix(invData);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <533, 544>
for (int intVar = 0; intVar < intVar; ++intVar) {
                final double[] invI = double[][]Var[intVar];
                for (int j = 0; j < intVar; ++j) {
                    double invIJ = 0;
                    for (int k = 0; k < intVar; ++k) {
                        final double[] vK = RealVectorImpl[]Var[k].getDataRef();
                        invIJ += vK[intVar] * vK[j] / double[]Var[k];
                    }
                    invI[j] = invIJ;
                }
            }
return MatrixUtils.createRealMatrix(double[][]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <533, 544>
for (int i = 0; i < m; ++i) {
                final double[] invI = invData[i];
                for (int j = 0; j < m; ++j) {
                    double invIJ = 0;
                    for (int k = 0; k < m; ++k) {
                        final double[] vK = eigenvectors[k].getDataRef();
                        invIJ += vK[i] * vK[j] / realEigenvalues[k];
                    }
                    invI[j] = invIJ;
                }
            }
return MatrixUtils.createRealMatrix(invData);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.PoissonDistributionImpl <106, 110>
if (x < 0 || x == Integer.MAX_VALUE) {
            return 0;
        }
return Math.pow(getMean(), x) / 
            MathUtils.factorialDouble(x) * Math.exp(-mean);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.PoissonDistributionImpl <106, 110>
if (intVar < 0 || intVar == Integer.MAX_VALUE) {
            return 0;
        }
return Math.pow(getMean(), intVar) / 
            MathUtils.factorialDouble(intVar) * Math.exp(-doubleVar);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.ExponentialDistributionImpl <119, 128>
if (p < 0.0 || p > 1.0) {
            throw new IllegalArgumentException
                ("probability argument must be between 0 and 1 (inclusive)");
        } else if (p == 1.0) {
            ret = Double.POSITIVE_INFINITY;
        } else {
            ret = -getMean() * Math.log(1.0 - p);
        }
empty line
return ret;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <556, 560>
for (int intVar = 0; intVar < intVar; ++intVar) {
            double[]Var[intVar] = getEntry(intVar, intVar);
        }
empty line
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <556, 560>
for (int i = 0; i < nCols; ++i) {
            out[i] = getEntry(row, i);
        }
empty line
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <590, 594>
for (int intVar = 0; intVar < intVar; ++intVar) {
            double[]Var[intVar] = getEntry(intVar, intVar);
        }
empty line
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <590, 594>
for (int i = 0; i < nRows; ++i) {
            out[i] = getEntry(i, column);
        }
empty line
return out;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <827, 835>
for (int row = 0; row < rows; ++row) {
            for (int column = 0; column < columns; ++column) {
                final double oldValue = getEntry(row, column);
                final double newValue = visitor.visit(row, column, oldValue);
                setEntry(row, column, newValue);
            }
        }
lu = null;
return visitor.end();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <827, 835>
for (int intVar = 0; intVar < intVar; ++intVar) {
            for (int column = 0; column < intVar; ++column) {
                final double oldValue = getEntry(intVar, column);
                final double newValue = RealMatrixChangingVisitor.visit(intVar, column, oldValue);
                setEntry(intVar, column, newValue);
            }
        }
DecompositionSolver = null;
return RealMatrixChangingVisitor.end();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <827, 835>
for (int row = 0; row < rows; ++row) {
            for (int column = 0; column < columns; ++column) {
                final double oldValue = getEntry(row, column);
                final double newValue = RealMatrixChangingVisitor.visit(row, column, oldValue);
                setEntry(row, column, newValue);
            }
        }
DecompositionSolver = null;
return RealMatrixChangingVisitor.end();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <893, 901>
for (int column = 0; column < columns; ++column) {
            for (int row = 0; row < rows; ++row) {
                final double oldValue = getEntry(row, column);
                final double newValue = visitor.visit(row, column, oldValue);
                setEntry(row, column, newValue);
            }
        }
lu = null;
return visitor.end();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <893, 901>
for (int intVar = 0; intVar < intVar; ++intVar) {
            for (int row = 0; row < intVar; ++row) {
                final double oldValue = getEntry(row, intVar);
                final double newValue = RealMatrixChangingVisitor.visit(row, intVar, oldValue);
                setEntry(row, intVar, newValue);
            }
        }
DecompositionSolver = null;
return RealMatrixChangingVisitor.end();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <893, 901>
for (int column = 0; column < columns; ++column) {
            for (int row = 0; row < rows; ++row) {
                final double oldValue = getEntry(row, column);
                final double newValue = RealMatrixChangingVisitor.visit(row, column, oldValue);
                setEntry(row, column, newValue);
            }
        }
DecompositionSolver = null;
return RealMatrixChangingVisitor.end();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SparseRealMatrix <186, 190>
if (value == 0.0) {
            entries.remove(key);
        } else {
            entries.put(key, value);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SparseRealMatrix <201, 205>
if (value == 0.0) {
            entries.remove(key);
        } else {
            entries.put(key, value);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <1101, 1107>
for (int intVar = 0; intVar < intVar; ++intVar) {
            for (int col = 0; col < intVar; ++col) {
               intVar = intVar * 31 + (11 * (intVar+1) + 17 * (col+1)) * 
                   MathUtils.hash(getEntry(intVar, col));
           }
        }
return intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <1101, 1107>
for (int row = 0; row < nRows; ++row) {
            for (int col = 0; col < nCols; ++col) {
               ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * 
                   MathUtils.hash(getEntry(row, col));
           }
        }
return ret;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Mean <150, 164>
if (test(values, begin, length)) {
            Sum sum = new Sum();
            double sampleSize = (double) length;
            
            // Compute initial estimate using definitional formula
            double xbar = sum.evaluate(values, begin, length) / sampleSize;
            
            // Compute correction factor in second pass
            double correction = 0;
            for (int i = begin; i < begin + length; i++) {
                correction += (values[i] - xbar);
            }
            return xbar + (correction/sampleSize);
        }
return Double.NaN;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.summary.SumOfLogs <128, 134>
if (test(values, begin, length)) {
            sumLog = 0.0;
            for (int i = begin; i < begin + length; i++) {
                sumLog += Math.log(values[i]);
            }
        }
return sumLog;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.geometry.Vector3D <298, 304>
if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <305, 308>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = doubleVar[intVar] + doubleVar;
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <305, 308>
for (int i = 0; i < data.length; i++) {
            out[i] = data[i] + d;
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <322, 325>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = doubleVar[intVar] - doubleVar;
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <322, 325>
for (int i = 0; i < data.length; i++) {
            out[i] = data[i] - d;
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <339, 342>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = doubleVar[intVar] * doubleVar;
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <339, 342>
for (int i = 0; i < data.length; i++) {
            out[i] = data[i] * d;
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <356, 359>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = doubleVar[intVar] / doubleVar;
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <356, 359>
for (int i = 0; i < data.length; i++) {
            out[i] = data[i] / d;
        }
return new RealVectorImpl(out);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <844, 849>
for (int row = 0; row < rows; ++row) {
            for (int column = 0; column < columns; ++column) {
                visitor.visit(row, column, getEntry(row, column));
            }
        }
return visitor.end();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <844, 849>
for (int intVar = 0; intVar < intVar; ++intVar) {
            for (int column = 0; column < intVar; ++column) {
                RealMatrixPreservingVisitor.visit(intVar, column, getEntry(intVar, column));
            }
        }
return RealMatrixPreservingVisitor.end();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <844, 849>
for (int row = 0; row < rows; ++row) {
            for (int column = 0; column < columns; ++column) {
                RealMatrixPreservingVisitor.visit(row, column, getEntry(row, column));
            }
        }
return RealMatrixPreservingVisitor.end();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <910, 915>
for (int column = 0; column < columns; ++column) {
            for (int row = 0; row < rows; ++row) {
                visitor.visit(row, column, getEntry(row, column));
            }
        }
return visitor.end();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <910, 915>
for (int intVar = 0; intVar < intVar; ++intVar) {
            for (int row = 0; row < intVar; ++row) {
                RealMatrixPreservingVisitor.visit(row, intVar, getEntry(row, intVar));
            }
        }
return RealMatrixPreservingVisitor.end();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <910, 915>
for (int column = 0; column < columns; ++column) {
            for (int row = 0; row < rows; ++row) {
                RealMatrixPreservingVisitor.visit(row, column, getEntry(row, column));
            }
        }
return RealMatrixPreservingVisitor.end();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.DenseRealMatrix <1106, 1113>
for (int intVar = 0; intVar < intVar; ++intVar) {
            final int jWidth     = blockWidth(intVar);
            final double[] block = doubleVar[intVar * intVar + intVar];
            System.arraycopy(block, intVar * jWidth, double[]Var, intVar, jWidth);
            intVar += jWidth;
        }
empty line
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.DenseRealMatrix <1106, 1113>
for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
            final int jWidth     = blockWidth(jBlock);
            final double[] block = blocks[iBlock * blockColumns + jBlock];
            System.arraycopy(block, iRow * jWidth, out, outIndex, jWidth);
            outIndex += jWidth;
        }
empty line
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.LUDecompositionImpl <395, 410>
for (int intVar = intVar - 1; intVar >= 0; intVar--) {
                final double[] bpCol = double[][]Var[intVar];
                final double luDiag = doubleVar[intVar][intVar];
                for (int j = 0; j < intVar; j++) {
                    bpCol[j] /= luDiag;
                }
                for (int i = 0; i < intVar; i++) {
                    final double[] bpI = double[][]Var[i];
                    final double luICol = doubleVar[i][intVar];
                    for (int j = 0; j < intVar; j++) {
                        bpI[j] -= bpCol[j] * luICol;
                    }
                }
            }
empty line
return new RealMatrixImpl(double[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.LUDecompositionImpl <395, 410>
for (int col = m - 1; col >= 0; col--) {
                final double[] bpCol = bp[col];
                final double luDiag = lu[col][col];
                for (int j = 0; j < nColB; j++) {
                    bpCol[j] /= luDiag;
                }
                for (int i = 0; i < col; i++) {
                    final double[] bpI = bp[i];
                    final double luICol = lu[i][col];
                    for (int j = 0; j < nColB; j++) {
                        bpI[j] -= bpCol[j] * luICol;
                    }
                }
            }
empty line
return new RealMatrixImpl(bp, false);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealVectorImpl <1195, 1201>
try {
            System.arraycopy(data, index, out.data, 0, n);
        } catch (IndexOutOfBoundsException e) {
            checkIndex(index);
            checkIndex(index + n - 1);
        }
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <1195, 1201>
try {
            System.arraycopy(doubleVar, intVar, RealVectorImpl.doubleVar, 0, intVar);
        } catch (IndexOutOfBoundsException e) {
            checkIndex(index);
            checkIndex(index + n - 1);
        }
return RealVectorImpl;

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.ContinuedFraction <146, 160>
if (Double.isInfinite(p2) || Double.isInfinite(q2)) {
                // need to scale
                if (a != 0.0) {
                    p2 = p1 + (b / a * p0);
                    q2 = q1 + (b / a * q0);
                } else if (b != 0) {
                    p2 = (a / b * p1) + p0;
                    q2 = (a / b * q1) + q0;
                } else {
                    // can not scale an convergent is unbounded.
                    throw new ConvergenceException(
                        "Continued fraction convergents diverged to +/- infinity for value {0}",
                        new Object[] { Double.valueOf(x) });
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Skewness <105, 111>
if (variance < 10E-20) {
            return 0.0d;
        } else {
            double n0 = (double) moment.getN();
            return  (n0 * moment.m3) /
            ((n0 - 1) * (n0 -2) * Math.sqrt(variance) * variance);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.QRDecompositionImpl <110, 147>
if (a != 0.0) {

                /*
                 * Calculate the normalized reflection vector v and transform
                 * the first column. We know the norm of v beforehand: v = x-ae
                 * so |v|^2 = <x-ae,x-ae> = <x,x>-2a<x,e>+a^2<e,e> =
                 * a^2+a^2-2a<x,e> = 2a*(a - <x,e>).
                 * Here <x, e> is now qr[minor][minor].
                 * v = x-ae is stored in the column at qr:
                 */
                qrtMinor[minor] -= a; // now |v|^2 = -2a*(qr[minor][minor])

                /*
                 * Transform the rest of the columns of the minor:
                 * They will be transformed by the matrix H = I-2vv'/|v|^2.
                 * If x is a column vector of the minor, then
                 * Hx = (I-2vv'/|v|^2)x = x-2vv'x/|v|^2 = x - 2<x,v>/|v|^2 v.
                 * Therefore the transformation is easily calculated by
                 * subtracting the column vector (2<x,v>/|v|^2)v from x.
                 *
                 * Let 2<x,v>/|v|^2 = alpha. From above we have
                 * |v|^2 = -2a*(qr[minor][minor]), so
                 * alpha = -<x,v>/(a*qr[minor][minor])
                 */
                for (int col = minor+1; col < n; col++) {
                    final double[] qrtCol = qrt[col];
                    double alpha = 0;
                    for (int row = minor; row < m; row++) {
                        alpha -= qrtCol[row] * qrtMinor[row];
                    }
                    alpha /= a * qrtMinor[minor];

                    // Subtract the column vector alpha*v from x.
                    for (int row = minor; row < m; row++) {
                        qrtCol[row] -= alpha * qrtMinor[row];
                    }
                }
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.DenseRealMatrix <452, 460>
for (int intVar = 0; intVar < AbstractRealMatrix.doubleVar.length; ++intVar) {
            final double[] outBlock = AbstractRealMatrix.doubleVar[intVar];
            final double[] tBlock   = doubleVar[intVar];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] + doubleVar;
            }
        }
empty line
return AbstractRealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.DenseRealMatrix <452, 460>
for (int blockIndex = 0; blockIndex < AbstractRealMatrix.blocks.length; ++blockIndex) {
            final double[] outBlock = AbstractRealMatrix.blocks[blockIndex];
            final double[] tBlock   = blocks[blockIndex];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] + d;
            }
        }
empty line
return null;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.DenseRealMatrix <471, 479>
for (int intVar = 0; intVar < AbstractRealMatrix.doubleVar.length; ++intVar) {
            final double[] outBlock = AbstractRealMatrix.doubleVar[intVar];
            final double[] tBlock   = doubleVar[intVar];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] * doubleVar;
            }
        }
empty line
return AbstractRealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.DenseRealMatrix <471, 479>
for (int blockIndex = 0; blockIndex < AbstractRealMatrix.blocks.length; ++blockIndex) {
            final double[] outBlock = AbstractRealMatrix.blocks[blockIndex];
            final double[] tBlock   = blocks[blockIndex];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] * d;
            }
        }
empty line
return null;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <897, 903>
for (int intVar = 0; intVar < intVar; intVar++) {
            final BigDecimal[] dataRow = BigDecimal[intVar];
            for (int col = 0; col < intVar; col++) {
                BigDecimal[][]Var[col][intVar] = dataRow[col];
            }
        }
return new BigMatrixImpl(BigDecimal[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <897, 903>
for (int row = 0; row < nRows; row++) {
            final BigDecimal[] dataRow = BigDecimal[row];
            for (int col = 0; col < nCols; col++) {
                outData[col][row] = dataRow[col];
            }
        }
return new BigMatrixImpl(outData, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <416, 427>
for (int intVar = 0; intVar < intVar; intVar++) {
                final BigDecimal[] dataRow    = BigDecimal[intVar];
                final BigDecimal[] outDataRow = BigDecimal[][]Var[intVar];
                for (int col = 0; col < intVar; col++) {
                    BigDecimal sum = BigDecimal;
                    for (int i = 0; i < intVar; i++) {
                        sum = sum.add(dataRow[i].multiply(BigMatrix.getEntry(i, col)));
                    }
                    outDataRow[col] = sum;
                }
            }
return new BigMatrixImpl(BigDecimal[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <416, 427>
for (int row = 0; row < nRows; row++) {
                final BigDecimal[] dataRow    = BigDecimal[row];
                final BigDecimal[] outDataRow = outData[row];
                for (int col = 0; col < nCols; col++) {
                    BigDecimal sum = BigDecimal;
                    for (int i = 0; i < nSum; i++) {
                        sum = sum.add(dataRow[i].multiply(BigMatrix.getEntry(i, col)));
                    }
                    outDataRow[col] = sum;
                }
            }
return new BigMatrixImpl(outData, false);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <139, 155>
for (int i = 0; i < randomBytes.length; i++) {
            Integer c = Integer.valueOf(randomBytes[i]);

            /* Add 128 to byte value to make interval 0-255 before
             * doing hex conversion.
             * This guarantees <= 2 hex digits from toHexString()
             * toHexString would otherwise add 2^32 to negative arguments.
             */
             String hex = Integer.toHexString(c.intValue() + 128);

             // Make sure we add 2 hex digits for each byte
             if (hex.length() == 1)  {
                 hex = "0" + hex;
             }
             outBuffer.append(hex);
        }
return outBuffer.toString().substring(0, len);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.RandomDataImpl <139, 155>
for (int intVar = 0; intVar < byte[]Var.length; intVar++) {
            Integer c = Integer.valueOf(byte[]Var[intVar]);

            /* Add 128 to byte value to make interval 0-255 before
             * doing hex conversion.
             * This guarantees <= 2 hex digits from toHexString()
             * toHexString would otherwise add 2^32 to negative arguments.
             */
             String hex = Integer.toHexString(c.intValue() + 128);

             // Make sure we add 2 hex digits for each byte
             if (hex.length() == 1)  {
                 hex = "0" + hex;
             }
             StringBuffer.append(hex);
        }
return StringBuffer.toString().substring(0, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.RandomDataImpl <139, 155>
for (int i = 0; i < randomBytes.length; i++) {
            Integer c = Integer.valueOf(randomBytes[i]);

            /* Add 128 to byte value to make interval 0-255 before
             * doing hex conversion.
             * This guarantees <= 2 hex digits from toHexString()
             * toHexString would otherwise add 2^32 to negative arguments.
             */
             String hex = Integer.toHexString(c.intValue() + 128);

             // Make sure we add 2 hex digits for each byte
             if (hex.length() == 1)  {
                 hex = "0" + hex;
             }
             StringBuffer.append(hex);
        }
return StringBuffer.toString().substring(0, len);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <904, 918>
for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {
                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&
                            (work[i + 2] <= TOLERANCE_2 * sigma)) {
                            // insert a split
                            work[i + 2]  = -sigma;
                            split        = i / 4;
                            qMax         = 0;
                            eMin         = work[i + 6];
                            previousEMin = work[i + 7];
                        } else {
                            qMax         = Math.max(qMax, work[i + 4]);
                            eMin         = Math.min(eMin, work[i + 2]);
                            previousEMin = Math.min(previousEMin, work[i + 3]);
                        }
                    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.ValueServer <146, 149>
for (int intVar = 0; intVar < intVar; intVar++) {
            double[]Var[intVar] = getNext();
        }
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.ValueServer <146, 149>
for (int i = 0; i < length; i++) {
            out[i] = getNext();
        }
return out;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <706, 711>
if (column > 0) {
                throw MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet",
                                                                       new Object[] { column });
            }
data = new BigDecimal[nRows][nCols];
System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <706, 711>
if (intVar > 0) {
                throw MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet",
                                                                       new Object[] { intVar });
            }
BigDecimal = new BigDecimal[intVar][intVar];
System.arraycopy(BigDecimal[][]Var, 0, BigDecimal, 0, BigDecimal[][]Var.length);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <221, 231>
if (truncated) {
                        // the step has been truncated, we need to adjust the previous steps
                        for (int i = 1; i < previousF.length; ++i) {
                            previousT[i] = stepStart - i * stepSize;
                            interpolator.setInterpolatedTime(previousT[i]);
                            System.arraycopy(interpolator.getInterpolatedState(), 0,
                                             previousF[i], 0, y0.length);
                        }
                    } else {
                        rotatePreviousSteps();
                    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <188, 198>
if (truncated) {
                        // the step has been truncated, we need to adjust the previous steps
                        for (int i = 1; i < previousF.length; ++i) {
                            previousT[i] = stepStart - i * stepSize;
                            interpolator.setInterpolatedTime(previousT[i]);
                            System.arraycopy(interpolator.getInterpolatedState(), 0,
                                             previousF[i], 0, y0.length);
                        }
                    } else {
                        rotatePreviousSteps();
                    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <369, 376>
for (int intVar = 0; intVar < intVar; intVar++) {
            final BigDecimal[] dataRow    = BigDecimal[intVar];
            final BigDecimal[] outDataRow = BigDecimal[][]Var[intVar];
            for (int col = 0; col < intVar; col++) {
                outDataRow[col] = dataRow[col].add(BigDecimal);
            }
        }
return new BigMatrixImpl(BigDecimal[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <369, 376>
for (int row = 0; row < rowCount; row++) {
            final BigDecimal[] dataRow    = BigDecimal[row];
            final BigDecimal[] outDataRow = outData[row];
            for (int col = 0; col < columnCount; col++) {
                outDataRow[col] = dataRow[col].add(BigDecimal);
            }
        }
return new BigMatrixImpl(outData, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <388, 395>
for (int intVar = 0; intVar < intVar; intVar++) {
            final BigDecimal[] dataRow    = BigDecimal[intVar];
            final BigDecimal[] outDataRow = BigDecimal[][]Var[intVar];
            for (int col = 0; col < intVar; col++) {
                outDataRow[col] = dataRow[col].multiply(BigDecimal);
            }
        }
return new BigMatrixImpl(BigDecimal[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <388, 395>
for (int row = 0; row < rowCount; row++) {
            final BigDecimal[] dataRow    = BigDecimal[row];
            final BigDecimal[] outDataRow = outData[row];
            for (int col = 0; col < columnCount; col++) {
                outDataRow[col] = dataRow[col].multiply(BigDecimal);
            }
        }
return new BigMatrixImpl(outData, false);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastCosineTransformer <101, 105>
/**
     * Transform the given real data set.
     * <p>
     * The formula is F<sub>n</sub> = &radic;(1/2N) [f<sub>0</sub> + (-1)<sup>n</sup> f<sub>N</sub>] +
     *                        &radic;(2/N) &sum;<sub>k=1</sub><sup>N-1</sup> f<sub>k</sub> cos(&pi; nk/N)
     * </p>
     * 
     * @param f the real data array to be transformed
     * @return the real transformed array
     * @throws IllegalArgumentException if any parameters are invalid
     */
    public double[] transform2(double f[]) throws IllegalArgumentException {

        double scaling_coefficient = Math.sqrt(2.0 / (f.length-1));
        return FastFourierTransformer.scaleArray(fct(f), scaling_coefficient);
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.AbstractEstimator <131, 135>
for (int intVar = 0; intVar < WeightedMeasurement[]Var.length; ++intVar) {
            double residual = WeightedMeasurement[]Var[intVar].getResidual();
            doubleVar += WeightedMeasurement[]Var[intVar].getWeight() * residual * residual;
        }
return Math.sqrt(doubleVar / WeightedMeasurement[]Var.length);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.AbstractEstimator <131, 135>
for (int i = 0; i < wm.length; ++i) {
            double residual = wm[i].getResidual();
            criterion += wm[i].getWeight() * residual * residual;
        }
return Math.sqrt(criterion / wm.length);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <404, 409>
if (subMatrix[r].length != nCols) {
                throw MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}",
                                                                          new Object[] {
                                                                              nCols, subMatrix[r].length
                                                                          }); 
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.AbstractEstimator <146, 150>
for (int intVar = 0; intVar < WeightedMeasurement[]Var.length; ++intVar) {
            double residual = WeightedMeasurement[]Var[intVar].getResidual();
            doubleVar += residual * residual / WeightedMeasurement[]Var[intVar].getWeight();
        }
return doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.AbstractEstimator <146, 150>
for (int i = 0; i < wm.length; ++i) {
            double residual = wm[i].getResidual();
            chiSquare += residual * residual / wm[i].getWeight();
        }
return chiSquare;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.PolynomialFunction <97, 99>
double[] out = new double[coefficients.length];
System.arraycopy(coefficients,0, out, 0, coefficients.length);
return out;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.PolynomialFunctionNewtonForm <111, 113>
double[] out = new double[a.length];
System.arraycopy(a, 0, out, 0, a.length);
return out;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.PolynomialFunctionNewtonForm <124, 126>
double[] out = new double[c.length];
System.arraycopy(c, 0, out, 0, c.length);
return out;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.PolynomialFunctionNewtonForm <140, 142>
double[] out = new double[coefficients.length];
System.arraycopy(coefficients, 0, out, 0, coefficients.length);
return out;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.PolynomialFunctionLagrangeForm <114, 116>
double[] out = new double[x.length];
System.arraycopy(x, 0, out, 0, x.length);
return out;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.PolynomialFunctionLagrangeForm <127, 129>
double[] out = new double[y.length];
System.arraycopy(y, 0, out, 0, y.length);
return out;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.PolynomialFunctionLagrangeForm <143, 145>
double[] out = new double[coefficients.length];
System.arraycopy(coefficients, 0, out, 0, coefficients.length);
return out;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1399, 1401>
final int[] out = new int[permutation.length];
System.arraycopy(permutation, 0, out, 0, permutation.length);
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.LaguerreSolver <228, 231>
for (int intVar = 0; intVar < Complex.length; intVar++) {
            Complex[intVar] = new Complex(doubleVar[intVar], 0.0);
        }
return solveAll(Complex, Complex);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.LaguerreSolver <228, 231>
for (int i = 0; i < Complex.length; i++) {
            Complex[i] = new Complex(coefficients[i], 0.0);
        }
return solveAll(Complex, Complex);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <468, 474>
for (int intVar = 0; intVar < intVar; ++intVar) {
            final double[] rowI = doubleVar[intVar];
            for (int j = 0; j < intVar; ++j) {
                rowI[j] = RealMatrixChangingVisitor.visit(intVar, j, rowI[j]);
            }
        }
return RealMatrixChangingVisitor.end();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealMatrixImpl <468, 474>
for (int i = 0; i < rows; ++i) {
            final double[] rowI = data[i];
            for (int j = 0; j < columns; ++j) {
                rowI[j] = RealMatrixChangingVisitor.visit(i, j, rowI[j]);
            }
        }
return RealMatrixChangingVisitor.end();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <532, 538>
for (int intVar = 0; intVar < intVar; ++intVar) {
            for (int i = 0; i < intVar; ++i) {
                final double[] rowI = doubleVar[i];
                rowI[intVar] = RealMatrixChangingVisitor.visit(i, intVar, rowI[intVar]);
            }
        }
return RealMatrixChangingVisitor.end();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealMatrixImpl <532, 538>
for (int j = 0; j < columns; ++j) {
            for (int i = 0; i < rows; ++i) {
                final double[] rowI = data[i];
                rowI[j] = RealMatrixChangingVisitor.visit(i, j, rowI[j]);
            }
        }
return RealMatrixChangingVisitor.end();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.AbstractIntegerDistribution <167, 187>
if (pm > p) {
                // update x1
                if (xm == x1) {
                    // this can happen with integer division
                    // simply decrement x1
                    --x1;
                } else {
                    // update x1 normally
                    x1 = xm;
                }
            } else {
                // update x0
                if (xm == x0) {
                    // this can happen with integer division
                    // simply increment x0
                    ++x0;
                } else {
                    // update x0 normally
                    x0 = xm;
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <332, 342>
if (currentDegree > 3) {
            double cDot = 0;
            double c = polynoms[currentDegree][i];
            for (int j = currentDegree - 1; j > 3; --j) {
                final double d = 1.0 / (j - 3);
                cDot = d * (theta05 * cDot + c);
                c = polynoms[j][i] + c * d * theta05;
            }
            interpolatedState[i]       += t4 * c;
            interpolatedDerivatives[i] += (t4 * cDot + t4Dot * c) / h;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.CorrelatedRandomVectorGenerator <276, 283>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
            double[]Var[intVar] = double[]Var[intVar];
            for (int j = 0; j < intVar; ++j) {
                double[]Var[intVar] += RealMatrix.getEntry(intVar, j) * double[]Var[j];
            }
        }
empty line
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.CorrelatedRandomVectorGenerator <276, 283>
for (int i = 0; i < correlated.length; ++i) {
            correlated[i] = mean[i];
            for (int j = 0; j < rank; ++j) {
                correlated[i] += RealMatrix.getEntry(i, j) * normalized[j];
            }
        }
empty line
return correlated;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastCosineTransformer <128, 130>
double data[] = FastFourierTransformer.sample(f, min, max, n);
double scaling_coefficient = Math.sqrt(2.0 / (n-1));
return FastFourierTransformer.scaleArray(fct(data), scaling_coefficient);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <338, 351>
if (a != 0.0) {
                hK[k] -= a;
                for (int i = k + 1; i < m; ++i) {
                    final double[] hI = householderVectors[i];
                    double alpha = 0;
                    for (int j = k; j < n; ++j) {
                        alpha -= hI[j] * hK[j];
                    }
                    alpha /= a * householderVectors[k][k];
                    for (int j = k; j < n; ++j) {
                        hI[j] -= alpha * hK[j];
                    }
                }
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.DenseRealMatrix <1019, 1022>
if (intVar >= double[]Var.length) {
                    double[]Var = AbstractRealMatrix.doubleVar[++intVar];
                    intVar = 0;
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <270, 277>
for (int intVar = 0; intVar < intVar; intVar++) {
                final BigDecimal[] dataRow    = BigDecimal[intVar];
                final BigDecimal[] outDataRow = BigDecimal[][]Var[intVar];
                for (int col = 0; col < intVar; col++) {
                    outDataRow[col] = dataRow[col].add(BigMatrix.getEntry(intVar, col));
                }  
            }
return new BigMatrixImpl(BigDecimal[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <270, 277>
for (int row = 0; row < rowCount; row++) {
                final BigDecimal[] dataRow    = BigDecimal[row];
                final BigDecimal[] outDataRow = outData[row];
                for (int col = 0; col < columnCount; col++) {
                    outDataRow[col] = dataRow[col].add(BigMatrix.getEntry(row, col));
                }  
            }
return new BigMatrixImpl(outData, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <393, 403>
for (intVar = 4; intVar < intVar; intVar <<= 1) {
            intVar = intVar / (intVar<<1);
            for (intVar = 0; intVar < intVar; intVar += intVar<<1) {
                for (intVar = 0; intVar < intVar; intVar++) {
                    Complex = Complex[intVar+intVar+intVar].multiply(Complex[intVar*intVar]);
                    Complex[intVar+intVar+intVar] = Complex[intVar+intVar].subtract(Complex);
                    Complex[intVar+intVar] = Complex[intVar+intVar].add(Complex);
                }
            }
        }
return Complex;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <710, 713>
for (int intVar = 0; intVar < int[]Var.length; intVar++) {
                Object = ((Object[]) Object)[intVar[intVar]];
            }
return (Complex) Object;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <710, 713>
for (int i = 0; i < dimensionSize.length; i++) {
                Object = ((Object[]) Object)[vector[i]];
            }
return (Complex) Object;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <323, 330>
for (int intVar = 0; intVar < intVar; intVar++) {
                final BigDecimal[] dataRow    = BigDecimal[intVar];
                final BigDecimal[] outDataRow = BigDecimal[][]Var[intVar];
                for (int col = 0; col < intVar; col++) {
                    outDataRow[col] = dataRow[col].subtract(getEntry(intVar, col));
                }  
            }
return new BigMatrixImpl(BigDecimal[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <323, 330>
for (int row = 0; row < rowCount; row++) {
                final BigDecimal[] dataRow    = BigDecimal[row];
                final BigDecimal[] outDataRow = outData[row];
                for (int col = 0; col < columnCount; col++) {
                    outDataRow[col] = dataRow[col].subtract(getEntry(row, col));
                }  
            }
return new BigMatrixImpl(outData, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <446, 457>
for (int intVar = 0; intVar < intVar; intVar++) {
            final BigDecimal[] dataRow    = BigDecimal[intVar];
            final BigDecimal[] outDataRow = BigDecimal[][]Var[intVar];
            for (int col = 0; col < intVar; col++) {
                BigDecimal sum = BigDecimal;
                for (int i = 0; i < intVar; i++) {
                    sum = sum.add(dataRow[i].multiply(BigMatrixImpl.BigDecimal[i][col]));
                }
                outDataRow[col] = sum;
            }
        }
return new BigMatrixImpl(BigDecimal[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <446, 457>
for (int row = 0; row < nRows; row++) {
            final BigDecimal[] dataRow    = BigDecimal[row];
            final BigDecimal[] outDataRow = outData[row];
            for (int col = 0; col < nCols; col++) {
                BigDecimal sum = BigDecimal;
                for (int i = 0; i < nSum; i++) {
                    sum = sum.add(dataRow[i].multiply(BigMatrixImpl.BigDecimal[i][col]));
                }
                outDataRow[col] = sum;
            }
        }
return new BigMatrixImpl(outData, false);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <175, 186>
if (manager.reset(stepStart, y)) {

                    // some events handler has triggered changes that
                    // invalidate the derivatives, we need to restart from scratch
                    stopTime =
                        start(previousF.length, stepSize, manager, equations, stepStart, y);
                    if (Double.isNaN(previousT[0])) {
                        return stopTime;
                    }
                    stepStart = previousT[0];

                } else {

                    if (truncated) {
                        // the step has been truncated, we need to adjust the previous steps
                        for (int i = 1; i < previousF.length; ++i) {
                            previousT[i] = stepStart - i * stepSize;
                            interpolator.setInterpolatedTime(previousT[i]);
                            System.arraycopy(interpolator.getInterpolatedState(), 0,
                                             previousF[i], 0, y0.length);
                        }
                    } else {
                        rotatePreviousSteps();
                    }

                    // evaluate differential equations for next step
                    previousT[0] = stepStart;
                    equations.computeDerivatives(stepStart, y, previousF[0]);

                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <131, 135>
throws IllegalArgumentException {
empty line
double scaling_coefficient = 1.0 / Math.sqrt(f.length);
return scaleArray(fft(f, false), scaling_coefficient);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <249, 253>
throws IllegalArgumentException {
empty line
double scaling_coefficient = 1.0 / Math.sqrt(f.length);
return scaleArray(fft(f, true), scaling_coefficient);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastCosineTransformer <170, 172>
double data[] = FastFourierTransformer.sample(f, min, max, n);
double scaling_coefficient = 2.0 / (n - 1);
return FastFourierTransformer.scaleArray(fct(data), scaling_coefficient);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <195, 204>
for (int intVar = 0; intVar < intVar; intVar++) {
            final double[] dataRow    = doubleVar[intVar];
            final double[] mRow       = AbstractRealMatrix.doubleVar[intVar];
            final double[] outDataRow = double[][]Var[intVar];
            for (int col = 0; col < intVar; col++) {
                outDataRow[col] = dataRow[col] + mRow[col];
            }
        }
empty line
return new RealMatrixImpl(double[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealMatrixImpl <195, 204>
for (int row = 0; row < rowCount; row++) {
            final double[] dataRow    = data[row];
            final double[] mRow       = AbstractRealMatrix.data[row];
            final double[] outDataRow = outData[row];
            for (int col = 0; col < columnCount; col++) {
                outDataRow[col] = dataRow[col] + mRow[col];
            }
        }
empty line
return new RealMatrixImpl(outData, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <234, 243>
for (int intVar = 0; intVar < intVar; intVar++) {
            final double[] dataRow    = doubleVar[intVar];
            final double[] mRow       = AbstractRealMatrix.doubleVar[intVar];
            final double[] outDataRow = double[][]Var[intVar];
            for (int col = 0; col < intVar; col++) {
                outDataRow[col] = dataRow[col] - mRow[col];
            }
        }
empty line
return new RealMatrixImpl(double[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealMatrixImpl <234, 243>
for (int row = 0; row < rowCount; row++) {
            final double[] dataRow    = data[row];
            final double[] mRow       = AbstractRealMatrix.data[row];
            final double[] outDataRow = outData[row];
            for (int col = 0; col < columnCount; col++) {
                outDataRow[col] = dataRow[col] - mRow[col];
            }
        }
empty line
return new RealMatrixImpl(outData, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.UncorrelatedRandomVectorGenerator <74, 78>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
      double[]Var[intVar] = double[]Var[intVar] + double[]Var[intVar] * NormalizedRandomGenerator.nextNormalizedDouble();
    }
empty line
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.UncorrelatedRandomVectorGenerator <74, 78>
for (int i = 0; i < random.length; ++i) {
      random[i] = mean[i] + standardDeviation[i] * NormalizedRandomGenerator.nextNormalizedDouble();
    }
empty line
return random;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.ContinuousOutputModel <264, 271>
if (intVar > 0) {
          intVar = intVar;
          doubleVar = 0.5 * (StepInterpolator.getPreviousTime() + StepInterpolator.getCurrentTime());
        } else {
          // we have found the target step, no need to continue searching
          StepInterpolator.setInterpolatedTime(doubleVar);
          return;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <1040, 1055>
for (int intVar = 0; intVar < intVar; ++intVar) {
            if (intVar > 0) {
                StringBuffer.append(",");
            }
            StringBuffer.append("{");
            for (int j = 0; j < intVar; ++j) {
                if (j > 0) {
                    StringBuffer.append(",");
                }
                StringBuffer.append(getEntry(intVar, j));
            } 
            StringBuffer.append("}");
        }
empty line
StringBuffer.append("}");
return StringBuffer.toString();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <1040, 1055>
for (int i = 0; i < nRows; ++i) {
            if (i > 0) {
                StringBuffer.append(",");
            }
            StringBuffer.append("{");
            for (int j = 0; j < nCols; ++j) {
                if (j > 0) {
                    StringBuffer.append(",");
                }
                StringBuffer.append(getEntry(i, j));
            } 
            StringBuffer.append("}");
        }
empty line
StringBuffer.append("}");
return StringBuffer.toString();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <1040, 1055>
for (int intVar = 0; intVar < intVar; ++intVar) {
            if (intVar > 0) {
                StringBuffer.append(",");
            }
            StringBuffer.append("{");
            for (int j = 0; j < intVar; ++j) {
                if (j > 0) {
                    StringBuffer.append(",");
                }
                StringBuffer.append(getEntry(intVar, j));
            } 
            StringBuffer.append("}");
        }
empty line
StringBuffer.append("}");
return StringBuffer.toString();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <1040, 1055>
for (int i = 0; i < nRows; ++i) {
            if (i > 0) {
                StringBuffer.append(",");
            }
            StringBuffer.append("{");
            for (int j = 0; j < nCols; ++j) {
                if (j > 0) {
                    StringBuffer.append(",");
                }
                StringBuffer.append(getEntry(i, j));
            } 
            StringBuffer.append("}");
        }
empty line
StringBuffer.append("}");
return StringBuffer.toString();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BiDiagonalTransformer <274, 288>
if (a != 0.0) {
                hK[k] -= a;
                for (int j = k + 1; j < n; ++j) {
                    double alpha = 0;
                    for (int i = k; i < m; ++i) {
                        final double[] hI = householderVectors[i];
                        alpha -= hI[j] * hI[k];
                    }
                    alpha /= a * householderVectors[k][k];
                    for (int i = k; i < m; ++i) {
                        final double[] hI = householderVectors[i];
                        hI[j] -= alpha * hI[k];
                    }
                }
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <662, 665>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.sqrt(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <662, 665>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.sqrt(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.NelderMead <117, 132>
if (doubleVar < doubleVar) {

        // perform an outside contraction
        double[] xC = new double[intVar];
        for (int intVar = 0; intVar < intVar; ++intVar) {
          xC[intVar] = double[]Var[intVar] + doubleVar * (double[]Var[intVar] - double[]Var[intVar]);
        }
        double costC = evaluateCost(xC);

        if (costC <= doubleVar) {
          // accept the contraction point
          replaceWorstPoint(new PointCostPair(xC, costC));
          return;
        }

      } else {

        // perform an inside contraction
        double[] xC = new double[intVar];
        for (int intVar = 0; intVar < intVar; ++intVar) {
          xC[intVar] = double[]Var[intVar] - doubleVar * (double[]Var[intVar] - double[]Var[intVar]);
        }
        double costC = evaluateCost(xC);

        if (costC < doubleVar) {
          // accept the contraction point
          replaceWorstPoint(new PointCostPair(xC, costC));
          return;
        }

      }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.NelderMead <117, 132>
if (costR < largest) {

        // perform an outside contraction
        double[] xC = new double[n];
        for (int j = 0; j < n; ++j) {
          xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]);
        }
        double costC = evaluateCost(xC);

        if (costC <= costR) {
          // accept the contraction point
          replaceWorstPoint(new PointCostPair(xC, costC));
          return;
        }

      } else {

        // perform an inside contraction
        double[] xC = new double[n];
        for (int j = 0; j < n; ++j) {
          xC[j] = centroid[j] - gamma * (centroid[j] - xLargest[j]);
        }
        double costC = evaluateCost(xC);

        if (costC < largest) {
          // accept the contraction point
          replaceWorstPoint(new PointCostPair(xC, costC));
          return;
        }

      }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.AbstractEstimator <214, 217>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
            double[]Var[intVar] = Math.sqrt(double[][]Var[intVar][intVar]) * doubleVar;
        }
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.AbstractEstimator <214, 217>
for (int i = 0; i < errors.length; ++i) {
            errors[i] = Math.sqrt(covar[i][i]) * c;
        }
return errors;

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <882, 894>
if (fraction > 0.5) {
                unscaled = Math.ceil(unscaled);
            } else if (fraction < 0.5) {
                unscaled = Math.floor(unscaled);
            } else {
                // The following equality test is intentional and needed for rounding purposes
                if (Math.floor(unscaled) / 2.0 == Math.floor(Math
                    .floor(unscaled) / 2.0)) { // even
                    unscaled = Math.floor(unscaled);
                } else { // odd
                    unscaled = Math.ceil(unscaled);
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <215, 218>
if (firstTime || !fsal) {
          // first stage
          equations.computeDerivatives(stepStart, y, yDotK[0]);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.MultistepStepInterpolator <81, 91>
if (AbstractStepInterpolator.currentState != null) {
            previousT = AbstractStepInterpolator.previousT.clone();
            previousF = new double[AbstractStepInterpolator.previousF.length][];
            for (int k = 0; k < AbstractStepInterpolator.previousF.length; ++k) {
                previousF[k] = AbstractStepInterpolator.previousF[k].clone();
            }
            initializeCoefficients();
        } else {
            previousT = null;
            previousF = null;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.EmpiricalDistributionImpl <482, 484>
double[] out = new double[len];
System.arraycopy(upperBounds, 0, out, 0, len);
return out;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.DenseRealMatrix <868, 876>
if (jWidth > available) {
                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, available);
                outBlock = out.blocks[++outBlockIndex];
                System.arraycopy(block, iRow * jWidth, outBlock, 0, jWidth - available);
                outIndex = jWidth - available;
            } else {
                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, jWidth);
                outIndex += jWidth;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.DenseRealMatrix <868, 876>
if (intVar > intVar) {
                System.arraycopy(double[]Var, intVar * intVar, double[]Var, intVar, intVar);
                double[]Var = AbstractRealMatrix.doubleVar[++intVar];
                System.arraycopy(double[]Var, intVar * intVar, double[]Var, 0, intVar - intVar);
                intVar = intVar - intVar;
            } else {
                System.arraycopy(double[]Var, intVar * intVar, double[]Var, intVar, intVar);
                intVar += intVar;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics <184, 187>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
            double[]Var[intVar] = StorelessUnivariateStatistic[]Var[intVar].getResult();
        }
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics <184, 187>
for (int i = 0; i < results.length; ++i) {
            results[i] = stats[i].getResult();
        }
return results;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.VectorialMean <66, 69>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
            double[]Var[intVar] = Mean[]Var[intVar].getResult();
        }
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.VectorialMean <66, 69>
for (int i = 0; i < result.length; ++i) {
            result[i] = means[i].getResult();
        }
return result;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealVectorImpl <1182, 1184>
System.arraycopy(data, 0, out, 0, data.length);
out[data.length] = in;
return new RealVectorImpl(out);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <512, 514>
if ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) {
                    return false;
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <512, 514>
if ((double[]Var[intVar] == 0) && (double[]Var[intVar] == 0)) {
                    return false;
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.AbstractMultipleLinearRegression <151, 154>
for (int intVar = 0; intVar < intVar; intVar++) {
            double[]Var[intVar] = Math.sqrt(doubleVar * double[][]Var[intVar][intVar]);
        }
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.AbstractMultipleLinearRegression <151, 154>
for (int i = 0; i < length; i++) {
            result[i] = Math.sqrt(sigma * betaVariance[i][i]);
        }
return result;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <582, 585>
for (int intVar = 0; intVar < int[]Var.length; intVar++) {
            mdfft(MultiDimensionalComplexMatrix, booleanVar, intVar, new int[0]);
        }
return MultiDimensionalComplexMatrix.getArray();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <582, 585>
for (int i = 0; i < dimensionSize.length; i++) {
            mdfft(MultiDimensionalComplexMatrix, forward, i, new int[0]);
        }
return MultiDimensionalComplexMatrix.getArray();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.PolynomialSplineFunction <205, 207>
double out[] = new double[n + 1];
System.arraycopy(knots, 0, out, 0, n + 1);
return out;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <773, 775>
final BigDecimal[] out = new BigDecimal[ncols];
System.arraycopy(data[row], 0, out, 0, ncols);
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <773, 775>
final BigDecimal[] BigDecimal[]Var = new BigDecimal[intVar];
System.arraycopy(BigDecimal[intVar], 0, BigDecimal[]Var, 0, intVar);
return BigDecimal[]Var;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.Fraction <204, 207>
if (den == 0) {
            throw MathRuntimeException.createArithmeticException("zero denominator in fraction {0}/{1}",
                                                                 new Object[] { num, den});
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.fraction.Fraction <204, 207>
if (intVar == 0) {
            throw MathRuntimeException.createArithmeticException("zero denominator in fraction {0}/{1}",
                                                                 new Object[] { intVar, intVar});
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.Fraction <366, 369>
if (numerator==Integer.MIN_VALUE) {
            throw MathRuntimeException.createArithmeticException("overflow in fraction {0}/{1}, cannot negate",
                                                                 new Object[] { numerator, denominator});
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.Fraction <525, 528>
if (denominator == 0) {
            throw MathRuntimeException.createArithmeticException("zero denominator in fraction {0}/{1}",
                                                                 new Object[] { numerator, denominator});
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.fraction.Fraction <525, 528>
if (intVar == 0) {
            throw MathRuntimeException.createArithmeticException("zero denominator in fraction {0}/{1}",
                                                                 new Object[] { intVar, intVar});
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <167, 174>
for (int intVar = 0; intVar < intVar; intVar++) {
            for (int col = 0; col < intVar; col++) {
                doubleVar = (double[]Var[intVar] * double[]Var[col]) / doubleVar;
                doubleVar += (((double) long[][]Var[intVar][col] - doubleVar) * 
                        ((double) long[][]Var[intVar][col] - doubleVar)) / doubleVar; 
            }
        }
return doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <167, 174>
for (int row = 0; row < nRows; row++) {
            for (int col = 0; col < nCols; col++) {
                expected = (rowSum[row] * colSum[col]) / total;
                sumSq += (((double) counts[row][col] - expected) * 
                        ((double) counts[row][col] - expected)) / expected; 
            }
        }
return sumSq;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <206, 219>
if (manager.reset(stepStart, y)) {

                    // some events handler has triggered changes that
                    // invalidate the derivatives, we need to restart from scratch
                    stopTime =
                        start(previousF.length - 1, stepSize, manager, equations, stepStart, y);
                    if (Double.isNaN(previousT[0])) {
                        return stopTime;
                    }
                    stepStart = previousT[0];
                    rotatePreviousSteps();
                    previousF[0] = new double[y0.length];

                } else {

                    if (truncated) {
                        // the step has been truncated, we need to adjust the previous steps
                        for (int i = 1; i < previousF.length; ++i) {
                            previousT[i] = stepStart - i * stepSize;
                            interpolator.setInterpolatedTime(previousT[i]);
                            System.arraycopy(interpolator.getInterpolatedState(), 0,
                                             previousF[i], 0, y0.length);
                        }
                    } else {
                        rotatePreviousSteps();
                    }

                    // evaluate differential equations for next step
                    previousT[0] = stepStart;
                    equations.computeDerivatives(stepStart, y, previousF[0]);

                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastSineTransformer <127, 129>
data[0] = 0.0;
double scaling_coefficient = Math.sqrt(2.0 / n);
return FastFourierTransformer.scaleArray(fst(data), scaling_coefficient);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <156, 158>
double data[] = sample(f, min, max, n);
double scaling_coefficient = 1.0 / Math.sqrt(n);
return scaleArray(fft(data, false), scaling_coefficient);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <274, 276>
double data[] = sample(f, min, max, n);
double scaling_coefficient = 1.0 / Math.sqrt(n);
return scaleArray(fft(data, true), scaling_coefficient);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.MatrixUtils <288, 291>
for (int intVar = 0; intVar < intVar; intVar++) {
            BigDecimal[][]Var[intVar][0] = BigDecimal[]Var[intVar];
        }
return new BigMatrixImpl(BigDecimal[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.MatrixUtils <288, 291>
for (int row = 0; row < nRows; row++) {
            data[row][0] = columnData[row];
        }
return new BigMatrixImpl(data, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.DenseRealMatrix <362, 371>
for (int intVar = 0; intVar < AbstractRealMatrix.doubleVar.length; ++intVar) {
            final double[] outBlock = AbstractRealMatrix.doubleVar[intVar];
            final double[] tBlock   = doubleVar[intVar];
            final double[] mBlock   = AbstractRealMatrix.doubleVar[intVar];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] + mBlock[k];
            }
        }
empty line
return AbstractRealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.DenseRealMatrix <362, 371>
for (int blockIndex = 0; blockIndex < AbstractRealMatrix.blocks.length; ++blockIndex) {
            final double[] outBlock = AbstractRealMatrix.blocks[blockIndex];
            final double[] tBlock   = blocks[blockIndex];
            final double[] mBlock   = AbstractRealMatrix.blocks[blockIndex];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] + mBlock[k];
            }
        }
empty line
return null;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.DenseRealMatrix <432, 441>
for (int intVar = 0; intVar < AbstractRealMatrix.doubleVar.length; ++intVar) {
            final double[] outBlock = AbstractRealMatrix.doubleVar[intVar];
            final double[] tBlock   = doubleVar[intVar];
            final double[] mBlock   = AbstractRealMatrix.doubleVar[intVar];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] - mBlock[k];
            }
        }
empty line
return AbstractRealMatrix;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.DenseRealMatrix <432, 441>
for (int blockIndex = 0; blockIndex < AbstractRealMatrix.blocks.length; ++blockIndex) {
            final double[] outBlock = AbstractRealMatrix.blocks[blockIndex];
            final double[] tBlock   = blocks[blockIndex];
            final double[] mBlock   = AbstractRealMatrix.blocks[blockIndex];
            for (int k = 0; k < outBlock.length; ++k) {
                outBlock[k] = tBlock[k] - mBlock[k];
            }
        }
empty line
return null;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.complex.Complex <931, 939>
for (int intVar = 0; intVar < intVar ; intVar++) {
            // inner part
            final double realPart      = doubleVar *  Math.cos(doubleVar);
            final double imaginaryPart = doubleVar *  Math.sin(doubleVar);
            ListVar.add(createComplex(realPart, imaginaryPart));
            doubleVar += doubleVar;
        }
empty line
return ListVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.complex.Complex <931, 939>
for (int k = 0; k < n ; k++) {
            // inner part
            final double realPart      = nthRootOfAbs *  Math.cos(innerPart);
            final double imaginaryPart = nthRootOfAbs *  Math.sin(innerPart);
            result.add(createComplex(realPart, imaginaryPart));
            innerPart += slice;
        }
empty line
return result;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastSineTransformer <101, 105>
/**
     * Transform the given real data set.
     * <p>
     * The formula is F<sub>n</sub> = &radic;(2/N) &sum;<sub>k=0</sub><sup>N-1</sup> f<sub>k</sub> sin(&pi; nk/N)
     * </p>
     * 
     * @param f the real data array to be transformed
     * @return the real transformed array
     * @throws IllegalArgumentException if any parameters are invalid
     */
    public double[] transform2(double f[]) throws IllegalArgumentException {

        double scaling_coefficient = Math.sqrt(2.0 / f.length);
        return FastFourierTransformer.scaleArray(fst(f), scaling_coefficient);
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.QRDecompositionImpl <328, 338>
for (int intVar = double[]Var.length - 1; intVar >= 0; --intVar) {
                double[]Var[intVar] /= double[]Var[intVar];
                final double yRow   = double[]Var[intVar];
                final double[] qrtRow = double[][]Var[intVar];
                double[]Var[intVar] = yRow;
                for (int i = 0; i < intVar; i++) {
                    double[]Var[i] -= yRow * qrtRow[i];
                }
            }
empty line
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.QRDecompositionImpl <328, 338>
for (int row = rDiag.length - 1; row >= 0; --row) {
                y[row] /= rDiag[row];
                final double yRow   = y[row];
                final double[] qrtRow = qrt[row];
                x[row] = yRow;
                for (int i = 0; i < row; i++) {
                    y[i] -= yRow * qrtRow[i];
                }
            }
empty line
return x;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <366, 369>
while (unif == 0.0d) {
            unif = rand.nextDouble();
        }
return -mean * Math.log(unif);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastCosineTransformer <144, 148>
/**
     * Inversely transform the given real data set.
     * <p>
     * The formula is f<sub>k</sub> = (1/N) [F<sub>0</sub> + (-1)<sup>k</sup> F<sub>N</sub>] +
     *                        (2/N) &sum;<sub>n=1</sub><sup>N-1</sup> F<sub>n</sub> cos(&pi; nk/N)
     * </p>
     * 
     * @param f the real data array to be inversely transformed
     * @return the real inversely transformed array
     * @throws IllegalArgumentException if any parameters are invalid
     */
    public double[] inversetransform(double f[]) throws IllegalArgumentException {

        double scaling_coefficient = 2.0 / (f.length - 1);
        return FastFourierTransformer.scaleArray(fct(f), scaling_coefficient);
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorFormat <318, 321>
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
            double[]Var[intVar] = ListVar.get(intVar).doubleValue();
        }
return new RealVectorImpl(double[]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorFormat <318, 321>
for (int i = 0; i < data.length; ++i) {
            data[i] = components.get(i).doubleValue();
        }
return new RealVectorImpl(data, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <494, 499>
for (int intVar = 0; intVar < intVar; intVar++) {
            for (int j = 0; j < intVar; j++) {
                doubleVar[intVar][j] = BigDecimal[intVar][j].doubleValue();
            }
        }
return doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <494, 499>
for (int i = 0; i < nRows; i++) {
            for (int j = 0; j < nCols; j++) {
                d[i][j] = BigDecimal[i][j].doubleValue();
            }
        }
return d;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <295, 303>
for (int intVar = 0; intVar < intVar; intVar++) {
            final BigDecimal[] dataRow    = BigDecimal[intVar];
            final BigDecimal[] mRow       = BigMatrixImpl.BigDecimal[intVar];
            final BigDecimal[] outDataRow = BigDecimal[][]Var[intVar];
            for (int col = 0; col < intVar; col++) {
                outDataRow[col] = dataRow[col].add(mRow[col]);
            }  
        }
return new BigMatrixImpl(BigDecimal[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <295, 303>
for (int row = 0; row < rowCount; row++) {
            final BigDecimal[] dataRow    = BigDecimal[row];
            final BigDecimal[] mRow       = BigMatrixImpl.BigDecimal[row];
            final BigDecimal[] outDataRow = outData[row];
            for (int col = 0; col < columnCount; col++) {
                outDataRow[col] = dataRow[col].add(mRow[col]);
            }  
        }
return new BigMatrixImpl(outData, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <348, 356>
for (int intVar = 0; intVar < intVar; intVar++) {
            final BigDecimal[] dataRow    = BigDecimal[intVar];
            final BigDecimal[] mRow       = BigMatrixImpl.BigDecimal[intVar];
            final BigDecimal[] outDataRow = BigDecimal[][]Var[intVar];
            for (int col = 0; col < intVar; col++) {
                outDataRow[col] = dataRow[col].subtract(mRow[col]);
            }  
        }
return new BigMatrixImpl(BigDecimal[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <348, 356>
for (int row = 0; row < rowCount; row++) {
            final BigDecimal[] dataRow    = BigDecimal[row];
            final BigDecimal[] mRow       = BigMatrixImpl.BigDecimal[row];
            final BigDecimal[] outDataRow = outData[row];
            for (int col = 0; col < columnCount; col++) {
                outDataRow[col] = dataRow[col].subtract(mRow[col]);
            }  
        }
return new BigMatrixImpl(outData, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.LUDecompositionImpl <332, 339>
for (int intVar = intVar - 1; intVar >= 0; intVar--) {
                    double[]Var[intVar] /= doubleVar[intVar][intVar];
                    for (int i = 0; i < intVar; i++) {
                        double[]Var[i] -= double[]Var[intVar] * doubleVar[i][intVar];
                    }
                }
empty line
return new RealVectorImpl(double[]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.LUDecompositionImpl <332, 339>
for (int col = m - 1; col >= 0; col--) {
                    bp[col] /= lu[col][col];
                    for (int i = 0; i < col; i++) {
                        bp[i] -= bp[col] * lu[i][col];
                    }
                }
empty line
return new RealVectorImpl(bp, false);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.MullerSolver <201, 212>
} else {
double xm = 0.5 * (x0 + x2);
double ym = f.value(xm);
if (MathUtils.sign(y0) + MathUtils.sign(ym) == 0.0) {
                    x2 = xm; y2 = ym;
                } else {
                    x0 = xm; y0 = ym;
                }
x1 = 0.5 * (x0 + x2);
y1 = f.value(x1);
oldx = Double.POSITIVE_INFINITY;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1081, 1084>
for (int row = 0; row < nRows; row++) {
            out[row] = solution[row][0];
        }
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <1081, 1084>
for (int intVar = 0; intVar < intVar; intVar++) {
            BigDecimal[]Var[intVar] = BigDecimal[][]Var[intVar][0];
        }
return BigDecimal[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <1081, 1084>
for (int row = 0; row < nRows; row++) {
            out[row] = solution[row][0];
        }
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <298, 301>
if (booleanVar) {
        // save the last evaluation for the next step
        System.arraycopy(double[][]Var[intVar - 1], 0, double[][]Var[0], 0, double[]Var.length);
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.ZipfDistributionImpl <131, 137>
if (x <= 0) {
            return 0.0;
        } else if (x >= getNumberOfElements()) {
            return 1.0;
        }
empty line
return generalizedHarmonic(x, exponent) / generalizedHarmonic(numberOfElements, exponent);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.ZipfDistributionImpl <131, 137>
if (intVar <= 0) {
            return 0.0;
        } else if (intVar >= getNumberOfElements()) {
            return 1.0;
        }
empty line
return generalizedHarmonic(intVar, doubleVar) / generalizedHarmonic(intVar, doubleVar);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <1153, 1168>
for (int intVar = intVar - 1; intVar >= 0; intVar--) {
            final BigDecimal[] bpCol = BigDecimal[][]Var[intVar];
            final BigDecimal luDiag = BigDecimal[intVar][intVar];
            for (int j = 0; j < intVar; j++) {
                bpCol[j] = bpCol[j].divide(luDiag, intVar, intVar);
            }
            for (int i = 0; i < intVar; i++) {
                final BigDecimal[] bpI = BigDecimal[][]Var[i];
                final BigDecimal[] luI = BigDecimal[i];
                for (int j = 0; j < intVar; j++) {
                    bpI[j] = bpI[j].subtract(BigDecimal[][]Var[intVar][j].multiply(luI[intVar]));
                }
            }
        }
empty line
return new BigMatrixImpl(BigDecimal[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <1153, 1168>
for (int col = nCol - 1; col >= 0; col--) {
            final BigDecimal[] bpCol = bp[col];
            final BigDecimal luDiag = BigDecimal[col][col];
            for (int j = 0; j < nColB; j++) {
                bpCol[j] = bpCol[j].divide(luDiag, scale, roundingMode);
            }
            for (int i = 0; i < col; i++) {
                final BigDecimal[] bpI = bp[i];
                final BigDecimal[] luI = BigDecimal[i];
                for (int j = 0; j < nColB; j++) {
                    bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));
                }
            }
        }
empty line
return new BigMatrixImpl(bp, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <373, 376>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.pow(doubleVar[intVar], doubleVar);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <373, 376>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.pow(data[i], d);
        }
return new RealVectorImpl(out);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <594, 597>
if (startColumn > endColumn) {
            throw new MatrixIndexException("initial column {0} after final column {1}",
                                           new Object[] { startColumn, endColumn });
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <1156, 1159>
if (startColumn > endColumn) {
            throw new MatrixIndexException("initial column {0} after final column {1}",
                                           new Object[] { startColumn, endColumn });
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <215, 217>
double data[] = sample(f, min, max, n);
double scaling_coefficient = 1.0 / n;
return scaleArray(fft(data, true), scaling_coefficient);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <543, 552>
if (denseOutput) {
      yDot1    = new double[y0.length];
      yMidDots = new double[1 + 2 * sequence.length][];
      for (int j = 0; j < yMidDots.length; ++j) {
        yMidDots[j] = new double[y0.length];
      }
    } else {
      yMidDots    = new double[1][];
      yMidDots[0] = new double[y0.length];
    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <543, 552>
if (denseOutput) {
      yDot1    = new double[y0.length];
      yMidDots = new double[1 + 2 * sequence.length][];
      for (int j = 0; j < yMidDots.length; ++j) {
        yMidDots[j] = new double[y0.length];
      }
    } else {
      yMidDots    = new double[1][];
      yMidDots[0] = new double[y0.length];
    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <346, 350>
if (h == 0) {
        // in this degenerated case, the previous computation leads to NaN for derivatives
        // we fix this by using the derivatives at midpoint
        System.arraycopy(yMidDots[1], 0, interpolatedDerivatives, 0, dimension);
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <390, 393>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.exp(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <390, 393>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.exp(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <407, 410>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.expm1(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <407, 410>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.expm1(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <424, 427>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.log(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <424, 427>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.log(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealVectorImpl <441, 444>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.log10(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <441, 444>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.log10(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <441, 444>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.log10(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <458, 461>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.log1p(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <458, 461>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.log1p(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <475, 478>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.cosh(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <475, 478>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.cosh(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <492, 495>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.sinh(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <492, 495>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.sinh(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <509, 512>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.tanh(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <509, 512>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.tanh(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <526, 529>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.cos(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <526, 529>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.cos(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <543, 546>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.sin(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <543, 546>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.sin(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <560, 563>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.tan(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <560, 563>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.tan(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <577, 580>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.acos(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <577, 580>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.acos(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <594, 597>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.asin(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <594, 597>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.asin(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <611, 614>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.atan(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <611, 614>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.atan(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <679, 682>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.cbrt(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <679, 682>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.cbrt(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <696, 699>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.ceil(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <696, 699>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.ceil(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <713, 716>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.floor(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <713, 716>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.floor(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <730, 733>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.rint(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <730, 733>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.rint(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <747, 750>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.signum(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <747, 750>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.signum(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealVectorImpl <764, 767>
for (int intVar = 0; intVar < doubleVar.length; intVar++) {
            double[]Var[intVar] = Math.ulp(doubleVar[intVar]);
        }
return new RealVectorImpl(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.RealVectorImpl <764, 767>
for (int i = 0; i < data.length; i++) {
            out[i] = Math.ulp(data[i]);
        }
return new RealVectorImpl(out);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator <144, 146>
if (Double.isNaN(previousT[0])) {
            return stopTime;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <128, 130>
if (Double.isNaN(previousT[0])) {
            return stopTime;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastSineTransformer <142, 146>
/**
     * Inversely transform the given real data set.
     * <p>
     * The formula is f<sub>k</sub> = (2/N) &sum;<sub>n=0</sub><sup>N-1</sup> F<sub>n</sub> sin(&pi; nk/N)
     * </p>
     * 
     * @param f the real data array to be inversely transformed
     * @return the real inversely transformed array
     * @throws IllegalArgumentException if any parameters are invalid
     */
    public double[] inversetransform(double f[]) throws IllegalArgumentException {

        double scaling_coefficient = 2.0 / f.length;
        return FastFourierTransformer.scaleArray(fst(f), scaling_coefficient);
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <789, 793>
if (z0 < z1) {
            final double t = z0;
            z0 = z1;
            z1 = t;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <799, 803>
if (z0 < z1) {
            final double t = z0;
            z0 = z1;
            z1 = t;
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.ResizableDoubleArray <557, 560>
double[] double[]Var = new double[intVar];
System.arraycopy( double[]Var, intVar, double[]Var, 0,
                intVar);
return double[]Var;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.ResizableDoubleArray <557, 560>
double[] elementArray = new double[numElements];
System.arraycopy( internalArray, startIndex, elementArray, 0,
                numElements);
return elementArray;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.LUDecompositionImpl <291, 298>
for (int intVar = intVar - 1; intVar >= 0; intVar--) {
                double[]Var[intVar] /= doubleVar[intVar][intVar];
                for (int i = 0; i < intVar; i++) {
                    double[]Var[i] -= double[]Var[intVar] * doubleVar[i][intVar];
                }
            }
empty line
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.LUDecompositionImpl <291, 298>
for (int col = m - 1; col >= 0; col--) {
                bp[col] /= lu[col][col];
                for (int i = 0; i < col; i++) {
                    bp[i] -= bp[col] * lu[i][col];
                }
            }
empty line
return bp;

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.OpenIntToDoubleHashMap <526, 529>
if (current < 0) {
                throw MathRuntimeException.createNoSuchElementException("iterator exhausted", null);
            }
return keys[current];

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.OpenIntToDoubleHashMap <526, 529>
if (intVar < 0) {
                throw MathRuntimeException.createNoSuchElementException("iterator exhausted", null);
            }
return keys[intVar];

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.OpenIntToDoubleHashMap <544, 547>
if (current < 0) {
                throw MathRuntimeException.createNoSuchElementException("iterator exhausted", null);
            }
return values[current];

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.OpenIntToDoubleHashMap <544, 547>
if (intVar < 0) {
                throw MathRuntimeException.createNoSuchElementException("iterator exhausted", null);
            }
return values[intVar];

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.MultiDirectional <105, 116>
for (int i = 1; i <= n; ++i) {
      double[] xOriginal    = original[i].getPoint();
      double[] xTransformed = new double[n];
      for (int j = 0; j < n; ++j) {
        xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);
      }
      simplex[i] = new PointCostPair(xTransformed, Double.NaN);
    }
empty line
// evaluate it
evaluateSimplex();
return simplex[0].getCost();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.MultiDirectional <105, 116>
for (int i = 1; i <= n; ++i) {
      double[] xOriginal    = original[i].getPoint();
      double[] xTransformed = new double[n];
      for (int j = 0; j < n; ++j) {
        xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);
      }
      simplex[i] = new PointCostPair(xTransformed, Double.NaN);
    }
empty line
// evaluate it
evaluateSimplex();
return simplex[0].getCost();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.PolynomialSplineFunction <166, 169>
for (int intVar = 0; intVar < intVar; intVar++) {
            PolynomialFunction[intVar] = PolynomialFunction[intVar].polynomialDerivative();
        }
return new PolynomialSplineFunction(doubleVar, PolynomialFunction);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.PolynomialSplineFunction <166, 169>
for (int i = 0; i < n; i++) {
            PolynomialFunction[i] = PolynomialFunction[i].polynomialDerivative();
        }
return new PolynomialSplineFunction(knots, PolynomialFunction);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <1100, 1103>
for (int intVar = 0; intVar < BigDecimal.length; intVar++) {
            BigDecimal[intVar] = new BigDecimal(double[]Var[intVar]);
        }
return solve(BigDecimal);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <1100, 1103>
for (int i = 0; i < BigDecimal.length; i++) {
            BigDecimal[i] = new BigDecimal(b[i]);
        }
return solve(BigDecimal);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator <179, 183>
if (manager.reset(stepStart, y) && ! lastStep) {
        // some events handler has triggered changes that
        // invalidate the derivatives, we need to recompute them
        equations.computeDerivatives(stepStart, y, yDotK[0]);
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator <303, 307>
if (manager.reset(stepStart, y) && ! lastStep) {
        // some event handler has triggered changes that
        // invalidate the derivatives, we need to recompute them
        equations.computeDerivatives(stepStart, y, yDotK[0]);
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <190, 194>
throws IllegalArgumentException {
empty line
double scaling_coefficient = 1.0 / f.length;
return scaleArray(fft(f, true), scaling_coefficient);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.special.Beta <197, 204>
if (Double.isNaN(a) || Double.isNaN(b) || (a <= 0.0) || (b <= 0.0)) {
            ret = Double.NaN;
        } else {
            ret = Gamma.logGamma(a) + Gamma.logGamma(b) -
                Gamma.logGamma(a + b);
        }
empty line
return ret;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <504, 507>
for (int intVar = 0; intVar < Complex.length; intVar++) {
            Complex[intVar] = new Complex(doubleVar * Complex[intVar].getReal(), doubleVar * Complex[intVar].getImaginary());
        }
return Complex;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <504, 507>
for (int i = 0; i < Complex.length; i++) {
            Complex[i] = new Complex(d * Complex[i].getReal(), d * Complex[i].getImaginary());
        }
return Complex;

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.CompositeFormat <176, 183>
if ((startIndex >= source.length()) ||
            (endIndex > source.length()) ||
            (source.substring(startIndex, endIndex).compareTo(expected) != 0)) {
            // set index back to start, error index should be the start index
            pos.setIndex(startIndex);
            pos.setErrorIndex(startIndex);
            return false;
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.CompositeFormat <176, 183>
if ((intVar >= StringVar.length()) ||
            (intVar > StringVar.length()) ||
            (StringVar.substring(intVar, intVar).compareTo(StringVar) != 0)) {
            // set index back to start, error index should be the start index
            ParsePosition.setIndex(intVar);
            ParsePosition.setErrorIndex(intVar);
            return false;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.WeibullDistributionImpl <98, 108>
if (p < 0.0 || p > 1.0) {
            throw new IllegalArgumentException
                ("probability argument must be between 0 and 1 (inclusive)");
        } else if (p == 0) {
            ret = 0.0;
        } else  if (p == 1) {
            ret = Double.POSITIVE_INFINITY;
        } else {
            ret = getScale() * Math.pow(-Math.log(1.0 - p), 1.0 / getShape());
        }
return ret;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.AbstractRandomGenerator <94, 96>
if ( intVar > 0) {
                  intVar = intVar >> 8;
              }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.AbstractIntegerDistribution <116, 120>
if (fl == x) {
            return this.probability((int) x);
        } else {
            return 0;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.BinomialDistributionImpl <130, 141>
if (intVar < 0) {
            doubleVar = 0.0;
        } else if (intVar >= getNumberOfTrials()) {
            doubleVar = 1.0;
        } else {
            doubleVar =
                1.0 - Beta.regularizedBeta(
                        getProbabilityOfSuccess(),
                        intVar + 1.0,
                        getNumberOfTrials() - intVar);
        }
return doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.DenseRealMatrix <168, 174>
if (blockData[index].length != iHeight * blockWidth(jBlock)) {
                    throw MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})",
                                                                              new Object[] {
                                                                                  blockData[index].length,
                                                                                  iHeight * blockWidth(jBlock)
                                                                              });
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.MatrixUtils <200, 203>
for (int intVar = 0; intVar < intVar; ++intVar) {
            BigDecimal[][]Var[0][intVar] = new BigDecimal(double[]Var[intVar]);
        }
return new BigMatrixImpl(BigDecimal[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.MatrixUtils <200, 203>
for (int i = 0; i < nCols; ++i) {
            data[0][i] = new BigDecimal(rowData[i]);
        }
return new BigMatrixImpl(data, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.MatrixUtils <234, 237>
for (int intVar = 0; intVar < intVar; ++intVar) {
            BigDecimal[][]Var[0][intVar] = new BigDecimal(String[]Var[intVar]);
        }
return new BigMatrixImpl(BigDecimal[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.MatrixUtils <234, 237>
for (int i = 0; i < nCols; ++i) {
            data[0][i] = new BigDecimal(rowData[i]);
        }
return new BigMatrixImpl(data, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.MatrixUtils <270, 273>
for (int intVar = 0; intVar < intVar; intVar++) {
            BigDecimal[][]Var[intVar][0] = new BigDecimal(double[]Var[intVar]);
        }
return new BigMatrixImpl(BigDecimal[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.MatrixUtils <270, 273>
for (int row = 0; row < nRows; row++) {
            data[row][0] = new BigDecimal(columnData[row]);
        }
return new BigMatrixImpl(data, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.MatrixUtils <306, 309>
for (int intVar = 0; intVar < intVar; intVar++) {
            BigDecimal[][]Var[intVar][0] = new BigDecimal(String[]Var[intVar]);
        }
return new BigMatrixImpl(BigDecimal[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.MatrixUtils <306, 309>
for (int row = 0; row < nRows; row++) {
            data[row][0] = new BigDecimal(columnData[row]);
        }
return new BigMatrixImpl(data, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.RandomDataImpl <576, 579>
for (int intVar = 0; intVar < intVar; intVar++) {
           Object[]Var[intVar] = Object[]Var[int[]Var[intVar]];
       }
return Object[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.RandomDataImpl <576, 579>
for (int i = 0; i < k; i++) {
           result[i] = objects[index[i]];
       }
return result;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <813, 816>
for (int intVar = 0; intVar < intVar; intVar++) {
            BigDecimal[]Var[intVar] = BigDecimal[intVar][intVar];
        }
return BigDecimal[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <813, 816>
for (int i = 0; i < nRows; i++) {
            out[i] = BigDecimal[i][col];
        }
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <87, 96>
for (int intVar = 0; intVar < long[]Var.length; intVar++) {
            if (booleanVar) {
                doubleVar = ((double) long[]Var[intVar] - doubleVar * double[]Var[intVar]);
                doubleVar += doubleVar * doubleVar / (doubleVar * double[]Var[intVar]);
            } else {
                doubleVar = ((double) long[]Var[intVar] - double[]Var[intVar]);
                doubleVar += doubleVar * doubleVar / double[]Var[intVar];
            }
        }
return doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <87, 96>
for (int i = 0; i < observed.length; i++) {
            if (rescale) {
                dev = ((double) observed[i] - ratio * expected[i]);
                sumSq += dev * dev / (ratio * expected[i]);
            } else {
                dev = ((double) observed[i] - expected[i]);
                sumSq += dev * dev / expected[i];
            }
        }
return sumSq;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.StatUtils <613, 618>
for (int intVar = 0; intVar < intVar; intVar++) {
            doubleVar = double[]Var[intVar] - double[]Var[intVar];
            doubleVar += (doubleVar - doubleVar) *(doubleVar - doubleVar);
            doubleVar += doubleVar - doubleVar;
        }
return (doubleVar - (doubleVar * doubleVar / (double) intVar)) / (double) (intVar - 1);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.StatUtils <613, 618>
for (int i = 0; i < n; i++) {
            diff = sample1[i] - sample2[i];
            sum1 += (diff - meanDifference) *(diff - meanDifference);
            sum2 += diff - meanDifference;
        }
return (sum1 - (sum2 * sum2 / (double) n)) / (double) (n - 1);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.complex.ComplexFormat <188, 197>
if (obj instanceof Complex) {
            ret = format( (Complex)obj, toAppendTo, pos);
        } else if (obj instanceof Number) {
            ret = format( new Complex(((Number)obj).doubleValue(), 0.0),
                toAppendTo, pos);
        } else { 
            throw new IllegalArgumentException("Cannot format given Object as a Complex");
        }
empty line
return ret;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.OneWayAnovaImpl <84, 86>
AnovaStats a = anovaStats(categoryData);
FDistribution fdist = new FDistributionImpl(a.dfbg, a.dfwg);
return 1.0 - fdist.cumulativeProbability(a.F);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.NelderMead <98, 115>
if (costR < smallest) {

      // compute the expansion point
      double[] xE = new double[n];
      for (int j = 0; j < n; ++j) {
        xE[j] = centroid[j] + khi * (xR[j] - centroid[j]);
      }
      double costE = evaluateCost(xE);

      if (costE < costR) {
        // accept the expansion point
        replaceWorstPoint(new PointCostPair(xE, costE));
      } else {
        // accept the reflected point
        replaceWorstPoint(new PointCostPair(xR, costR));
      }

    } else {

      if (costR < largest) {

        // perform an outside contraction
        double[] xC = new double[n];
        for (int j = 0; j < n; ++j) {
          xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]);
        }
        double costC = evaluateCost(xC);

        if (costC <= costR) {
          // accept the contraction point
          replaceWorstPoint(new PointCostPair(xC, costC));
          return;
        }

      } else {

        // perform an inside contraction
        double[] xC = new double[n];
        for (int j = 0; j < n; ++j) {
          xC[j] = centroid[j] - gamma * (centroid[j] - xLargest[j]);
        }
        double costC = evaluateCost(xC);

        if (costC < largest) {
          // accept the contraction point
          replaceWorstPoint(new PointCostPair(xC, costC));
          return;
        }

      }

      // perform a shrink
      double[] xSmallest = simplex[0].getPoint();
      for (int i = 1; i < simplex.length; ++i) {
        double[] x = simplex[i].getPoint();
        for (int j = 0; j < n; ++j) {
          x[j] = xSmallest[j] + sigma * (x[j] - xSmallest[j]);
        }
        simplex[i] = new PointCostPair(x, Double.NaN);
      }
      evaluateSimplex();

    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.NelderMead <98, 115>
if (doubleVar < doubleVar) {

      // compute the expansion point
      double[] xE = new double[intVar];
      for (int intVar = 0; intVar < intVar; ++intVar) {
        xE[intVar] = double[]Var[intVar] + doubleVar * (double[]Var[intVar] - double[]Var[intVar]);
      }
      double costE = evaluateCost(xE);

      if (costE < doubleVar) {
        // accept the expansion point
        replaceWorstPoint(new PointCostPair(xE, costE));
      } else {
        // accept the reflected point
        replaceWorstPoint(new PointCostPair(double[]Var, doubleVar));
      }

    } else {

      if (doubleVar < doubleVar) {

        // perform an outside contraction
        double[] xC = new double[intVar];
        for (int intVar = 0; intVar < intVar; ++intVar) {
          xC[intVar] = double[]Var[intVar] + doubleVar * (double[]Var[intVar] - double[]Var[intVar]);
        }
        double costC = evaluateCost(xC);

        if (costC <= doubleVar) {
          // accept the contraction point
          replaceWorstPoint(new PointCostPair(xC, costC));
          return;
        }

      } else {

        // perform an inside contraction
        double[] xC = new double[intVar];
        for (int intVar = 0; intVar < intVar; ++intVar) {
          xC[intVar] = double[]Var[intVar] - doubleVar * (double[]Var[intVar] - double[]Var[intVar]);
        }
        double costC = evaluateCost(xC);

        if (costC < doubleVar) {
          // accept the contraction point
          replaceWorstPoint(new PointCostPair(xC, costC));
          return;
        }

      }

      // perform a shrink
      double[] xSmallest = PointCostPair[]Var[0].getPoint();
      for (int intVar = 1; intVar < PointCostPair[]Var.length; ++intVar) {
        double[] x = PointCostPair[]Var[intVar].getPoint();
        for (int intVar = 0; intVar < intVar; ++intVar) {
          x[intVar] = xSmallest[intVar] + doubleVar * (x[intVar] - xSmallest[intVar]);
        }
        PointCostPair[]Var[intVar] = new PointCostPair(x, Double.NaN);
      }
      evaluateSimplex();

    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.NelderMead <98, 115>
if (costR < smallest) {

      // compute the expansion point
      double[] xE = new double[n];
      for (int j = 0; j < n; ++j) {
        xE[j] = centroid[j] + khi * (xR[j] - centroid[j]);
      }
      double costE = evaluateCost(xE);

      if (costE < costR) {
        // accept the expansion point
        replaceWorstPoint(new PointCostPair(xE, costE));
      } else {
        // accept the reflected point
        replaceWorstPoint(new PointCostPair(xR, costR));
      }

    } else {

      if (costR < largest) {

        // perform an outside contraction
        double[] xC = new double[n];
        for (int j = 0; j < n; ++j) {
          xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]);
        }
        double costC = evaluateCost(xC);

        if (costC <= costR) {
          // accept the contraction point
          replaceWorstPoint(new PointCostPair(xC, costC));
          return;
        }

      } else {

        // perform an inside contraction
        double[] xC = new double[n];
        for (int j = 0; j < n; ++j) {
          xC[j] = centroid[j] - gamma * (centroid[j] - xLargest[j]);
        }
        double costC = evaluateCost(xC);

        if (costC < largest) {
          // accept the contraction point
          replaceWorstPoint(new PointCostPair(xC, costC));
          return;
        }

      }

      // perform a shrink
      double[] xSmallest = simplex[0].getPoint();
      for (int i = 1; i < simplex.length; ++i) {
        double[] x = simplex[i].getPoint();
        for (int j = 0; j < n; ++j) {
          x[j] = xSmallest[j] + sigma * (x[j] - xSmallest[j]);
        }
        simplex[i] = new PointCostPair(x, Double.NaN);
      }
      evaluateSimplex();

    }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.ResizableDoubleArray <744, 748>
if (intVar < 0) {
            String msg =
                "Number of elements must be zero or a positive " + "integer";
            throw new IllegalArgumentException(msg);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastSineTransformer <167, 169>
data[0] = 0.0;
double scaling_coefficient = 2.0 / n;
return FastFourierTransformer.scaleArray(fst(data), scaling_coefficient);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <625, 630>
if (selectedRows.length * selectedColumns.length == 0) {
            if (selectedRows.length == 0) {
                throw new MatrixIndexException("empty selected row index array", null);
            }
            throw new MatrixIndexException("empty selected column index array", null);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <1173, 1178>
if (selectedRows.length * selectedColumns.length == 0) {
            if (selectedRows.length == 0) {
                throw new MatrixIndexException("empty selected row index array", null);
            }
            throw new MatrixIndexException("empty selected column index array", null);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <793, 796>
for (int intVar=0;intVar<intVar;intVar++) {
            double[]Var[intVar] = BigDecimal[intVar][intVar].doubleValue();
        }
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <793, 796>
for (int i=0;i<ncols;i++) {
            out[i] = BigDecimal[row][i].doubleValue();
        }
return out;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <834, 837>
for (int intVar=0;intVar<intVar;intVar++) {
            double[]Var[intVar] = BigDecimal[intVar][intVar].doubleValue();
        }
return double[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <834, 837>
for (int i=0;i<nrows;i++) {
            out[i] = BigDecimal[i][col].doubleValue();
        }
return out;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.OpenIntToDoubleHashMap <406, 410>
if (intVar < 0) {
            intVar = changeIndexSign(intVar);
            doubleVar = double[]Var[intVar];
            booleanVar = false;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <754, 757>
for (int row = 0; row < nRows; row++) {
            out[row][0] = data[row][column];
        }
return new BigMatrixImpl(out, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <754, 757>
for (int intVar = 0; intVar < intVar; intVar++) {
            BigDecimal[][]Var[intVar][0] = BigDecimal[intVar][intVar];
        }
return new BigMatrixImpl(BigDecimal[][]Var, false);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <754, 757>
for (int row = 0; row < nRows; row++) {
            out[row][0] = BigDecimal[row][column];
        }
return new BigMatrixImpl(out, false);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.AbstractIntegerDistribution <192, 197>
while (pm > p) {
            --x0;
            pm = cumulativeProbability(x0);
        }
empty line
return x0;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <186, 188>
double df = ((double) counts.length -1) * ((double) counts[0].length - 1);
distribution.setDegreesOfFreedom(df);
return 1 - distribution.cumulativeProbability(chiSquare(counts));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastHadamardTransformer <61, 65>
throws FunctionEvaluationException, IllegalArgumentException {
final double[] unscaled =
            fht(FastFourierTransformer.sample(f, min, max, n));
return FastFourierTransformer.scaleArray(unscaled, 1.0 / n);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <121, 132>
if (n == 0) {
            xbar = x;
            ybar = y;
        } else {
            double dx = x - xbar;
            double dy = y - ybar;
            sumXX += dx * dx * (double) n / (double) (n + 1.0);
            sumYY += dy * dy * (double) n / (double) (n + 1.0);
            sumXY += dx * dy * (double) n / (double) (n + 1.0);
            xbar += dx / (double) (n + 1.0);
            ybar += dy / (double) (n + 1.0);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.TTestImpl <122, 127>
throws IllegalArgumentException, MathException {
double meanDifference = StatUtils.meanDifference(sample1, sample2);
return tTest(meanDifference, 0, 
                StatUtils.varianceDifference(sample1, sample2, meanDifference), 
                (double) sample1.length);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.ContinuousOutputModel <339, 347>
if (forward) {
      if (time < interval.getPreviousTime()) {
        return -1;
      } else if (time > interval.getCurrentTime()) {
        return +1;
      } else {
        return 0;
      }
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.Fraction <238, 243>
if (numerator >= 0) {
            ret = this;
        } else {
            ret = negate();
        }
return ret;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.fraction.Fraction <238, 243>
if (intVar >= 0) {
            Number = this;
        } else {
            Number = negate();
        }
return Number;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.Frequency <248, 250>
if (getSumFreq() == 0) {
            return Double.NaN;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.Frequency <389, 391>
if (getSumFreq() == 0) {
            return Double.NaN;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <329, 338>
for (int i = 1; i < N; i++) {
            Complex A = z[N-i].conjugate();
            Complex B = z[i].add(A);
            Complex C = z[i].subtract(A);
            Complex D = omega[i].multiply(Complex.I);
            F[i] = B.subtract(C.multiply(D));
            F[2*N-i] = F[i].conjugate();
        }
empty line
return scaleArray(F, 0.5);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.BrentSolver <262, 272>
if (x0 == x2) {
                    // Linear interpolation.
                    p = dx * r3;
                    p1 = 1.0 - r3;
                } else {
                    // Inverse quadratic interpolation.
                    double r1 = y0 / y2;
                    double r2 = y1 / y2;
                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));
                    p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <941, 946>
if (double[]Var[intVar + 2] <= doubleVar * doubleVar) {
                    double[]Var[intVar + 2] = -0.0;
                    doubleVar = double[]Var[intVar];
                } else {
                    doubleVar *= double[]Var[intVar] / (doubleVar + double[]Var[intVar + 2]);
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.BinomialDistributionImpl <152, 161>
if (intVar < 0 || intVar > getNumberOfTrials()) {
            doubleVar = 0.0;
        } else {
            doubleVar = MathUtils.binomialCoefficientDouble(
                    getNumberOfTrials(), intVar) *
                  Math.pow(getProbabilityOfSuccess(), intVar) *
                  Math.pow(1.0 - getProbabilityOfSuccess(),
                        getNumberOfTrials() - intVar);
        }
return doubleVar;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.PascalDistributionImpl <130, 136>
if (intVar < 0) {
            doubleVar = 0.0;
        } else {
            doubleVar = Beta.regularizedBeta(getProbabilityOfSuccess(),
                getNumberOfSuccesses(), intVar + 1);
        }
return doubleVar;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <174, 176>
computeOmega(f.length);
double scaling_coefficient = 1.0 / Math.sqrt(f.length);
return scaleArray(fft(f), scaling_coefficient);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.ContinuedFraction <172, 178>
if (n >= maxIterations) {
            throw new MaxIterationsExceededException(maxIterations,
                "Continued fraction convergents failed to converge for value {0}",
                new Object[] { Double.valueOf(x) });
        }
empty line
return c;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <292, 294>
computeOmega(-f.length);
double scaling_coefficient = 1.0 / Math.sqrt(f.length);
return scaleArray(fft(f), scaling_coefficient);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <249, 258>
for (int intVar = 1; intVar < intVar; ++intVar) {
            int[][]Var[intVar] = new int[intVar + 1];
            int[][]Var[intVar][0] = 1;
            for (int j = 0; j < intVar - 1; ++j) {
                int[][]Var[intVar][j + 1] = int[][]Var[intVar - 1][j + 1] - int[][]Var[intVar - 1][j];
            }
            int[][]Var[intVar][intVar] = -int[][]Var[intVar - 1][intVar - 1];
        }
empty line
return int[][]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator <249, 258>
for (int i = 1; i < order; ++i) {
            bdArray[i] = new int[i + 1];
            bdArray[i][0] = 1;
            for (int j = 0; j < i - 1; ++j) {
                bdArray[i][j + 1] = bdArray[i - 1][j + 1] - bdArray[i - 1][j];
            }
            bdArray[i][i] = -bdArray[i - 1][i - 1];
        }
empty line
return bdArray;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <792, 796>
if (int[]Var[intVar] < int[]Var[intVar]) {
                        break;
                    } else {
                        int[]Var[intVar] = 0;
                    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.geometry.Rotation <128, 135>
if (needsNormalization) {
      // normalization preprocessing
      double inv = 1.0 / Math.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
      q0 *= inv;
      q1 *= inv;
      q2 *= inv;
      q3 *= inv;
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <273, 284>
if (mu > 2) {
            final double ph3 = 6 * (bspl - aspl);
            polynoms[7][i] = 16 * (yMidDots[3][i] - ph3 + 3 * polynoms[5][i]);

            for (int j = 4; j <= mu; ++j) {
              final double fac1 = 0.5 * j * (j - 1);
              final double fac2 = 2 * fac1 * (j - 2) * (j - 3);
              polynoms[j+4][i] =
                  16 * (yMidDots[j][i] + fac1 * polynoms[j+2][i] - fac2 * polynoms[j][i]);
            }

          }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.rank.Percentile <129, 132>
/**
     * Returns an estimate of the <code>p</code>th percentile of the values
     * in the <code>values</code> array.
     * <p>
     * Calls to this method do not modify the internal <code>quantile</code>
     * state of this statistic.</p>
     * <p>
     * <ul>
     * <li>Returns <code>Double.NaN</code> if <code>values</code> has length 
     * <code>0</code></li>
     * <li>Returns (for any value of <code>p</code>) <code>values[0]</code>
     *  if <code>values</code> has length <code>1</code></li>
     * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>
     * is null or p is not a valid quantile value (p must be greater than 0
     * and less than or equal to 100) </li>
     * </ul></p>
     * <p>
     * See {@link Percentile} for a description of the percentile estimation
     * algorithm used.</p>
     * 
     * @param values input array of values
     * @param p the percentile value to compute
     * @return the percentile value or Double.NaN if the array is empty
     * @throws IllegalArgumentException if <code>values</code> is null 
     *     or p is invalid
     */
    public double evaluate(final double[] values, final double p) {
        test(values, 0, 0);
        return evaluate(values, 0, values.length, p);
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <340, 344>
if (sigma <= 0) {
            throw new IllegalArgumentException("Gaussian std dev must be > 0");
        }
RandomGenerator rand = getRan();
return sigma * rand.nextGaussian() + mu;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Variance <209, 212>
if (values == null) {
            throw new IllegalArgumentException("input values array is null");
        }
return evaluate(values, 0, values.length);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic <59, 62>
if (values == null) {
            throw new IllegalArgumentException("input value array is null");
        }
return evaluate(values, 0, values.length);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.events.CombinedEventsManager <139, 151>
if (! initialized) {

                // initialize the events states
                final double t0 = interpolator.getPreviousTime();
                interpolator.setInterpolatedTime(t0);
                final double [] y = interpolator.getInterpolatedState();
                for (EventState state : states) {
                    state.reinitializeBegin(t0, y);
                }

                initialized = true;

            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <233, 235>
computeOmega(-f.length);
double scaling_coefficient = 1.0 / f.length;
return scaleArray(fft(f), scaling_coefficient);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.CompositeFormat <121, 128>
if (endIndex < source.length()) {
            if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {
                ret = Double.valueOf(value);
                pos.setIndex(endIndex);
            }
        }
empty line
return ret;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.CompositeFormat <121, 128>
if (intVar < StringVar.length()) {
            if (StringVar.substring(intVar, intVar).compareTo(StringBuffer.toString()) == 0) {
                Number = Double.valueOf(doubleVar);
                ParsePosition.setIndex(intVar);
            }
        }
empty line
return Number;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <112, 116>
throws IllegalArgumentException, MathException {
distribution.setDegreesOfFreedom(expected.length - 1.0);
return 1.0 - distribution.cumulativeProbability(
            chiSquare(expected, observed));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <567, 573>
if (denseOutput || (! eventsHandlersManager.isEmpty())) {
      interpolator = new GraggBulirschStoerStepInterpolator(y, yDot0,
                                                            y1, yDot1,
                                                            yMidDots, forward);
    } else {
      interpolator = new DummyStepInterpolator(y, forward);
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.complex.Complex <823, 826>
double imaginary2 = 2.0 * imaginary;
double d = Math.cos(real2) + MathUtils.cosh(imaginary2);
empty line
return createComplex(Math.sin(real2) / d, MathUtils.sinh(imaginary2) / d);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.complex.Complex <861, 864>
double imaginary2 = 2.0 * imaginary;
double d = MathUtils.cosh(real2) + Math.cos(imaginary2);
empty line
return createComplex(MathUtils.sinh(real2) / d, Math.sin(imaginary2) / d);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.RandomDataImpl <594, 598>
if (intVar == 0) {
                intVar = 0;
            } else {
                intVar = nextInt(0, intVar);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <237, 240>
if (countSum1 * countSum2 == 0) {
            throw new IllegalArgumentException(
             "observed counts cannot all be 0"); 
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.SimpsonIntegrator <103, 107>
if (maximalIterationCount > 64) {
            throw new IllegalArgumentException
                ("Iteration upper limit out of [0, 64] range: " +
                maximalIterationCount);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.RombergIntegrator <104, 108>
if (maximalIterationCount > 32) {
            throw new IllegalArgumentException
                ("Iteration upper limit out of [0, 32] range: " +
                maximalIterationCount);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.TrapezoidIntegrator <134, 138>
if (maximalIterationCount > 64) {
            throw new IllegalArgumentException
                ("Iteration upper limit out of [0, 64] range: " +
                maximalIterationCount);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.UnivariateRealSolverUtils <174, 177>
if (maximumIterations <= 0)  {
            throw new IllegalArgumentException
            ("bad value for maximumIterations: " + maximumIterations);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.UnivariateRealSolverUtils <174, 177>
if (intVar <= 0)  {
            throw new IllegalArgumentException
            ("bad value for maximumIterations: " + intVar);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SparseRealMatrix <171, 175>
if (value == 0.0) {
            entries.remove(computeKey(row, column));
        } else {
            entries.put(computeKey(row, column), value);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <171, 173>
RandomGenerator rand = getRan();
double r = rand.nextDouble();
return (int)((r * upper) + ((1.0 - r) * lower) + r);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.RandomDataImpl <171, 173>
RandomGenerator RandomGenerator = getRan();
double doubleVar = RandomGenerator.nextDouble();
return (int)((doubleVar * intVar) + ((1.0 - doubleVar) * intVar) + doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.RandomDataImpl <171, 173>
RandomGenerator RandomGenerator = getRan();
double r = RandomGenerator.nextDouble();
return (int)((r * upper) + ((1.0 - r) * lower) + r);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <189, 191>
RandomGenerator rand = getRan();
double r = rand.nextDouble();
return (long)((r * upper) + ((1.0 - r) * lower) + r);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics <612, 615>
if (n > 0) {
            throw MathRuntimeException.createIllegalStateException("{0} values have been added before statistic is configured",
                                                                   new Object[] { n });
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.SummaryStatistics <612, 615>
if (n > 0) {
            throw MathRuntimeException.createIllegalStateException("{0} values have been added before statistic is configured",
                                                                   new Object[] { n });
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <395, 397>
if (long[][]Var[intVar][intVar] < 0) {
                    return false;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.ZipfDistributionImpl <102, 105>
if (s <= 0.0) {
            throw MathRuntimeException.createIllegalArgumentException("invalid exponent {0} (must be positive)",
                                                                      new Object[] { s });
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.ProperFractionFormat <166, 170>
if (num.intValue() < 0) {
            // minus signs should be leading, invalid expression
            pos.setIndex(initialIndex);
            return null;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.fraction.ProperFractionFormat <166, 170>
if (Number.intValue() < 0) {
            // minus signs should be leading, invalid expression
            ParsePosition.setIndex(initialIndex);
            return null;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.ProperFractionFormat <205, 209>
if (den.intValue() < 0) {
            // minus signs must be leading, invalid
            pos.setIndex(initialIndex);
            return null;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.fraction.ProperFractionFormat <205, 209>
if (Number.intValue() < 0) {
            // minus signs must be leading, invalid
            ParsePosition.setIndex(initialIndex);
            return null;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <702, 705>
if (row > 0) {
                throw MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet",
                                                                       new Object[] { row });
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <702, 705>
if (intVar > 0) {
                throw MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet",
                                                                       new Object[] { intVar });
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <310, 313>
if (row > 0) {
                throw MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet",
                                                                       new Object[] { row });
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <310, 313>
if (intVar > 0) {
                throw MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet",
                                                                       new Object[] { intVar });
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.RealMatrixImpl <314, 317>
if (column > 0) {
                throw MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet",
                                                                       new Object[] { column });
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.RealMatrixImpl <314, 317>
if (intVar > 0) {
                throw MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet",
                                                                       new Object[] { intVar });
            }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.ResizableDoubleArray <668, 671>
if (index < 0) {
            throw MathRuntimeException.createArrayIndexOutOfBoundsException("cannot set an element at a negative index {0}",
                                                                            new Object[] { index });
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.ResizableDoubleArray <668, 671>
if (intVar < 0) {
            throw MathRuntimeException.createArrayIndexOutOfBoundsException("cannot set an element at a negative index {0}",
                                                                            new Object[] { intVar });
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.complex.Complex <907, 910>
if (n <= 0) {
            throw MathRuntimeException.createIllegalArgumentException("cannot compute nth root for null or negative n: {0}",
                    new Object[] { n });
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.complex.Complex <907, 910>
if (intVar <= 0) {
            throw MathRuntimeException.createIllegalArgumentException("cannot compute nth root for null or negative n: {0}",
                    new Object[] { intVar });
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <466, 469>
if (n <= 0) {
            throw MathRuntimeException.createIllegalArgumentException("number of sample is not positive: {0}",
                                                                      new Object[] { n });
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <466, 469>
if (intVar <= 0) {
            throw MathRuntimeException.createIllegalArgumentException("number of sample is not positive: {0}",
                                                                      new Object[] { intVar });
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <737, 739>
final BigDecimal[][] out = new BigDecimal[1][ncols];
System.arraycopy(data[row], 0, out[0], 0, ncols);
return new BigMatrixImpl(out, false);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <737, 739>
final BigDecimal[][] BigDecimal[][]Var = new BigDecimal[1][intVar];
System.arraycopy(BigDecimal[intVar], 0, BigDecimal[][]Var[0], 0, intVar);
return new BigMatrixImpl(BigDecimal[][]Var, false);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1106, 1111>
if (Double.isNaN(dMin)) {
                    tau = 0.0;
                } else {
                    // possible underflow. Play it safe.
                    loop = false;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.ContinuousOutputModel <348, 354>
if (time > interval.getPreviousTime()) {
      return -1;
    } else if (time < interval.getCurrentTime()) {
      return +1;
    } else {
      return 0;
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.Fraction <457, 463>
if (w.bitLength() > 31) {
            throw MathRuntimeException.createArithmeticException("overflow, numerator too large after multiply: {0}",
                                                                 new Object[] { w });
        }
return new Fraction (w.intValue(), 
                MathUtils.mulAndCheck(denominator/d1, 
                        fraction.denominator/d2));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <763, 766>
if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {
            throw new EstimationException("unable to perform Q.R decomposition on the {0}x{1} jacobian matrix",
                                          new Object[] { Integer.valueOf(rows), Integer.valueOf(cols) });
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <1246, 1257>
if (max != col) {
                BigDecimal tmp = BigDecimal;
                for (int i = 0; i < nCols; i++) {
                    tmp = BigDecimal[max][i];
                    BigDecimal[max][i] = BigDecimal[col][i];
                    BigDecimal[col][i] = tmp;
                }
                int temp = permutation[max];
                permutation[max] = permutation[col];
                permutation[col] = temp;
                parity = -parity;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.LUDecompositionImpl <139, 150>
if (max != col) {
                double tmp = 0;
                for (int i = 0; i < m; i++) {
                    tmp = lu[max][i];
                    lu[max][i] = lu[col][i];
                    lu[col][i] = tmp;
                }
                int temp = pivot[max];
                pivot[max] = pivot[col];
                pivot[col] = temp;
                even = !even;
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.LUDecompositionImpl <139, 150>
if (max != col) {
                double tmp = 0;
                for (int i = 0; i < m; i++) {
                    tmp = lu[max][i];
                    lu[max][i] = lu[col][i];
                    lu[col][i] = tmp;
                }
                int temp = pivot[max];
                pivot[max] = pivot[col];
                pivot[col] = temp;
                even = !even;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.rank.Percentile <215, 217>
if (pos < 1) {
            return sorted[0];
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <360, 362>
if (double[]Var[intVar] <= 0) {
                return false;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.inference.ChiSquareTestImpl <377, 379>
if (long[]Var[intVar] < 0) {
                return false;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.SplineInterpolator <107, 115>
for (int intVar = 0; intVar < intVar; intVar++) {
            doubleVar[0] = doubleVar[intVar];
            doubleVar[1] = doubleVar[intVar];
            doubleVar[2] = doubleVar[intVar];
            doubleVar[3] = doubleVar[intVar];
            PolynomialFunction[intVar] = new PolynomialFunction(doubleVar);
        }
empty line
return new PolynomialSplineFunction(doubleVar, PolynomialFunction);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.SplineInterpolator <107, 115>
for (int i = 0; i < n; i++) {
            coefficients[0] = y[i];
            coefficients[1] = b[i];
            coefficients[2] = c[i];
            coefficients[3] = d[i];
            PolynomialFunction[i] = new PolynomialFunction(coefficients);
        }
empty line
return new PolynomialSplineFunction(x, PolynomialFunction);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <868, 871>
if (double[]Var[intVar + 2] <= 0) {
                    intVar = 1 + intVar / 4;
                    break;
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator <263, 265>
if ((intVar <= 6) || (intVar % 2 != 0)) {
      AdaptiveStepsizeIntegrator.intVar = 18;
    }

