---patch code 0--- org.apache.commons.math3.util.FastMath <465, 471>
if (doubleVar >= doubleVar) {
              // Avoid overflow (MATH-905).
              final double t = exp(0.5 * doubleVar);
              return (0.5 * t) * t;
          } else {
              return 0.5 * exp(doubleVar);
          }

---fix ingredient  <parseContainCheck2>  varMapType:0--- org.apache.commons.math3.distribution.GammaDistribution <197, 255>
/** {@inheritDoc} */
    public double density(double x) {
       /* The present method must return the value of
        *
        *     1       x a     - x
        * ---------- (-)  exp(---)
        * x Gamma(a)  b        b
        *
        * where a is the shape parameter, and b the scale parameter.
        * Substituting the Lanczos approximation of Gamma(a) leads to the
        * following expression of the density
        *
        * a              e            1         y      a
        * - sqrt(------------------) ---- (-----------)  exp(a - y + g),
        * x      2 pi (a + g + 0.5)  L(a)  a + g + 0.5
        *
        * where y = x / b. The above formula is the "natural" computation, which
        * is implemented when no overflow is likely to occur. If overflow occurs
        * with the natural computation, the following identity is used. It is
        * based on the BOOST library
        * http://www.boost.org/doc/libs/1_35_0/libs/math/doc/sf_and_dist/html/math_toolkit/special/sf_gamma/igamma.html
        * Formula (15) needs adaptations, which are detailed below.
        *
        *       y      a
        * (-----------)  exp(a - y + g)
        *  a + g + 0.5
        *                              y - a - g - 0.5    y (g + 0.5)
        *               = exp(a log1pm(---------------) - ----------- + g),
        *                                a + g + 0.5      a + g + 0.5
        *
        *  where log1pm(z) = log(1 + z) - z. Therefore, the value to be
        *  returned is
        *
        * a              e            1
        * - sqrt(------------------) ----
        * x      2 pi (a + g + 0.5)  L(a)
        *                              y - a - g - 0.5    y (g + 0.5)
        *               * exp(a log1pm(---------------) - ----------- + g).
        *                                a + g + 0.5      a + g + 0.5
        */
        if (doubleVar < 0) {
            return 0;
        }
        final double y = doubleVar / doubleVar;
        if ((y <= doubleVar) || (FastMath.log(y) >= doubleVar)) {
            /*
             * Overflow.
             */
            final double aux1 = (y - doubleVar) / doubleVar;
            final double aux2 = doubleVar * (FastMath.log1p(aux1) - aux1);
            final double aux3 = -y * (Gamma.LANCZOS_G + 0.5) / doubleVar +
                    Gamma.LANCZOS_G + aux2;
            return doubleVar / doubleVar * FastMath.exp(aux3);
        }
        /*
         * Natural calculation.
         */
        return doubleVar  * FastMath.exp(-y) *
                FastMath.pow(y, doubleVar - 1);
    }

---fix ingredient  varMapType:0--- org.apache.commons.math3.distribution.UniformRealDistribution <116, 124>
/** {@inheritDoc} */
    public double cumulativeProbability(double x)  {
        if (doubleVar <= doubleVar) {
            return 0;
        }
        if (doubleVar >= doubleVar) {
            return 1;
        }
        return (doubleVar - doubleVar) / (doubleVar - doubleVar);
    }

---fix ingredient  varMapType:0--- org.apache.commons.math3.distribution.UniformRealDistribution <116, 124>
/** {@inheritDoc} */
    public double cumulativeProbability(double x)  {
        if (doubleVar <= doubleVar) {
            return 0;
        }
        if (doubleVar >= doubleVar) {
            return 1;
        }
        return (doubleVar - doubleVar) / (doubleVar - doubleVar);
    }

---fix ingredient  varMapType:0--- org.apache.commons.math3.special.Gamma <509, 524>
if (doubleVar > 0 && doubleVar <= doubleVar) {
            // use method 5 from Bernardo AS103
            // accurate to O(x)
            return -doubleVar - 1 / doubleVar;
        }
empty line
if (doubleVar >= doubleVar) {
            // use method 4 (accurate to O(1/x^8)
            double inv = 1 / (doubleVar * doubleVar);
            //            1       1        1         1
            // log(x) -  --- - ------ + ------- - -------
            //           2 x   12 x^2   120 x^4   252 x^6
            return FastMath.log(doubleVar) - 0.5 / doubleVar - inv * ((1.0 / 12) + inv * (1.0 / 120 - inv / 252));
        }
empty line
return digamma(doubleVar + 1) - 1 / doubleVar;

---fix ingredient  varMapType:0--- org.apache.commons.math3.special.Gamma <509, 524>
if (doubleVar > 0 && doubleVar <= doubleVar) {
            // use method 5 from Bernardo AS103
            // accurate to O(x)
            return -doubleVar - 1 / doubleVar;
        }
empty line
if (doubleVar >= doubleVar) {
            // use method 4 (accurate to O(1/x^8)
            double inv = 1 / (doubleVar * doubleVar);
            //            1       1        1         1
            // log(x) -  --- - ------ + ------- - -------
            //           2 x   12 x^2   120 x^4   252 x^6
            return FastMath.log(doubleVar) - 0.5 / doubleVar - inv * ((1.0 / 12) + inv * (1.0 / 120 - inv / 252));
        }
empty line
return digamma(doubleVar + 1) - 1 / doubleVar;

