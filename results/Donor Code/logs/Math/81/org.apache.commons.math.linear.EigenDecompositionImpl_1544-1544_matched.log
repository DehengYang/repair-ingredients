---patch code ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1544, 1562>
if (end - start > 3) {
                    b2 = work[nn - 13] / work[nn - 15];
                    a2 = a2 + b2;
                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4]  >  work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                }

---fix ingredient(SameMethod)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1543, 1561>
if (end - start > 2) {
                    b2 = work[nn - 13] / work[nn - 15];
                    a2 = a2 + b2;
                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4]  >  work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                }

---patch code 0--- org.apache.commons.math.linear.EigenDecompositionImpl <1544, 1562>
if (intVar - intVar > 3) {
                    doubleVar = double[]Var[intVar - 13] / double[]Var[intVar - 15];
                    doubleVar = doubleVar + doubleVar;
                    for (int i4 = intVar - 17; i4 >= 4 * intVar + 2 + intVar; i4 -= 4) {
                        if (doubleVar == 0.0) {
                            break;
                        }
                        doubleVar = doubleVar;
                        if (double[]Var[i4]  >  double[]Var[i4 - 2]) {
                            return;
                        }
                        doubleVar = doubleVar * (double[]Var[i4] / double[]Var[i4 - 2]);
                        doubleVar = doubleVar + doubleVar;
                        if (100 * Math.max(doubleVar, doubleVar) < doubleVar || doubleVar < doubleVar)  {
                            break;
                        }
                    }
                    doubleVar = doubleVar * doubleVar;
                }

---fix ingredient(SameMethod)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <1543, 1561>
if (intVar - intVar > 2) {
                    doubleVar = double[]Var[intVar - 13] / double[]Var[intVar - 15];
                    doubleVar = doubleVar + doubleVar;
                    for (int i4 = intVar - 17; i4 >= 4 * intVar + 2 + intVar; i4 -= 4) {
                        if (doubleVar == 0.0) {
                            break;
                        }
                        doubleVar = doubleVar;
                        if (double[]Var[i4]  >  double[]Var[i4 - 2]) {
                            return;
                        }
                        doubleVar = doubleVar * (double[]Var[i4] / double[]Var[i4 - 2]);
                        doubleVar = doubleVar + doubleVar;
                        if (100 * Math.max(doubleVar, doubleVar) < doubleVar || doubleVar < doubleVar)  {
                            break;
                        }
                    }
                    doubleVar = doubleVar * doubleVar;
                }

---patch code 1--- org.apache.commons.math.linear.EigenDecompositionImpl <1544, 1562>
if (end - start > 3) {
                    b2 = work[nn - 13] / work[nn - 15];
                    a2 = a2 + b2;
                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4]  >  work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                }

---fix ingredient(SameMethod)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1543, 1561>
if (end - start > 2) {
                    b2 = work[nn - 13] / work[nn - 15];
                    a2 = a2 + b2;
                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4]  >  work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                }

---fix ingredient(SameMethod)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1502, 1523>
a2 = a2 + b2;
for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if(b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4]  >  work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
a2 = cnst3 * a2;
empty line
// rayleigh quotient residual bound.
if (a2 < cnst1) {
                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                    }
tau = s;

---fix ingredient(SameMethod)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1502, 1523>
a2 = a2 + b2;
for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if(b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4]  >  work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
a2 = cnst3 * a2;
empty line
// rayleigh quotient residual bound.
if (a2 < cnst1) {
                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                    }
tau = s;

---fix ingredient(SameMethod)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1502, 1523>
a2 = a2 + b2;
for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if(b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4]  >  work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
a2 = cnst3 * a2;
empty line
// rayleigh quotient residual bound.
if (a2 < cnst1) {
                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                    }
tau = s;

---fix ingredient(SameMethod)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1502, 1523>
a2 = a2 + b2;
for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if(b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4]  >  work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
a2 = cnst3 * a2;
empty line
// rayleigh quotient residual bound.
if (a2 < cnst1) {
                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                    }
tau = s;

---fix ingredient(SameMethod)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1458, 1471>
if (gap1 > 0.0 && gap1 > b1) {
                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);
                        tType = -2;
                    } else {
                        double s = 0.0;
                        if (dN > b1) {
                            s = dN - b1;
                        }
                        if (a2 > (b1 + b2)) {
                            s = Math.min(s, a2 - (b1 + b2));
                        }
                        tau   = Math.max(s, 0.333 * dMin);
                        tType = -3;
                    }

---fix ingredient(SameMethod)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <1458, 1471>
if (doubleVar > 0.0 && doubleVar > doubleVar) {
                        doubleVar   = Math.max(doubleVar - (doubleVar / doubleVar) * doubleVar, 0.5 * doubleVar);
                        intVar = -2;
                    } else {
                        double s = 0.0;
                        if (doubleVar > doubleVar) {
                            s = doubleVar - doubleVar;
                        }
                        if (doubleVar > (doubleVar + doubleVar)) {
                            s = Math.min(s, doubleVar - (doubleVar + doubleVar));
                        }
                        doubleVar   = Math.max(s, 0.333 * doubleVar);
                        intVar = -3;
                    }

---fix ingredient(SameMethod)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1458, 1471>
if (gap1 > 0.0 && gap1 > b1) {
                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);
                        tType = -2;
                    } else {
                        double s = 0.0;
                        if (dN > b1) {
                            s = dN - b1;
                        }
                        if (a2 > (b1 + b2)) {
                            s = Math.min(s, a2 - (b1 + b2));
                        }
                        tau   = Math.max(s, 0.333 * dMin);
                        tType = -3;
                    }

---fix ingredient(SameMethod)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1640, 1660>
if (b2 != 0.0){
                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 *= work[i4] / work[i4 - 2];
                        b2 += b1;
                        if (100 * b1 < b2) {
                            break;
                        }
                    }
                }
b2 = Math.sqrt(cnst3 * b2);
final double a2 = dMin2 / (1 + b2 * b2);
final double gap2 = work[nn - 7] + work[nn - 9] -
                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;
if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                }

---fix ingredient(SameMethod)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1640, 1660>
if (b2 != 0.0){
                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 *= work[i4] / work[i4 - 2];
                        b2 += b1;
                        if (100 * b1 < b2) {
                            break;
                        }
                    }
                }
b2 = Math.sqrt(cnst3 * b2);
final double a2 = dMin2 / (1 + b2 * b2);
final double gap2 = work[nn - 7] + work[nn - 9] -
                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;
if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <545, 547>
if (lmPar == 0) {
                lmPar = Math.max(2.2251e-308, 0.001 * paru);
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <545, 547>
if (doubleVar == 0) {
                doubleVar = Math.max(2.2251e-308, 0.001 * doubleVar);
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer <545, 547>
if (lmPar == 0) {
                lmPar = Math.max(2.2251e-308, 0.001 * paru);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <588, 590>
if (lmPar == 0) {
        lmPar = Math.max(2.2251e-308, 0.001 * paru);
      }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <588, 590>
if (doubleVar == 0) {
        doubleVar = Math.max(2.2251e-308, 0.001 * doubleVar);
      }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.estimation.LevenbergMarquardtEstimator <588, 590>
if (lmPar == 0) {
        lmPar = Math.max(2.2251e-308, 0.001 * paru);
      }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <905, 919>
for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {
                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&
                            (work[i + 2] <= TOLERANCE_2 * sigma)) {
                            // insert a split
                            work[i + 2]  = -sigma;
                            split        = i / 4;
                            diagMax      = 0;
                            offDiagMin   = work[i + 6];
                            previousEMin = work[i + 7];
                        } else {
                            diagMax      = Math.max(diagMax, work[i + 4]);
                            offDiagMin   = Math.min(offDiagMin, work[i + 2]);
                            previousEMin = Math.min(previousEMin, work[i + 3]);
                        }
                    }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <905, 919>
for (int intVar = 4 * intVar; intVar < 4 * intVar - 11; intVar += 4) {
                        if ((double[]Var[intVar + 3] <= doubleVar * double[]Var[intVar]) &&
                            (double[]Var[intVar + 2] <= doubleVar * doubleVar)) {
                            // insert a split
                            double[]Var[intVar + 2]  = -doubleVar;
                            intVar        = intVar / 4;
                            doubleVar      = 0;
                            doubleVar   = double[]Var[intVar + 6];
                            doubleVar = double[]Var[intVar + 7];
                        } else {
                            doubleVar      = Math.max(doubleVar, double[]Var[intVar + 4]);
                            doubleVar   = Math.min(doubleVar, double[]Var[intVar + 2]);
                            doubleVar = Math.min(doubleVar, double[]Var[intVar + 3]);
                        }
                    }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <905, 919>
for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {
                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&
                            (work[i + 2] <= TOLERANCE_2 * sigma)) {
                            // insert a split
                            work[i + 2]  = -sigma;
                            split        = i / 4;
                            diagMax      = 0;
                            offDiagMin   = work[i + 6];
                            previousEMin = work[i + 7];
                        } else {
                            diagMax      = Math.max(diagMax, work[i + 4]);
                            offDiagMin   = Math.min(offDiagMin, work[i + 2]);
                            previousEMin = Math.min(previousEMin, work[i + 3]);
                        }
                    }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1052, 1064>
if ((dMin <= 0) || (deflatedEnd < end)) {
            if (flipIfWarranted(deflatedEnd, 1)) {
                dMin2 = Math.min(dMin2, work[l - 1]);
                work[l - 1] =
                    Math.min(work[l - 1],
                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                work[l - 2 * pingPong] =
                    Math.min(work[l - 2 * pingPong],
                             Math.min(work[6 + pingPong], work[6 + pingPong]));
                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));
                dMin  = -0.0;
            }
        }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <1052, 1064>
if ((doubleVar <= 0) || (intVar < intVar)) {
            if (flipIfWarranted(intVar, 1)) {
                doubleVar = Math.min(doubleVar, double[]Var[intVar - 1]);
                double[]Var[intVar - 1] =
                    Math.min(double[]Var[intVar - 1],
                             Math.min(double[]Var[3 + intVar], double[]Var[7 + intVar]));
                double[]Var[intVar - 2 * intVar] =
                    Math.min(double[]Var[intVar - 2 * intVar],
                             Math.min(double[]Var[6 + intVar], double[]Var[6 + intVar]));
                doubleVar  = Math.max(doubleVar, Math.max(double[]Var[3 + intVar], double[]Var[7 + intVar]));
                doubleVar  = -0.0;
            }
        }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1052, 1064>
if ((dMin <= 0) || (deflatedEnd < end)) {
            if (flipIfWarranted(deflatedEnd, 1)) {
                dMin2 = Math.min(dMin2, work[l - 1]);
                work[l - 1] =
                    Math.min(work[l - 1],
                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                work[l - 2 * pingPong] =
                    Math.min(work[l - 2 * pingPong],
                             Math.min(work[6 + pingPong], work[6 + pingPong]));
                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));
                dMin  = -0.0;
            }
        }

---fix ingredient(SameMethod)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1478, 1499>
if (dMin == dN) {
                        gam = dN;
                        a2 = 0.0;
                        if (work[nn - 5]  >  work[nn - 7]) {
                            return;
                        }
                        b2 = work[nn - 5] / work[nn - 7];
                        np = nn - 9;
                    } else {
                        np = nn - 2 * pingPong;
                        b2 = work[np - 2];
                        gam = dN1;
                        if (work[np - 4]  >  work[np - 2]) {
                            return;
                        }
                        a2 = work[np - 4] / work[np - 2];
                        if (work[nn - 9]  >  work[nn - 11]) {
                            return;
                        }
                        b2 = work[nn - 9] / work[nn - 11];
                        np = nn - 13;
                    }

---fix ingredient(SameMethod)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <1478, 1499>
if (doubleVar == doubleVar) {
                        doubleVar = doubleVar;
                        doubleVar = 0.0;
                        if (double[]Var[intVar - 5]  >  double[]Var[intVar - 7]) {
                            return;
                        }
                        doubleVar = double[]Var[intVar - 5] / double[]Var[intVar - 7];
                        intVar = intVar - 9;
                    } else {
                        intVar = intVar - 2 * intVar;
                        doubleVar = double[]Var[intVar - 2];
                        doubleVar = doubleVar;
                        if (double[]Var[intVar - 4]  >  double[]Var[intVar - 2]) {
                            return;
                        }
                        doubleVar = double[]Var[intVar - 4] / double[]Var[intVar - 2];
                        if (double[]Var[intVar - 9]  >  double[]Var[intVar - 11]) {
                            return;
                        }
                        doubleVar = double[]Var[intVar - 9] / double[]Var[intVar - 11];
                        intVar = intVar - 13;
                    }

---fix ingredient(SameMethod)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1478, 1499>
if (dMin == dN) {
                        gam = dN;
                        a2 = 0.0;
                        if (work[nn - 5]  >  work[nn - 7]) {
                            return;
                        }
                        b2 = work[nn - 5] / work[nn - 7];
                        np = nn - 9;
                    } else {
                        np = nn - 2 * pingPong;
                        b2 = work[np - 2];
                        gam = dN1;
                        if (work[np - 4]  >  work[np - 2]) {
                            return;
                        }
                        a2 = work[np - 4] / work[np - 2];
                        if (work[nn - 9]  >  work[nn - 11]) {
                            return;
                        }
                        b2 = work[nn - 9] / work[nn - 11];
                        np = nn - 13;
                    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.geometry.Vector3D <512, 515>
final double doubleVar = Math.abs(Vector3DVar.doubleVar - Vector3DVar.doubleVar);
final double doubleVar = Math.abs(Vector3DVar.doubleVar - Vector3DVar.doubleVar);
final double doubleVar = Math.abs(Vector3DVar.doubleVar - Vector3DVar.doubleVar);
return Math.max(Math.max(doubleVar, doubleVar), doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.geometry.Vector3D <512, 515>
final double dx = Math.abs(Vector3D.x - Vector3D.x);
final double dy = Math.abs(Vector3D.y - Vector3D.y);
final double dz = Math.abs(Vector3D.z - Vector3D.z);
return Math.max(Math.max(dx, dy), dz);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator <136, 152>
double error = 0;
empty line
for (int j = 0; j < y0.length; ++j) {
        final double errSum = E1 * yDotK[0][j] +  E3 * yDotK[2][j] +
                              E4 * yDotK[3][j] +  E5 * yDotK[4][j] +
                              E6 * yDotK[5][j] +  E7 * yDotK[6][j];

        final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
        final double tol = (vecAbsoluteTolerance == null) ?
                           (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                               (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
        final double ratio  = h * errSum / tol;
        error += ratio * ratio;

    }
empty line
return Math.sqrt(error / y0.length);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator <136, 152>
double doubleVar = 0;
empty line
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
        final double errSum = doubleVar * double[][]Var[0][intVar] +  doubleVar * double[][]Var[2][intVar] +
                              doubleVar * double[][]Var[3][intVar] +  doubleVar * double[][]Var[4][intVar] +
                              doubleVar * double[][]Var[5][intVar] +  doubleVar * double[][]Var[6][intVar];

        final double yScale = Math.max(Math.abs(double[]Var[intVar]), Math.abs(double[]Var[intVar]));
        final double tol = (double[]Var == null) ?
                           (doubleVar + doubleVar * yScale) :
                               (double[]Var[intVar] + double[]Var[intVar] * yScale);
        final double ratio  = doubleVar * errSum / tol;
        doubleVar += ratio * ratio;

    }
empty line
return Math.sqrt(doubleVar / double[]Var.length);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator <136, 152>
double error = 0;
empty line
for (int j = 0; j < y0.length; ++j) {
        final double errSum = E1 * yDotK[0][j] +  E3 * yDotK[2][j] +
                              E4 * yDotK[3][j] +  E5 * yDotK[4][j] +
                              E6 * yDotK[5][j] +  E7 * yDotK[6][j];

        final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
        final double tol = (vecAbsoluteTolerance == null) ?
                           (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
                               (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
        final double ratio  = h * errSum / tol;
        error += ratio * ratio;

    }
empty line
return Math.sqrt(error / y0.length);

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1087, 1093>
if ((dMin < 0.0) &&
                           (dMin1 > 0.0) &&
                           (work[4 * deflatedEnd - 5 - pingPong] < TOLERANCE * (sigma + dN1)) &&
                           (Math.abs(dN) < TOLERANCE * sigma)) {
                   // convergence hidden by negative DN.
                    work[4 * deflatedEnd - 3 - pingPong] = 0.0;
                    dMin = 0.0;
                    updateSigma(tau);
                    return deflatedEnd;
                } else if (dMin < 0.0) {
                    // tau too big. Select new tau and try again.
                    if (tType < -22) {
                        // failed twice. Play it safe.
                        tau = 0.0;
                    } else if (dMin1 > 0.0) {
                        // late failure. Gives excellent shift.
                        tau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);
                        tType -= 11;
                    } else {
                        // early failure. Divide by 4.
                        tau *= 0.25;
                        tType -= 12;
                    }
                } else if (Double.isNaN(dMin)) {
                    tau = 0.0;
                } else {
                    // possible underflow. Play it safe.
                    loop = false;
                }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <1087, 1093>
if ((doubleVar < 0.0) &&
                           (doubleVar > 0.0) &&
                           (double[]Var[4 * intVar - 5 - intVar] < doubleVar * (doubleVar + doubleVar)) &&
                           (Math.abs(doubleVar) < doubleVar * doubleVar)) {
                   // convergence hidden by negative DN.
                    double[]Var[4 * intVar - 3 - intVar] = 0.0;
                    doubleVar = 0.0;
                    updateSigma(doubleVar);
                    return intVar;
                } else if (doubleVar < 0.0) {
                    // tau too big. Select new tau and try again.
                    if (intVar < -22) {
                        // failed twice. Play it safe.
                        doubleVar = 0.0;
                    } else if (doubleVar > 0.0) {
                        // late failure. Gives excellent shift.
                        doubleVar = (doubleVar + doubleVar) * (1.0 - 2.0 * MathUtils.EPSILON);
                        intVar -= 11;
                    } else {
                        // early failure. Divide by 4.
                        doubleVar *= 0.25;
                        intVar -= 12;
                    }
                } else if (Double.isNaN(doubleVar)) {
                    doubleVar = 0.0;
                } else {
                    // possible underflow. Play it safe.
                    booleanVar = false;
                }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1087, 1093>
if ((dMin < 0.0) &&
                           (dMin1 > 0.0) &&
                           (work[4 * deflatedEnd - 5 - pingPong] < TOLERANCE * (sigma + dN1)) &&
                           (Math.abs(dN) < TOLERANCE * sigma)) {
                   // convergence hidden by negative DN.
                    work[4 * deflatedEnd - 3 - pingPong] = 0.0;
                    dMin = 0.0;
                    updateSigma(tau);
                    return deflatedEnd;
                } else if (dMin < 0.0) {
                    // tau too big. Select new tau and try again.
                    if (tType < -22) {
                        // failed twice. Play it safe.
                        tau = 0.0;
                    } else if (dMin1 > 0.0) {
                        // late failure. Gives excellent shift.
                        tau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);
                        tType -= 11;
                    } else {
                        // early failure. Divide by 4.
                        tau *= 0.25;
                        tType -= 12;
                    }
                } else if (Double.isNaN(dMin)) {
                    tau = 0.0;
                } else {
                    // possible underflow. Play it safe.
                    loop = false;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.ContinuousOutputModel <296, 321>
final StepInterpolator sMed = steps.get(iMed);
final double tMed = 0.5 * (sMed.getPreviousTime() + sMed.getCurrentTime());
empty line
if ((Math.abs(tMed - tMin) < 1e-6) || (Math.abs(tMax - tMed) < 1e-6)) {
          // too close to the bounds, we estimate using a simple dichotomy
          index = iMed;
        } else {
          // estimate the index using a reverse quadratic polynom
          // (reverse means we have i = P(t), thus allowing to simply
          // compute index = P(time) rather than solving a quadratic equation)
          final double d12 = tMax - tMed;
          final double d23 = tMed - tMin;
          final double d13 = tMax - tMin;
          final double dt1 = time - tMax;
          final double dt2 = time - tMed;
          final double dt3 = time - tMin;
          final double iLagrange = ((dt2 * dt3 * d23) * iMax -
                                    (dt1 * dt3 * d13) * iMed +
                                    (dt1 * dt2 * d12) * iMin) /
                                   (d12 * d23 * d13);
          index = (int) Math.rint(iLagrange);
        }
empty line
// force the next size reduction to be at least one tenth
final int low  = Math.max(iMin + 1, (9 * iMin + iMax) / 10);
final int high = Math.min(iMax - 1, (iMin + 9 * iMax) / 10);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.ContinuousOutputModel <296, 321>
final StepInterpolator StepInterpolator = ListVar.get(intVar);
final double doubleVar = 0.5 * (StepInterpolator.getPreviousTime() + StepInterpolator.getCurrentTime());
empty line
if ((Math.abs(doubleVar - doubleVar) < 1e-6) || (Math.abs(doubleVar - doubleVar) < 1e-6)) {
          // too close to the bounds, we estimate using a simple dichotomy
          intVar = intVar;
        } else {
          // estimate the index using a reverse quadratic polynom
          // (reverse means we have i = P(t), thus allowing to simply
          // compute index = P(time) rather than solving a quadratic equation)
          final double d12 = doubleVar - doubleVar;
          final double d23 = doubleVar - doubleVar;
          final double d13 = doubleVar - doubleVar;
          final double dt1 = doubleVar - doubleVar;
          final double dt2 = doubleVar - doubleVar;
          final double dt3 = doubleVar - doubleVar;
          final double iLagrange = ((dt2 * dt3 * d23) * intVar -
                                    (dt1 * dt3 * d13) * intVar +
                                    (dt1 * dt2 * d12) * intVar) /
                                   (d12 * d23 * d13);
          intVar = (int) Math.rint(iLagrange);
        }
empty line
// force the next size reduction to be at least one tenth
final int intVar  = Math.max(intVar + 1, (9 * intVar + intVar) / 10);
final int intVar = Math.min(intVar - 1, (intVar + 9 * intVar) / 10);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.ContinuousOutputModel <296, 321>
final StepInterpolator StepInterpolator = steps.get(iMed);
final double tMed = 0.5 * (StepInterpolator.getPreviousTime() + StepInterpolator.getCurrentTime());
empty line
if ((Math.abs(tMed - tMin) < 1e-6) || (Math.abs(tMax - tMed) < 1e-6)) {
          // too close to the bounds, we estimate using a simple dichotomy
          index = iMed;
        } else {
          // estimate the index using a reverse quadratic polynom
          // (reverse means we have i = P(t), thus allowing to simply
          // compute index = P(time) rather than solving a quadratic equation)
          final double d12 = tMax - tMed;
          final double d23 = tMed - tMin;
          final double d13 = tMax - tMin;
          final double dt1 = time - tMax;
          final double dt2 = time - tMed;
          final double dt3 = time - tMin;
          final double iLagrange = ((dt2 * dt3 * d23) * iMax -
                                    (dt1 * dt3 * d13) * iMed +
                                    (dt1 * dt2 * d12) * iMin) /
                                   (d12 * d23 * d13);
          index = (int) Math.rint(iLagrange);
        }
empty line
// force the next size reduction to be at least one tenth
final int low  = Math.max(iMin + 1, (9 * iMin + iMax) / 10);
final int high = Math.min(iMax - 1, (iMin + 9 * iMax) / 10);

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1278, 1296>
if (pingPong == 0) {
            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {
                work[j4 - 2] = d + work[j4 - 1];
                final double tmp = work[j4 + 1] / work[j4 - 2];
                d = d * tmp - tau;
                dMin = Math.min(dMin, d);
                work[j4] = work[j4 - 1] * tmp;
                eMin = Math.min(work[j4], eMin);
            }
        } else {
            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {
                work[j4 - 3] = d + work[j4];
                final double tmp = work[j4 + 2] / work[j4 - 3];
                d = d * tmp - tau;
                dMin = Math.min(dMin, d);
                work[j4 - 1] = work[j4] * tmp;
                eMin = Math.min(work[j4 - 1], eMin);
            }
        }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <1278, 1296>
if (intVar == 0) {
            for (int j4 = 4 * intVar + 3; j4 <= 4 * (intVar - 3); j4 += 4) {
                double[]Var[j4 - 2] = doubleVar + double[]Var[j4 - 1];
                final double tmp = double[]Var[j4 + 1] / double[]Var[j4 - 2];
                doubleVar = doubleVar * tmp - doubleVar;
                doubleVar = Math.min(doubleVar, doubleVar);
                double[]Var[j4] = double[]Var[j4 - 1] * tmp;
                doubleVar = Math.min(double[]Var[j4], doubleVar);
            }
        } else {
            for (int j4 = 4 * intVar + 3; j4 <= 4 * (intVar - 3); j4 += 4) {
                double[]Var[j4 - 3] = doubleVar + double[]Var[j4];
                final double tmp = double[]Var[j4 + 2] / double[]Var[j4 - 3];
                doubleVar = doubleVar * tmp - doubleVar;
                doubleVar = Math.min(doubleVar, doubleVar);
                double[]Var[j4 - 1] = double[]Var[j4] * tmp;
                doubleVar = Math.min(double[]Var[j4 - 1], doubleVar);
            }
        }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1278, 1296>
if (pingPong == 0) {
            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {
                work[j4 - 2] = d + work[j4 - 1];
                final double tmp = work[j4 + 1] / work[j4 - 2];
                d = d * tmp - tau;
                dMin = Math.min(dMin, d);
                work[j4] = work[j4 - 1] * tmp;
                eMin = Math.min(work[j4], eMin);
            }
        } else {
            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {
                work[j4 - 3] = d + work[j4];
                final double tmp = work[j4 + 2] / work[j4 - 3];
                d = d * tmp - tau;
                dMin = Math.min(dMin, d);
                work[j4 - 1] = work[j4] * tmp;
                eMin = Math.min(work[j4 - 1], eMin);
            }
        }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1335, 1353>
for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {
                work[j4 - 2] = d + work[j4 - 1];
                if (work[j4 - 2] == 0.0) {
                    work[j4] = 0.0;
                    d = work[j4 + 1];
                    dMin = d;
                    eMin = 0.0;
                } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                           (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
                    final double tmp = work[j4 + 1] / work[j4 - 2];
                    work[j4] = work[j4 - 1] * tmp;
                    d *= tmp;
                } else {
                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);
                    d *= work[j4 + 1] / work[j4 - 2];
                }
                dMin = Math.min(dMin, d);
                eMin = Math.min(eMin, work[j4]);
            }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <1335, 1353>
for (int intVar = 4 * intVar + 3; intVar < 4 * (intVar - 3); intVar += 4) {
                double[]Var[intVar - 2] = doubleVar + double[]Var[intVar - 1];
                if (double[]Var[intVar - 2] == 0.0) {
                    double[]Var[intVar] = 0.0;
                    doubleVar = double[]Var[intVar + 1];
                    doubleVar = doubleVar;
                    doubleVar = 0.0;
                } else if ((MathUtils.SAFE_MIN * double[]Var[intVar + 1] < double[]Var[intVar - 2]) &&
                           (MathUtils.SAFE_MIN * double[]Var[intVar - 2] < double[]Var[intVar + 1])) {
                    final double tmp = double[]Var[intVar + 1] / double[]Var[intVar - 2];
                    double[]Var[intVar] = double[]Var[intVar - 1] * tmp;
                    doubleVar *= tmp;
                } else {
                    double[]Var[intVar] = double[]Var[intVar + 1] * (double[]Var[intVar - 1] / double[]Var[intVar - 2]);
                    doubleVar *= double[]Var[intVar + 1] / double[]Var[intVar - 2];
                }
                doubleVar = Math.min(doubleVar, doubleVar);
                doubleVar = Math.min(doubleVar, double[]Var[intVar]);
            }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1335, 1353>
for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {
                work[j4 - 2] = d + work[j4 - 1];
                if (work[j4 - 2] == 0.0) {
                    work[j4] = 0.0;
                    d = work[j4 + 1];
                    dMin = d;
                    eMin = 0.0;
                } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                           (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
                    final double tmp = work[j4 + 1] / work[j4 - 2];
                    work[j4] = work[j4 - 1] * tmp;
                    d *= tmp;
                } else {
                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);
                    d *= work[j4 + 1] / work[j4 - 2];
                }
                dMin = Math.min(dMin, d);
                eMin = Math.min(eMin, work[j4]);
            }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1355, 1373>
for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {
                work[j4 - 3] = d + work[j4];
                if (work[j4 - 3] == 0.0) {
                    work[j4 - 1] = 0.0;
                    d = work[j4 + 2];
                    dMin = d;
                    eMin = 0.0;
                } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                           (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
                    final double tmp = work[j4 + 2] / work[j4 - 3];
                    work[j4 - 1] = work[j4] * tmp;
                    d *= tmp;
                } else {
                    work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);
                    d *= work[j4 + 2] / work[j4 - 3];
                }
                dMin = Math.min(dMin, d);
                eMin = Math.min(eMin, work[j4 - 1]);
            }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <1355, 1373>
for (int intVar = 4 * intVar + 3; intVar < 4 * (intVar - 3); intVar += 4) {
                double[]Var[intVar - 3] = doubleVar + double[]Var[intVar];
                if (double[]Var[intVar - 3] == 0.0) {
                    double[]Var[intVar - 1] = 0.0;
                    doubleVar = double[]Var[intVar + 2];
                    doubleVar = doubleVar;
                    doubleVar = 0.0;
                } else if ((MathUtils.SAFE_MIN * double[]Var[intVar + 2] < double[]Var[intVar - 3]) &&
                           (MathUtils.SAFE_MIN * double[]Var[intVar - 3] < double[]Var[intVar + 2])) {
                    final double tmp = double[]Var[intVar + 2] / double[]Var[intVar - 3];
                    double[]Var[intVar - 1] = double[]Var[intVar] * tmp;
                    doubleVar *= tmp;
                } else {
                    double[]Var[intVar - 1] = double[]Var[intVar + 2] * (double[]Var[intVar] / double[]Var[intVar - 3]);
                    doubleVar *= double[]Var[intVar + 2] / double[]Var[intVar - 3];
                }
                doubleVar = Math.min(doubleVar, doubleVar);
                doubleVar = Math.min(doubleVar, double[]Var[intVar - 1]);
            }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1355, 1373>
for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {
                work[j4 - 3] = d + work[j4];
                if (work[j4 - 3] == 0.0) {
                    work[j4 - 1] = 0.0;
                    d = work[j4 + 2];
                    dMin = d;
                    eMin = 0.0;
                } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                           (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
                    final double tmp = work[j4 + 2] / work[j4 - 3];
                    work[j4 - 1] = work[j4] * tmp;
                    d *= tmp;
                } else {
                    work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);
                    d *= work[j4 + 2] / work[j4 - 3];
                }
                dMin = Math.min(dMin, d);
                eMin = Math.min(eMin, work[j4 - 1]);
            }

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <952, 973>
for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) {
                final int j = i - 2 * pingPong - 1;
                work[j] = d + work[i];
                if (work[i] <= TOLERANCE_2 * d) {
                    work[i]     = -0.0;
                    work[j]     = d;
                    work[j + 2] = 0.0;
                    d = work[i + 2];
                } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                           (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                    final double tmp = work[i + 2] / work[j];
                    work[j + 2] = work[i] * tmp;
                    d *= tmp;
                } else {
                    work[j + 2] = work[i + 2] * (work[i] / work[j]);
                    d *= work[i + 2] / work[j];
               }
            }
work[4 * n - 3 - pingPong] = d;
empty line
// from ping to pong
pingPong = 1 - pingPong;

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <952, 973>
for (int intVar = 2 + intVar; intVar < 4 * intVar - 2; intVar += 4) {
                final int j = intVar - 2 * intVar - 1;
                double[]Var[j] = doubleVar + double[]Var[intVar];
                if (double[]Var[intVar] <= doubleVar * doubleVar) {
                    double[]Var[intVar]     = -0.0;
                    double[]Var[j]     = doubleVar;
                    double[]Var[j + 2] = 0.0;
                    doubleVar = double[]Var[intVar + 2];
                } else if ((MathUtils.SAFE_MIN * double[]Var[intVar + 2] < double[]Var[j]) &&
                           (MathUtils.SAFE_MIN * double[]Var[j] < double[]Var[intVar + 2])) {
                    final double tmp = double[]Var[intVar + 2] / double[]Var[j];
                    double[]Var[j + 2] = double[]Var[intVar] * tmp;
                    doubleVar *= tmp;
                } else {
                    double[]Var[j + 2] = double[]Var[intVar + 2] * (double[]Var[intVar] / double[]Var[j]);
                    doubleVar *= double[]Var[intVar + 2] / double[]Var[j];
               }
            }
double[]Var[4 * intVar - 3 - intVar] = doubleVar;
empty line
// from ping to pong
intVar = 1 - intVar;

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <952, 973>
for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) {
                final int j = i - 2 * pingPong - 1;
                work[j] = d + work[i];
                if (work[i] <= TOLERANCE_2 * d) {
                    work[i]     = -0.0;
                    work[j]     = d;
                    work[j + 2] = 0.0;
                    d = work[i + 2];
                } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                           (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                    final double tmp = work[i + 2] / work[j];
                    work[j + 2] = work[i] * tmp;
                    d *= tmp;
                } else {
                    work[j + 2] = work[i + 2] * (work[i] / work[j]);
                    d *= work[i + 2] / work[j];
               }
            }
work[4 * n - 3 - pingPong] = d;
empty line
// from ping to pong
pingPong = 1 - pingPong;

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1014, 1045>
if ((start == deflatedEnd - 2) ||
                (work[k - 9] <= TOLERANCE_2 * sigma) ||
                (work[k - 2 * pingPong - 8] <= TOLERANCE_2 * work[k - 11])) {

                // two realEigenvalues found, deflate array
                if (work[k - 3] > work[k - 7]) {
                    final double tmp = work[k - 3];
                    work[k - 3] = work[k - 7];
                    work[k - 7] = tmp;
                }

                if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {
                    double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);
                    double s = work[k - 3] * (work[k - 5] / t);
                    if (s <= t) {
                        s = work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));
                    } else {
                        s = work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));
                    }
                    t = work[k - 7] + (s + work[k - 5]);
                    work[k - 3] *= work[k - 7] / t;
                    work[k - 7]  = t;
                }
                work[4 * deflatedEnd - 8] = sigma + work[k - 7];
                work[4 * deflatedEnd - 4] = sigma + work[k - 3];
                deflatedEnd -= 2;
            } else {

                // no more realEigenvalues found, we need to iterate
                deflating = false;

            }

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <1014, 1045>
if ((intVar == intVar - 2) ||
                (double[]Var[intVar - 9] <= doubleVar * doubleVar) ||
                (double[]Var[intVar - 2 * intVar - 8] <= doubleVar * double[]Var[intVar - 11])) {

                // two realEigenvalues found, deflate array
                if (double[]Var[intVar - 3] > double[]Var[intVar - 7]) {
                    final double tmp = double[]Var[intVar - 3];
                    double[]Var[intVar - 3] = double[]Var[intVar - 7];
                    double[]Var[intVar - 7] = tmp;
                }

                if (double[]Var[intVar - 5] > doubleVar * double[]Var[intVar - 3]) {
                    double t = 0.5 * ((double[]Var[intVar - 7] - double[]Var[intVar - 3]) + double[]Var[intVar - 5]);
                    double s = double[]Var[intVar - 3] * (double[]Var[intVar - 5] / t);
                    if (s <= t) {
                        s = double[]Var[intVar - 3] * double[]Var[intVar - 5] / (t * (1 + Math.sqrt(1 + s / t)));
                    } else {
                        s = double[]Var[intVar - 3] * double[]Var[intVar - 5] / (t + Math.sqrt(t * (t + s)));
                    }
                    t = double[]Var[intVar - 7] + (s + double[]Var[intVar - 5]);
                    double[]Var[intVar - 3] *= double[]Var[intVar - 7] / t;
                    double[]Var[intVar - 7]  = t;
                }
                double[]Var[4 * intVar - 8] = doubleVar + double[]Var[intVar - 7];
                double[]Var[4 * intVar - 4] = doubleVar + double[]Var[intVar - 3];
                intVar -= 2;
            } else {

                // no more realEigenvalues found, we need to iterate
                booleanVar = false;

            }

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1014, 1045>
if ((start == deflatedEnd - 2) ||
                (work[k - 9] <= TOLERANCE_2 * sigma) ||
                (work[k - 2 * pingPong - 8] <= TOLERANCE_2 * work[k - 11])) {

                // two realEigenvalues found, deflate array
                if (work[k - 3] > work[k - 7]) {
                    final double tmp = work[k - 3];
                    work[k - 3] = work[k - 7];
                    work[k - 7] = tmp;
                }

                if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {
                    double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);
                    double s = work[k - 3] * (work[k - 5] / t);
                    if (s <= t) {
                        s = work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));
                    } else {
                        s = work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));
                    }
                    t = work[k - 7] + (s + work[k - 5]);
                    work[k - 3] *= work[k - 7] / t;
                    work[k - 7]  = t;
                }
                work[4 * deflatedEnd - 8] = sigma + work[k - 7];
                work[4 * deflatedEnd - 4] = sigma + work[k - 3];
                deflatedEnd -= 2;
            } else {

                // no more realEigenvalues found, we need to iterate
                deflating = false;

            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.RiddersSolver <147, 167>
final double y3 = f.value(x3);
if (Math.abs(y3) <= functionValueAccuracy) {
                setResult(x3, i);
                return result;
            }
final double delta = 1 - (y1 * y2) / (y3 * y3);
final double correction = (MathUtils.sign(y2) * MathUtils.sign(y3)) *
                                      (x3 - x1) / Math.sqrt(delta);
final double x = x3 - correction;
final double y = f.value(x);
empty line
// check for convergence
final double tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);
if (Math.abs(x - oldx) <= tolerance) {
                setResult(x, i);
                return result;
            }
if (Math.abs(y) <= functionValueAccuracy) {
                setResult(x, i);
                return result;
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.solvers.RiddersSolver <147, 167>
final double y3 = UnivariateRealFunction.value(x3);
if (Math.abs(y3) <= functionValueAccuracy) {
                setResult(x3, i);
                return result;
            }
final double delta = 1 - (y1 * y2) / (y3 * y3);
final double correction = (MathUtils.sign(y2) * MathUtils.sign(y3)) *
                                      (x3 - x1) / Math.sqrt(delta);
final double x = x3 - correction;
final double y = UnivariateRealFunction.value(x);
empty line
// check for convergence
final double tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);
if (Math.abs(x - oldx) <= tolerance) {
                setResult(x, i);
                return result;
            }
if (Math.abs(y) <= functionValueAccuracy) {
                setResult(x, i);
                return result;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialsUtils <196, 219>
final int maxDegree = (int) Math.floor(Math.sqrt(2 * coefficients.size())) - 1;
synchronized (PolynomialsUtils.class) {
            if (degree > maxDegree) {
                computeUpToDegree(degree, maxDegree, generator, coefficients);
            }
        }
empty line
// coefficient  for polynomial 0 is  l [0]
// coefficients for polynomial 1 are l [1] ... l [2] (degrees 0 ... 1)
// coefficients for polynomial 2 are l [3] ... l [5] (degrees 0 ... 2)
// coefficients for polynomial 3 are l [6] ... l [9] (degrees 0 ... 3)
// coefficients for polynomial 4 are l[10] ... l[14] (degrees 0 ... 4)
// coefficients for polynomial 5 are l[15] ... l[20] (degrees 0 ... 5)
// coefficients for polynomial 6 are l[21] ... l[27] (degrees 0 ... 6)
// ...
final int start = degree * (degree + 1) / 2;
empty line
final double[] a = new double[degree + 1];
for (int i = 0; i <= degree; ++i) {
            a[i] = coefficients.get(start + i).doubleValue();
        }
empty line
// build the polynomial
return new PolynomialFunction(a);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialsUtils <196, 219>
final int intVar = (int) Math.floor(Math.sqrt(2 * ArrayList.size())) - 1;
synchronized (PolynomialsUtils.class) {
            if (intVar > intVar) {
                computeUpToDegree(intVar, intVar, RecurrenceCoefficientsGenerator, ArrayList);
            }
        }
empty line
// coefficient  for polynomial 0 is  l [0]
// coefficients for polynomial 1 are l [1] ... l [2] (degrees 0 ... 1)
// coefficients for polynomial 2 are l [3] ... l [5] (degrees 0 ... 2)
// coefficients for polynomial 3 are l [6] ... l [9] (degrees 0 ... 3)
// coefficients for polynomial 4 are l[10] ... l[14] (degrees 0 ... 4)
// coefficients for polynomial 5 are l[15] ... l[20] (degrees 0 ... 5)
// coefficients for polynomial 6 are l[21] ... l[27] (degrees 0 ... 6)
// ...
final int intVar = intVar * (intVar + 1) / 2;
empty line
final double[] double[]Var = new double[intVar + 1];
for (int intVar = 0; intVar <= intVar; ++intVar) {
            double[]Var[intVar] = ArrayList.get(intVar + intVar).doubleValue();
        }
empty line
// build the polynomial
return new PolynomialFunction(double[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialsUtils <196, 219>
final int maxDegree = (int) Math.floor(Math.sqrt(2 * ArrayList.size())) - 1;
synchronized (PolynomialsUtils.class) {
            if (degree > maxDegree) {
                computeUpToDegree(degree, maxDegree, RecurrenceCoefficientsGenerator, ArrayList);
            }
        }
empty line
// coefficient  for polynomial 0 is  l [0]
// coefficients for polynomial 1 are l [1] ... l [2] (degrees 0 ... 1)
// coefficients for polynomial 2 are l [3] ... l [5] (degrees 0 ... 2)
// coefficients for polynomial 3 are l [6] ... l [9] (degrees 0 ... 3)
// coefficients for polynomial 4 are l[10] ... l[14] (degrees 0 ... 4)
// coefficients for polynomial 5 are l[15] ... l[20] (degrees 0 ... 5)
// coefficients for polynomial 6 are l[21] ... l[27] (degrees 0 ... 6)
// ...
final int start = degree * (degree + 1) / 2;
empty line
final double[] a = new double[degree + 1];
for (int i = 0; i <= degree; ++i) {
            a[i] = ArrayList.get(start + i).doubleValue();
        }
empty line
// build the polynomial
return new PolynomialFunction(a);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <335, 345>
if (currentDegree > 3) {
            double cDot = 0;
            double c = polynoms[currentDegree][i];
            for (int j = currentDegree - 1; j > 3; --j) {
                final double d = 1.0 / (j - 3);
                cDot = d * (theta05 * cDot + c);
                c = polynoms[j][i] + c * d * theta05;
            }
            interpolatedState[i]       += t4 * c;
            interpolatedDerivatives[i] += (t4 * cDot + t4Dot * c) / h;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <335, 345>
if (intVar > 3) {
            double cDot = 0;
            double c = double[][]Var[intVar][intVar];
            for (int j = intVar - 1; j > 3; --j) {
                final double d = 1.0 / (j - 3);
                cDot = d * (doubleVar * cDot + c);
                c = double[][]Var[j][intVar] + c * d * doubleVar;
            }
            double[]Var[intVar]       += doubleVar * c;
            double[]Var[intVar] += (doubleVar * cDot + doubleVar * c) / doubleVar;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <335, 345>
if (currentDegree > 3) {
            double cDot = 0;
            double c = polynoms[currentDegree][i];
            for (int j = currentDegree - 1; j > 3; --j) {
                final double d = 1.0 / (j - 3);
                cDot = d * (theta05 * cDot + c);
                c = polynoms[j][i] + c * d * theta05;
            }
            interpolatedState[i]       += t4 * c;
            interpolatedDerivatives[i] += (t4 * cDot + t4Dot * c) / h;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Kurtosis <107, 120>
double kurtosis = Double.NaN;
if (moment.getN() > 3) {
            double variance = moment.m2 / (moment.n - 1);
                if (moment.n <= 3 || variance < 10E-20) {
                    kurtosis = 0.0;
                } else {
                    double n = moment.n;
                    kurtosis =
                        (n * (n + 1) * moment.m4 -
                                3 * moment.m2 * moment.m2 * (n - 1)) /
                                ((n - 1) * (n -2) * (n -3) * variance * variance);
                }
        }
return kurtosis;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Kurtosis <107, 120>
double doubleVar = Double.NaN;
if (ThirdMoment.getN() > 3) {
            double variance = ThirdMoment.m2 / (ThirdMoment.n - 1);
                if (ThirdMoment.n <= 3 || variance < 10E-20) {
                    doubleVar = 0.0;
                } else {
                    double n = ThirdMoment.n;
                    doubleVar =
                        (n * (n + 1) * ThirdMoment.m4 -
                                3 * ThirdMoment.m2 * ThirdMoment.m2 * (n - 1)) /
                                ((n - 1) * (n -2) * (n -3) * variance * variance);
                }
        }
return doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.Kurtosis <107, 120>
double kurtosis = Double.NaN;
if (ThirdMoment.getN() > 3) {
            double variance = ThirdMoment.m2 / (ThirdMoment.n - 1);
                if (ThirdMoment.n <= 3 || variance < 10E-20) {
                    kurtosis = 0.0;
                } else {
                    double n = ThirdMoment.n;
                    kurtosis =
                        (n * (n + 1) * ThirdMoment.m4 -
                                3 * ThirdMoment.m2 * ThirdMoment.m2 * (n - 1)) /
                                ((n - 1) * (n -2) * (n -3) * variance * variance);
                }
        }
return kurtosis;

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <1367, 1394>
for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
            final int pStart = iBlock * BLOCK_SIZE;
            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);
            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
                final double[] block  = blocks[iBlock * blockColumns + jBlock];
                final int      qStart = jBlock * BLOCK_SIZE;
                final int      qEnd   = Math.min(qStart + BLOCK_SIZE, columns);
                int k = 0;
                for (int p = pStart; p < pEnd; ++p) {
                    double sum = 0;
                    int q = qStart;
                    while (q < qEnd - 3) {
                        sum += block[k]     * v[q]     +
                               block[k + 1] * v[q + 1] +
                               block[k + 2] * v[q + 2] +
                               block[k + 3] * v[q + 3];
                        k += 4;
                        q += 4;
                    }
                    while (q < qEnd) {
                        sum += block[k++] * v[q++];
                    }
                    out[p] += sum;
                }
            }
        }
empty line
return out;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockRealMatrix <1367, 1394>
for (int intVar = 0; intVar < intVar; ++intVar) {
            final int pStart = intVar * intVar;
            final int pEnd   = Math.min(pStart + intVar, intVar);
            for (int jBlock = 0; jBlock < intVar; ++jBlock) {
                final double[] block  = doubleVar[intVar * intVar + jBlock];
                final int      qStart = jBlock * intVar;
                final int      qEnd   = Math.min(qStart + intVar, intVar);
                int k = 0;
                for (int p = pStart; p < pEnd; ++p) {
                    double sum = 0;
                    int q = qStart;
                    while (q < qEnd - 3) {
                        sum += block[k]     * double[]Var[q]     +
                               block[k + 1] * double[]Var[q + 1] +
                               block[k + 2] * double[]Var[q + 2] +
                               block[k + 3] * double[]Var[q + 3];
                        k += 4;
                        q += 4;
                    }
                    while (q < qEnd) {
                        sum += block[k++] * double[]Var[q++];
                    }
                    double[]Var[p] += sum;
                }
            }
        }
empty line
return double[]Var;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BlockRealMatrix <1367, 1394>
for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
            final int pStart = iBlock * BLOCK_SIZE;
            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);
            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
                final double[] block  = blocks[iBlock * blockColumns + jBlock];
                final int      qStart = jBlock * BLOCK_SIZE;
                final int      qEnd   = Math.min(qStart + BLOCK_SIZE, columns);
                int k = 0;
                for (int p = pStart; p < pEnd; ++p) {
                    double sum = 0;
                    int q = qStart;
                    while (q < qEnd - 3) {
                        sum += block[k]     * v[q]     +
                               block[k + 1] * v[q + 1] +
                               block[k + 2] * v[q + 2] +
                               block[k + 3] * v[q + 3];
                        k += 4;
                        q += 4;
                    }
                    while (q < qEnd) {
                        sum += block[k++] * v[q++];
                    }
                    out[p] += sum;
                }
            }
        }
empty line
return out;

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BigMatrixImpl <1367, 1379>
int ret = 7;
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
ret = ret * 31 + nRows;
ret = ret * 31 + nCols;
for (int row = 0; row < nRows; row++) {
            final BigDecimal[] dataRow = data[row];
            for (int col = 0; col < nCols; col++) {
                ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) *
                dataRow[col].hashCode();
            }
        }
return ret;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BigMatrixImpl <1367, 1379>
int intVar = 7;
final int intVar = getRowDimension();
final int intVar = getColumnDimension();
intVar = intVar * 31 + intVar;
intVar = intVar * 31 + intVar;
for (int intVar = 0; intVar < intVar; intVar++) {
            final BigDecimal[] dataRow = BigDecimal[intVar];
            for (int col = 0; col < intVar; col++) {
                intVar = intVar * 31 + (11 * (intVar+1) + 17 * (col+1)) *
                dataRow[col].hashCode();
            }
        }
return intVar;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BigMatrixImpl <1367, 1379>
int ret = 7;
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
ret = ret * 31 + nRows;
ret = ret * 31 + nCols;
for (int row = 0; row < nRows; row++) {
            final BigDecimal[] dataRow = BigDecimal[row];
            for (int col = 0; col < nCols; col++) {
                ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) *
                dataRow[col].hashCode();
            }
        }
return ret;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <407, 425>
a = x < 0 ? 1 : 0;
t = y * (y + 1) / (2 * lambda);
if (v < -t && a == 0) {
                    y = lambda + y;
                    break;
                }
qr = t * ((2 * y + 1) / (6 * lambda) - 1);
qa = qr - (t * t) / (3 * (lambda + a * (y + 1)));
if (v < qa) {
                    y = lambda + y;
                    break;
                }
if (v > qr) {
                    continue;
                }
if (v < y * logLambda - MathUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) {
                    y = lambda + y;
                    break;
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.RandomDataImpl <407, 425>
intVar = doubleVar < 0 ? 1 : 0;
doubleVar = doubleVar * (doubleVar + 1) / (2 * doubleVar);
if (doubleVar < -doubleVar && intVar == 0) {
                    doubleVar = doubleVar + doubleVar;
                    break;
                }
doubleVar = doubleVar * ((2 * doubleVar + 1) / (6 * doubleVar) - 1);
doubleVar = doubleVar - (doubleVar * doubleVar) / (3 * (doubleVar + intVar * (doubleVar + 1)));
if (doubleVar < doubleVar) {
                    doubleVar = doubleVar + doubleVar;
                    break;
                }
if (doubleVar > doubleVar) {
                    continue;
                }
if (doubleVar < doubleVar * doubleVar - MathUtils.factorialLog((int) (doubleVar + doubleVar)) + doubleVar) {
                    doubleVar = doubleVar + doubleVar;
                    break;
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.RandomDataImpl <407, 425>
a = x < 0 ? 1 : 0;
t = y * (y + 1) / (2 * lambda);
if (v < -t && a == 0) {
                    y = lambda + y;
                    break;
                }
qr = t * ((2 * y + 1) / (6 * lambda) - 1);
qa = qr - (t * t) / (3 * (lambda + a * (y + 1)));
if (v < qa) {
                    y = lambda + y;
                    break;
                }
if (v > qr) {
                    continue;
                }
if (v < y * logLambda - MathUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) {
                    y = lambda + y;
                    break;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <124, 130>
final int prime = 31;
int result = 1;
result = prime * result + (isBiasCorrected ? 1231 : 1237);
result = prime * result + (int) (n ^ (n >>> 32));
result = prime * result + Arrays.hashCode(productsSums);
result = prime * result + Arrays.hashCode(sums);
return result;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <124, 130>
final int intVar = 31;
int intVar = 1;
intVar = intVar * intVar + (booleanVar ? 1231 : 1237);
intVar = intVar * intVar + (int) (longVar ^ (longVar >>> 32));
intVar = intVar * intVar + Arrays.hashCode(double[]Var);
intVar = intVar * intVar + Arrays.hashCode(double[]Var);
return intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.VectorialCovariance <124, 130>
final int prime = 31;
int result = 1;
result = prime * result + (isBiasCorrected ? 1231 : 1237);
result = prime * result + (int) (n ^ (n >>> 32));
result = prime * result + Arrays.hashCode(productsSums);
result = prime * result + Arrays.hashCode(sums);
return result;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.geometry.Rotation <536, 539>
if (q0 < 0) {
      double inverse = 1 / Math.sqrt(squaredSine);
      return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.geometry.Rotation <536, 539>
if (doubleVar < 0) {
      double inverse = 1 / Math.sqrt(doubleVar);
      return new Vector3D(doubleVar * inverse, doubleVar * inverse, doubleVar * inverse);
    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.geometry.Rotation <536, 539>
if (q0 < 0) {
      double inverse = 1 / Math.sqrt(squaredSine);
      return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Skewness <156, 186>
if (test(values, begin, length) && length > 2 ){
            Mean mean = new Mean();
            // Get the mean and the standard deviation
            double m = mean.evaluate(values, begin, length);

            // Calc the std, this is implemented here instead
            // of using the standardDeviation method eliminate
            // a duplicate pass to get the mean
            double accum = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                final double d = values[i] - m;
                accum  += d * d;
                accum2 += d;
            }
            final double variance = (accum - (accum2 * accum2 / length)) / (length - 1);

            double accum3 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                final double d = values[i] - m;
                accum3 += d * d * d;
            }
            accum3 /= variance * Math.sqrt(variance);

            // Get N
            double n0 = length;

            // Calculate skewness
            skew = (n0 / ((n0 - 1) * (n0 - 2))) * accum3;
        }
return skew;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Skewness <156, 186>
if (test(double[]Var, intVar, intVar) && intVar > 2 ){
            Mean mean = new Mean();
            // Get the mean and the standard deviation
            double m = mean.evaluate(double[]Var, intVar, intVar);

            // Calc the std, this is implemented here instead
            // of using the standardDeviation method eliminate
            // a duplicate pass to get the mean
            double accum = 0.0;
            double accum2 = 0.0;
            for (int i = intVar; i < intVar + intVar; i++) {
                final double d = double[]Var[i] - m;
                accum  += d * d;
                accum2 += d;
            }
            final double variance = (accum - (accum2 * accum2 / intVar)) / (intVar - 1);

            double accum3 = 0.0;
            for (int i = intVar; i < intVar + intVar; i++) {
                final double d = double[]Var[i] - m;
                accum3 += d * d * d;
            }
            accum3 /= variance * Math.sqrt(variance);

            // Get N
            double n0 = intVar;

            // Calculate skewness
            doubleVar = (n0 / ((n0 - 1) * (n0 - 2))) * accum3;
        }
return doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.Skewness <156, 186>
if (test(values, begin, length) && length > 2 ){
            Mean mean = new Mean();
            // Get the mean and the standard deviation
            double m = mean.evaluate(values, begin, length);

            // Calc the std, this is implemented here instead
            // of using the standardDeviation method eliminate
            // a duplicate pass to get the mean
            double accum = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                final double d = values[i] - m;
                accum  += d * d;
                accum2 += d;
            }
            final double variance = (accum - (accum2 * accum2 / length)) / (length - 1);

            double accum3 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                final double d = values[i] - m;
                accum3 += d * d * d;
            }
            accum3 /= variance * Math.sqrt(variance);

            // Get N
            double n0 = length;

            // Calculate skewness
            skew = (n0 / ((n0 - 1) * (n0 - 2))) * accum3;
        }
return skew;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.SaddlePointExpansion <107, 125>
double ret;
if (z < 15.0) {
            double z2 = 2.0 * z;
            if (Math.floor(z2) == z2) {
                ret = EXACT_STIRLING_ERRORS[(int) z2];
            } else {
                ret = Gamma.logGamma(z + 1.0) - (z + 0.5) * Math.log(z) +
                      z - HALF_LOG_2_PI;
            }
        } else {
            double z2 = z * z;
            ret = (0.083333333333333333333 -
                    (0.00277777777777777777778 -
                            (0.00079365079365079365079365 -
                                    (0.000595238095238095238095238 -
                                            0.0008417508417508417508417508 /
                                            z2) / z2) / z2) / z2) / z;
        }
return ret;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.SaddlePointExpansion <107, 125>
double doubleVar;
if (doubleVar < 15.0) {
            double z2 = 2.0 * doubleVar;
            if (Math.floor(z2) == z2) {
                doubleVar = double[]Var[(int) z2];
            } else {
                doubleVar = Gamma.logGamma(doubleVar + 1.0) - (doubleVar + 0.5) * Math.log(doubleVar) +
                      doubleVar - doubleVar;
            }
        } else {
            double z2 = doubleVar * doubleVar;
            doubleVar = (0.083333333333333333333 -
                    (0.00277777777777777777778 -
                            (0.00079365079365079365079365 -
                                    (0.000595238095238095238095238 -
                                            0.0008417508417508417508417508 /
                                            z2) / z2) / z2) / z2) / doubleVar;
        }
return doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.distribution.SaddlePointExpansion <107, 125>
double ret;
if (z < 15.0) {
            double z2 = 2.0 * z;
            if (Math.floor(z2) == z2) {
                ret = EXACT_STIRLING_ERRORS[(int) z2];
            } else {
                ret = Gamma.logGamma(z + 1.0) - (z + 0.5) * Math.log(z) +
                      z - HALF_LOG_2_PI;
            }
        } else {
            double z2 = z * z;
            ret = (0.083333333333333333333 -
                    (0.00277777777777777777778 -
                            (0.00079365079365079365079365 -
                                    (0.000595238095238095238095238 -
                                            0.0008417508417508417508417508 /
                                            z2) / z2) / z2) / z2) / z;
        }
return ret;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <171, 198>
if (! vectorsInitialized) {

      if (v1 == null) {
        v1 = new double[interpolatedState.length];
        v2 = new double[interpolatedState.length];
        v3 = new double[interpolatedState.length];
        v4 = new double[interpolatedState.length];
      }

      // no step finalization is needed for this interpolator

      // we need to compute the interpolation vectors for this time step
      for (int i = 0; i < interpolatedState.length; ++i) {
          final double yDot0 = yDotK[0][i];
          final double yDot2 = yDotK[2][i];
          final double yDot3 = yDotK[3][i];
          final double yDot4 = yDotK[4][i];
          final double yDot5 = yDotK[5][i];
          final double yDot6 = yDotK[6][i];
          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;
          v2[i] = yDot0 - v1[i];
          v3[i] = v1[i] - v2[i] - yDot6;
          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;
      }

      vectorsInitialized = true;

    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <171, 198>
if (! booleanVar) {

      if (double[]Var == null) {
        double[]Var = new double[double[]Var.length];
        double[]Var = new double[double[]Var.length];
        double[]Var = new double[double[]Var.length];
        double[]Var = new double[double[]Var.length];
      }

      // no step finalization is needed for this interpolator

      // we need to compute the interpolation vectors for this time step
      for (int i = 0; i < double[]Var.length; ++i) {
          final double yDot0 = double[][]Var[0][i];
          final double yDot2 = double[][]Var[2][i];
          final double yDot3 = double[][]Var[3][i];
          final double yDot4 = double[][]Var[4][i];
          final double yDot5 = double[][]Var[5][i];
          final double yDot6 = double[][]Var[6][i];
          double[]Var[i] = doubleVar * yDot0 + doubleVar * yDot2 + doubleVar * yDot3 + doubleVar * yDot4 + doubleVar * yDot5;
          double[]Var[i] = yDot0 - double[]Var[i];
          double[]Var[i] = double[]Var[i] - double[]Var[i] - yDot6;
          double[]Var[i] = doubleVar * yDot0 + doubleVar * yDot2 + doubleVar * yDot3 + doubleVar * yDot4 + doubleVar * yDot5 + doubleVar * yDot6;
      }

      booleanVar = true;

    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <171, 198>
if (! vectorsInitialized) {

      if (v1 == null) {
        v1 = new double[interpolatedState.length];
        v2 = new double[interpolatedState.length];
        v3 = new double[interpolatedState.length];
        v4 = new double[interpolatedState.length];
      }

      // no step finalization is needed for this interpolator

      // we need to compute the interpolation vectors for this time step
      for (int i = 0; i < interpolatedState.length; ++i) {
          final double yDot0 = yDotK[0][i];
          final double yDot2 = yDotK[2][i];
          final double yDot3 = yDotK[3][i];
          final double yDot4 = yDotK[4][i];
          final double yDot5 = yDotK[5][i];
          final double yDot6 = yDotK[6][i];
          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;
          v2[i] = yDot0 - v1[i];
          v3[i] = v1[i] - v2[i] - yDot6;
          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;
      }

      vectorsInitialized = true;

    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Kurtosis <166, 192>
if (test(values, begin, length) && length > 3) {

            // Compute the mean and standard deviation
            Variance variance = new Variance();
            variance.incrementAll(values, begin, length);
            double mean = variance.moment.m1;
            double stdDev = Math.sqrt(variance.getResult());

            // Sum the ^4 of the distance from the mean divided by the
            // standard deviation
            double accum3 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                accum3 += Math.pow(values[i] - mean, 4.0);
            }
            accum3 /= Math.pow(stdDev, 4.0d);

            // Get N
            double n0 = length;

            double coefficientOne =
                (n0 * (n0 + 1)) / ((n0 - 1) * (n0 - 2) * (n0 - 3));
            double termTwo =
                (3 * Math.pow(n0 - 1, 2.0)) / ((n0 - 2) * (n0 - 3));

            // Calculate kurtosis
            kurt = (coefficientOne * accum3) - termTwo;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Kurtosis <166, 192>
if (test(double[]Var, intVar, intVar) && intVar > 3) {

            // Compute the mean and standard deviation
            Variance variance = new Variance();
            variance.incrementAll(double[]Var, intVar, intVar);
            double mean = variance.ThirdMoment.m1;
            double stdDev = Math.sqrt(variance.getResult());

            // Sum the ^4 of the distance from the mean divided by the
            // standard deviation
            double accum3 = 0.0;
            for (int i = intVar; i < intVar + intVar; i++) {
                accum3 += Math.pow(double[]Var[i] - mean, 4.0);
            }
            accum3 /= Math.pow(stdDev, 4.0d);

            // Get N
            double n0 = intVar;

            double coefficientOne =
                (n0 * (n0 + 1)) / ((n0 - 1) * (n0 - 2) * (n0 - 3));
            double termTwo =
                (3 * Math.pow(n0 - 1, 2.0)) / ((n0 - 2) * (n0 - 3));

            // Calculate kurtosis
            doubleVar = (coefficientOne * accum3) - termTwo;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.Kurtosis <166, 192>
if (test(values, begin, length) && length > 3) {

            // Compute the mean and standard deviation
            Variance variance = new Variance();
            variance.incrementAll(values, begin, length);
            double mean = variance.ThirdMoment.m1;
            double stdDev = Math.sqrt(variance.getResult());

            // Sum the ^4 of the distance from the mean divided by the
            // standard deviation
            double accum3 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                accum3 += Math.pow(values[i] - mean, 4.0);
            }
            accum3 /= Math.pow(stdDev, 4.0d);

            // Get N
            double n0 = length;

            double coefficientOne =
                (n0 * (n0 + 1)) / ((n0 - 1) * (n0 - 2) * (n0 - 3));
            double termTwo =
                (3 * Math.pow(n0 - 1, 2.0)) / ((n0 - 2) * (n0 - 3));

            // Calculate kurtosis
            kurt = (coefficientOne * accum3) - termTwo;
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <1056, 1067>
int ret = 7;
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
ret = ret * 31 + nRows;
ret = ret * 31 + nCols;
for (int row = 0; row < nRows; ++row) {
            for (int col = 0; col < nCols; ++col) {
               ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) *
                   MathUtils.hash(getEntry(row, col));
           }
        }
return ret;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <1056, 1067>
int intVar = 7;
final int intVar = getRowDimension();
final int intVar = getColumnDimension();
intVar = intVar * 31 + intVar;
intVar = intVar * 31 + intVar;
for (int intVar = 0; intVar < intVar; ++intVar) {
            for (int col = 0; col < intVar; ++col) {
               intVar = intVar * 31 + (11 * (intVar+1) + 17 * (col+1)) *
                   MathUtils.hash(getEntry(intVar, col));
           }
        }
return intVar;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <1056, 1067>
int ret = 7;
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
ret = ret * 31 + nRows;
ret = ret * 31 + nCols;
for (int row = 0; row < nRows; ++row) {
            for (int col = 0; col < nCols; ++col) {
               ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) *
                   MathUtils.hash(getEntry(row, col));
           }
        }
return ret;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.geometry.Rotation <373, 397>
if (c == 0) {
      // the (q1, q2, q3) vector is aligned with u1:
      // we try (u2, u3) and (v2, v3)
      k = new Vector3D(dy2 * dz3 - dz2 * dy3,
                       dz2 * dx3 - dx2 * dz3,
                       dx2 * dy3 - dy2 * dx3);
      c = k.getX() * (u2y * u3z - u2z * u3y) +
          k.getY() * (u2z * u3x - u2x * u3z) +
          k.getZ() * (u2x * u3y - u2y * u3x);

      if (c == 0) {
        // the (q1, q2, q3) vector is aligned with everything
        // this is really the identity rotation
        q0 = 1.0;
        q1 = 0.0;
        q2 = 0.0;
        q3 = 0.0;
        return;
      }

      // we will have to use u2 and v2 to compute the scalar part
      uRef = u2;
      vRef = v2;

    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.geometry.Rotation <373, 397>
if (doubleVar == 0) {
      // the (q1, q2, q3) vector is aligned with u1:
      // we try (u2, u3) and (v2, v3)
      Vector3DVar = new Vector3D(doubleVar * doubleVar - doubleVar * doubleVar,
                       doubleVar * doubleVar - doubleVar * doubleVar,
                       doubleVar * doubleVar - doubleVar * doubleVar);
      doubleVar = Vector3DVar.getX() * (doubleVar * doubleVar - doubleVar * doubleVar) +
          Vector3DVar.getY() * (doubleVar * doubleVar - doubleVar * doubleVar) +
          Vector3DVar.getZ() * (doubleVar * doubleVar - doubleVar * doubleVar);

      if (doubleVar == 0) {
        // the (q1, q2, q3) vector is aligned with everything
        // this is really the identity rotation
        doubleVar = 1.0;
        doubleVar = 0.0;
        doubleVar = 0.0;
        doubleVar = 0.0;
        return;
      }

      // we will have to use u2 and v2 to compute the scalar part
      Vector3DVar = Vector3DVar;
      Vector3DVar = Vector3DVar;

    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.geometry.Rotation <373, 397>
if (c == 0) {
      // the (q1, q2, q3) vector is aligned with u1:
      // we try (u2, u3) and (v2, v3)
      k = new Vector3D(dy2 * dz3 - dz2 * dy3,
                       dz2 * dx3 - dx2 * dz3,
                       dx2 * dy3 - dy2 * dx3);
      c = k.getX() * (u2y * u3z - u2z * u3y) +
          k.getY() * (u2z * u3x - u2x * u3z) +
          k.getZ() * (u2x * u3y - u2y * u3x);

      if (c == 0) {
        // the (q1, q2, q3) vector is aligned with everything
        // this is really the identity rotation
        q0 = 1.0;
        q1 = 0.0;
        q2 = 0.0;
        q3 = 0.0;
        return;
      }

      // we will have to use u2 and v2 to compute the scalar part
      uRef = u2;
      vRef = v2;

    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.VectorialMean <84, 87>
final int prime = 31;
int result = 1;
result = prime * result + Arrays.hashCode(means);
return result;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.VectorialMean <84, 87>
final int intVar = 31;
int intVar = 1;
intVar = intVar * intVar + Arrays.hashCode(Mean[]Var);
return intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.VectorialMean <84, 87>
final int prime = 31;
int result = 1;
result = prime * result + Arrays.hashCode(means);
return result;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <329, 332>
final int prime = 31;
int result = 1;
result = prime * result + Arrays.hashCode(coefficients);
return result;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <329, 332>
final int intVar = 31;
int intVar = 1;
intVar = intVar * intVar + Arrays.hashCode(doubleVar);
return intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.polynomials.PolynomialFunction <329, 332>
final int prime = 31;
int result = 1;
result = prime * result + Arrays.hashCode(coefficients);
return result;

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <1005, 1015>
int ret = 322562;
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
ret = ret * 31 + nRows;
ret = ret * 31 + nCols;
for (int row = 0; row < nRows; ++row) {
            for (int col = 0; col < nCols; ++col) {
               ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * getEntry(row, col).hashCode();
           }
        }
return ret;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractFieldMatrix <1005, 1015>
int intVar = 322562;
final int intVar = getRowDimension();
final int intVar = getColumnDimension();
intVar = intVar * 31 + intVar;
intVar = intVar * 31 + intVar;
for (int intVar = 0; intVar < intVar; ++intVar) {
            for (int col = 0; col < intVar; ++col) {
               intVar = intVar * 31 + (11 * (intVar+1) + 17 * (col+1)) * getEntry(intVar, col).hashCode();
           }
        }
return intVar;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractFieldMatrix <1005, 1015>
int ret = 322562;
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
ret = ret * 31 + nRows;
ret = ret * 31 + nCols;
for (int row = 0; row < nRows; ++row) {
            for (int col = 0; col < nCols; ++col) {
               ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * getEntry(row, col).hashCode();
           }
        }
return ret;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.geometry.Vector3D <308, 321>
double threshold = 0.6 * getNorm();
if (threshold == 0) {
      throw MathRuntimeException.createArithmeticException("zero norm");
    }
empty line
if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
double inverse  = 1 / Math.sqrt(x * x + y * y);
return new Vector3D(inverse * y, -inverse * x, 0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.geometry.Vector3D <308, 321>
double doubleVar = 0.6 * getNorm();
if (doubleVar == 0) {
      throw MathRuntimeException.createArithmeticException("zero norm");
    }
empty line
if ((doubleVar >= -doubleVar) && (doubleVar <= doubleVar)) {
      double inverse  = 1 / Math.sqrt(doubleVar * doubleVar + doubleVar * doubleVar);
      return new Vector3D(0, inverse * doubleVar, -inverse * doubleVar);
    } else if ((doubleVar >= -doubleVar) && (doubleVar <= doubleVar)) {
      double inverse  = 1 / Math.sqrt(doubleVar * doubleVar + doubleVar * doubleVar);
      return new Vector3D(-inverse * doubleVar, 0, inverse * doubleVar);
    }
double doubleVar  = 1 / Math.sqrt(doubleVar * doubleVar + doubleVar * doubleVar);
return new Vector3D(doubleVar * doubleVar, -doubleVar * doubleVar, 0);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.geometry.Vector3D <308, 321>
double threshold = 0.6 * getNorm();
if (threshold == 0) {
      throw MathRuntimeException.createArithmeticException("zero norm");
    }
empty line
if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
double inverse  = 1 / Math.sqrt(x * x + y * y);
return new Vector3D(inverse * y, -inverse * x, 0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.geometry.Vector3D <308, 321>
double threshold = 0.6 * getNorm();
if (threshold == 0) {
      throw MathRuntimeException.createArithmeticException("zero norm");
    }
empty line
if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
double inverse  = 1 / Math.sqrt(x * x + y * y);
return new Vector3D(inverse * y, -inverse * x, 0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.geometry.Vector3D <308, 321>
double doubleVar = 0.6 * getNorm();
if (doubleVar == 0) {
      throw MathRuntimeException.createArithmeticException("zero norm");
    }
empty line
if ((doubleVar >= -doubleVar) && (doubleVar <= doubleVar)) {
      double inverse  = 1 / Math.sqrt(doubleVar * doubleVar + doubleVar * doubleVar);
      return new Vector3D(0, inverse * doubleVar, -inverse * doubleVar);
    } else if ((doubleVar >= -doubleVar) && (doubleVar <= doubleVar)) {
      double inverse  = 1 / Math.sqrt(doubleVar * doubleVar + doubleVar * doubleVar);
      return new Vector3D(-inverse * doubleVar, 0, inverse * doubleVar);
    }
double doubleVar  = 1 / Math.sqrt(doubleVar * doubleVar + doubleVar * doubleVar);
return new Vector3D(doubleVar * doubleVar, -doubleVar * doubleVar, 0);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.geometry.Vector3D <308, 321>
double threshold = 0.6 * getNorm();
if (threshold == 0) {
      throw MathRuntimeException.createArithmeticException("zero norm");
    }
empty line
if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
double inverse  = 1 / Math.sqrt(x * x + y * y);
return new Vector3D(inverse * y, -inverse * x, 0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <347, 363>
if (mean < pivot) {
            double p = Math.exp(-mean);
            long n = 0;
            double r = 1.0d;
            double rnd = 1.0d;

            while (n < 1000 * mean) {
                rnd = generator.nextDouble();
                r = r * rnd;
                if (r >= p) {
                    n++;
                } else {
                    return n;
                }
            }
            return n;
        } else {
            final double lambda = Math.floor(mean);
            final double lambdaFractional = mean - lambda;
            final double logLambda = Math.log(lambda);
            final double logLambdaFactorial = MathUtils.factorialLog((int) lambda);
            final long y2 = lambdaFractional < Double.MIN_VALUE ? 0 : nextPoisson(lambdaFractional);
            final double delta = Math.sqrt(lambda * Math.log(32 * lambda / Math.PI + 1));
            final double halfDelta = delta / 2;
            final double twolpd = 2 * lambda + delta;
            final double a1 = Math.sqrt(Math.PI * twolpd) * Math.exp(1 / 8 * lambda);
            final double a2 = (twolpd / delta) * Math.exp(-delta * (1 + delta) / twolpd);
            final double aSum = a1 + a2 + 1;
            final double p1 = a1 / aSum;
            final double p2 = a2 / aSum;
            final double c1 = 1 / (8 * lambda);

            double x = 0;
            double y = 0;
            double v = 0;
            int a = 0;
            double t = 0;
            double qr = 0;
            double qa = 0;
            for (;;) {
                final double u = nextUniform(0.0, 1);
                if (u <= p1) {
                    final double n = nextGaussian(0d, 1d);
                    x = n * Math.sqrt(lambda + halfDelta) - 0.5d;
                    if (x > delta || x < -lambda) {
                        continue;
                    }
                    y = x < 0 ? Math.floor(x) : Math.ceil(x);
                    final double e = nextExponential(1d);
                    v = -e - (n * n / 2) + c1;
                } else {
                    if (u > p1 + p2) {
                        y = lambda;
                        break;
                    } else {
                        x = delta + (twolpd / delta) * nextExponential(1d);
                        y = Math.ceil(x);
                        v = -nextExponential(1d) - delta * (x + 1) / twolpd;
                    }
                }
                a = x < 0 ? 1 : 0;
                t = y * (y + 1) / (2 * lambda);
                if (v < -t && a == 0) {
                    y = lambda + y;
                    break;
                }
                qr = t * ((2 * y + 1) / (6 * lambda) - 1);
                qa = qr - (t * t) / (3 * (lambda + a * (y + 1)));
                if (v < qa) {
                    y = lambda + y;
                    break;
                }
                if (v > qr) {
                    continue;
                }
                if (v < y * logLambda - MathUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) {
                    y = lambda + y;
                    break;
                }
            }
            return y2 + (long) y;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.RandomDataImpl <347, 363>
if (doubleVar < doubleVar) {
            double p = Math.exp(-doubleVar);
            long n = 0;
            double r = 1.0d;
            double rnd = 1.0d;

            while (n < 1000 * doubleVar) {
                rnd = RandomGenerator.nextDouble();
                r = r * rnd;
                if (r >= p) {
                    n++;
                } else {
                    return n;
                }
            }
            return n;
        } else {
            final double lambda = Math.floor(doubleVar);
            final double lambdaFractional = doubleVar - lambda;
            final double logLambda = Math.log(lambda);
            final double logLambdaFactorial = MathUtils.factorialLog((int) lambda);
            final long y2 = lambdaFractional < Double.MIN_VALUE ? 0 : nextPoisson(lambdaFractional);
            final double delta = Math.sqrt(lambda * Math.log(32 * lambda / Math.PI + 1));
            final double halfDelta = delta / 2;
            final double twolpd = 2 * lambda + delta;
            final double a1 = Math.sqrt(Math.PI * twolpd) * Math.exp(1 / 8 * lambda);
            final double a2 = (twolpd / delta) * Math.exp(-delta * (1 + delta) / twolpd);
            final double aSum = a1 + a2 + 1;
            final double p1 = a1 / aSum;
            final double p2 = a2 / aSum;
            final double c1 = 1 / (8 * lambda);

            double x = 0;
            double y = 0;
            double v = 0;
            int a = 0;
            double t = 0;
            double qr = 0;
            double qa = 0;
            for (;;) {
                final double u = nextUniform(0.0, 1);
                if (u <= p1) {
                    final double n = nextGaussian(0d, 1d);
                    x = n * Math.sqrt(lambda + halfDelta) - 0.5d;
                    if (x > delta || x < -lambda) {
                        continue;
                    }
                    y = x < 0 ? Math.floor(x) : Math.ceil(x);
                    final double e = nextExponential(1d);
                    v = -e - (n * n / 2) + c1;
                } else {
                    if (u > p1 + p2) {
                        y = lambda;
                        break;
                    } else {
                        x = delta + (twolpd / delta) * nextExponential(1d);
                        y = Math.ceil(x);
                        v = -nextExponential(1d) - delta * (x + 1) / twolpd;
                    }
                }
                a = x < 0 ? 1 : 0;
                t = y * (y + 1) / (2 * lambda);
                if (v < -t && a == 0) {
                    y = lambda + y;
                    break;
                }
                qr = t * ((2 * y + 1) / (6 * lambda) - 1);
                qa = qr - (t * t) / (3 * (lambda + a * (y + 1)));
                if (v < qa) {
                    y = lambda + y;
                    break;
                }
                if (v > qr) {
                    continue;
                }
                if (v < y * logLambda - MathUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) {
                    y = lambda + y;
                    break;
                }
            }
            return y2 + (long) y;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.RandomDataImpl <347, 363>
if (mean < pivot) {
            double p = Math.exp(-mean);
            long n = 0;
            double r = 1.0d;
            double rnd = 1.0d;

            while (n < 1000 * mean) {
                rnd = RandomGenerator.nextDouble();
                r = r * rnd;
                if (r >= p) {
                    n++;
                } else {
                    return n;
                }
            }
            return n;
        } else {
            final double lambda = Math.floor(mean);
            final double lambdaFractional = mean - lambda;
            final double logLambda = Math.log(lambda);
            final double logLambdaFactorial = MathUtils.factorialLog((int) lambda);
            final long y2 = lambdaFractional < Double.MIN_VALUE ? 0 : nextPoisson(lambdaFractional);
            final double delta = Math.sqrt(lambda * Math.log(32 * lambda / Math.PI + 1));
            final double halfDelta = delta / 2;
            final double twolpd = 2 * lambda + delta;
            final double a1 = Math.sqrt(Math.PI * twolpd) * Math.exp(1 / 8 * lambda);
            final double a2 = (twolpd / delta) * Math.exp(-delta * (1 + delta) / twolpd);
            final double aSum = a1 + a2 + 1;
            final double p1 = a1 / aSum;
            final double p2 = a2 / aSum;
            final double c1 = 1 / (8 * lambda);

            double x = 0;
            double y = 0;
            double v = 0;
            int a = 0;
            double t = 0;
            double qr = 0;
            double qa = 0;
            for (;;) {
                final double u = nextUniform(0.0, 1);
                if (u <= p1) {
                    final double n = nextGaussian(0d, 1d);
                    x = n * Math.sqrt(lambda + halfDelta) - 0.5d;
                    if (x > delta || x < -lambda) {
                        continue;
                    }
                    y = x < 0 ? Math.floor(x) : Math.ceil(x);
                    final double e = nextExponential(1d);
                    v = -e - (n * n / 2) + c1;
                } else {
                    if (u > p1 + p2) {
                        y = lambda;
                        break;
                    } else {
                        x = delta + (twolpd / delta) * nextExponential(1d);
                        y = Math.ceil(x);
                        v = -nextExponential(1d) - delta * (x + 1) / twolpd;
                    }
                }
                a = x < 0 ? 1 : 0;
                t = y * (y + 1) / (2 * lambda);
                if (v < -t && a == 0) {
                    y = lambda + y;
                    break;
                }
                qr = t * ((2 * y + 1) / (6 * lambda) - 1);
                qa = qr - (t * t) / (3 * (lambda + a * (y + 1)));
                if (v < qa) {
                    y = lambda + y;
                    break;
                }
                if (v > qr) {
                    continue;
                }
                if (v < y * logLambda - MathUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) {
                    y = lambda + y;
                    break;
                }
            }
            return y2 + (long) y;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.geometry.Rotation <128, 135>
if (needsNormalization) {
      // normalization preprocessing
      double inv = 1.0 / Math.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
      q0 *= inv;
      q1 *= inv;
      q2 *= inv;
      q3 *= inv;
    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.geometry.Rotation <128, 135>
if (needsNormalization) {
      // normalization preprocessing
      double inv = 1.0 / Math.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
      q0 *= inv;
      q1 *= inv;
      q2 *= inv;
      q3 *= inv;
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.transform.FastFourierTransformer <374, 409>
for (int i = 0; i < n; i += 4) {
            final Complex a = f[i].add(f[i+1]);
            final Complex b = f[i+2].add(f[i+3]);
            final Complex c = f[i].subtract(f[i+1]);
            final Complex d = f[i+2].subtract(f[i+3]);
            final Complex e1 = c.add(d.multiply(Complex.I));
            final Complex e2 = c.subtract(d.multiply(Complex.I));
            f[i] = a.add(b);
            f[i+2] = a.subtract(b);
            // omegaCount indicates forward or inverse transform
            f[i+1] = roots.isForward() ? e2 : e1;
            f[i+3] = roots.isForward() ? e1 : e2;
        }
empty line
// iterations from bottom to top take O(N*logN) time
for (int i = 4; i < n; i <<= 1) {
            final int m = n / (i<<1);
            for (int j = 0; j < n; j += i<<1) {
                for (int k = 0; k < i; k++) {
                    //z = f[i+j+k].multiply(roots.getOmega(k*m));
                    final int k_times_m = k*m;
                    final double omega_k_times_m_real = roots.getOmegaReal(k_times_m);
                    final double omega_k_times_m_imaginary = roots.getOmegaImaginary(k_times_m);
                    //z = f[i+j+k].multiply(omega[k*m]);
                    final Complex z = new Complex(
                        f[i+j+k].getReal() * omega_k_times_m_real -
                        f[i+j+k].getImaginary() * omega_k_times_m_imaginary,
                        f[i+j+k].getReal() * omega_k_times_m_imaginary +
                        f[i+j+k].getImaginary() * omega_k_times_m_real);

                    f[i+j+k] = f[j+k].subtract(z);
                    f[j+k] = f[j+k].add(z);
                }
            }
        }
return f;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.transform.FastFourierTransformer <374, 409>
for (int intVar = 0; intVar < intVar; intVar += 4) {
            final Complex a = Complex[intVar].add(Complex[intVar+1]);
            final Complex b = Complex[intVar+2].add(Complex[intVar+3]);
            final Complex c = Complex[intVar].subtract(Complex[intVar+1]);
            final Complex d = Complex[intVar+2].subtract(Complex[intVar+3]);
            final Complex e1 = c.add(d.multiply(Complex.I));
            final Complex e2 = c.subtract(d.multiply(Complex.I));
            Complex[intVar] = a.add(b);
            Complex[intVar+2] = a.subtract(b);
            // omegaCount indicates forward or inverse transform
            Complex[intVar+1] = RootsOfUnity.isForward() ? e2 : e1;
            Complex[intVar+3] = RootsOfUnity.isForward() ? e1 : e2;
        }
empty line
// iterations from bottom to top take O(N*logN) time
for (int intVar = 4; intVar < intVar; intVar <<= 1) {
            final int m = intVar / (intVar<<1);
            for (int j = 0; j < intVar; j += intVar<<1) {
                for (int k = 0; k < intVar; k++) {
                    //z = f[i+j+k].multiply(roots.getOmega(k*m));
                    final int k_times_m = k*m;
                    final double omega_k_times_m_real = RootsOfUnity.getOmegaReal(k_times_m);
                    final double omega_k_times_m_imaginary = RootsOfUnity.getOmegaImaginary(k_times_m);
                    //z = f[i+j+k].multiply(omega[k*m]);
                    final Complex z = new Complex(
                        Complex[intVar+j+k].getReal() * omega_k_times_m_real -
                        Complex[intVar+j+k].getImaginary() * omega_k_times_m_imaginary,
                        Complex[intVar+j+k].getReal() * omega_k_times_m_imaginary +
                        Complex[intVar+j+k].getImaginary() * omega_k_times_m_real);

                    Complex[intVar+j+k] = Complex[j+k].subtract(z);
                    Complex[j+k] = Complex[j+k].add(z);
                }
            }
        }
return Complex;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.transform.FastFourierTransformer <374, 409>
for (int i = 0; i < n; i += 4) {
            final Complex a = Complex[i].add(Complex[i+1]);
            final Complex b = Complex[i+2].add(Complex[i+3]);
            final Complex c = Complex[i].subtract(Complex[i+1]);
            final Complex d = Complex[i+2].subtract(Complex[i+3]);
            final Complex e1 = c.add(d.multiply(Complex.I));
            final Complex e2 = c.subtract(d.multiply(Complex.I));
            Complex[i] = a.add(b);
            Complex[i+2] = a.subtract(b);
            // omegaCount indicates forward or inverse transform
            Complex[i+1] = RootsOfUnity.isForward() ? e2 : e1;
            Complex[i+3] = RootsOfUnity.isForward() ? e1 : e2;
        }
empty line
// iterations from bottom to top take O(N*logN) time
for (int i = 4; i < n; i <<= 1) {
            final int m = n / (i<<1);
            for (int j = 0; j < n; j += i<<1) {
                for (int k = 0; k < i; k++) {
                    //z = f[i+j+k].multiply(roots.getOmega(k*m));
                    final int k_times_m = k*m;
                    final double omega_k_times_m_real = RootsOfUnity.getOmegaReal(k_times_m);
                    final double omega_k_times_m_imaginary = RootsOfUnity.getOmegaImaginary(k_times_m);
                    //z = f[i+j+k].multiply(omega[k*m]);
                    final Complex z = new Complex(
                        Complex[i+j+k].getReal() * omega_k_times_m_real -
                        Complex[i+j+k].getImaginary() * omega_k_times_m_imaginary,
                        Complex[i+j+k].getReal() * omega_k_times_m_imaginary +
                        Complex[i+j+k].getImaginary() * omega_k_times_m_real);

                    Complex[i+j+k] = Complex[j+k].subtract(z);
                    Complex[j+k] = Complex[j+k].add(z);
                }
            }
        }
return Complex;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils <198, 205>
if (fa * fb > 0.0 ) {
            throw new ConvergenceException(
                      "number of iterations={0}, maximum iterations={1}, " +
                      "initial={2}, lower bound={3}, upper bound={4}, final a value={5}, " +
                      "final b value={6}, f(a)={7}, f(b)={8}",
                      numIterations, maximumIterations, initial,
                      lowerBound, upperBound, a, b, fa, fb);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils <198, 205>
if (doubleVar * doubleVar > 0.0 ) {
            throw new ConvergenceException(
                      "number of iterations={0}, maximum iterations={1}, " +
                      "initial={2}, lower bound={3}, upper bound={4}, final a value={5}, " +
                      "final b value={6}, f(a)={7}, f(b)={8}",
                      intVar, intVar, doubleVar,
                      doubleVar, doubleVar, doubleVar, doubleVar, doubleVar, doubleVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils <198, 205>
if (fa * fb > 0.0 ) {
            throw new ConvergenceException(
                      "number of iterations={0}, maximum iterations={1}, " +
                      "initial={2}, lower bound={3}, upper bound={4}, final a value={5}, " +
                      "final b value={6}, f(a)={7}, f(b)={8}",
                      numIterations, maximumIterations, initial,
                      lowerBound, upperBound, a, b, fa, fb);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <275, 286>
if (mu > 2) {
            final double ph3 = 6 * (bspl - aspl);
            polynoms[7][i] = 16 * (yMidDots[3][i] - ph3 + 3 * polynoms[5][i]);

            for (int j = 4; j <= mu; ++j) {
              final double fac1 = 0.5 * j * (j - 1);
              final double fac2 = 2 * fac1 * (j - 2) * (j - 3);
              polynoms[j+4][i] =
                  16 * (yMidDots[j][i] + fac1 * polynoms[j+2][i] - fac2 * polynoms[j][i]);
            }

          }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <275, 286>
if (intVar > 2) {
            final double ph3 = 6 * (doubleVar - doubleVar);
            double[][]Var[7][intVar] = 16 * (double[][]Var[3][intVar] - ph3 + 3 * double[][]Var[5][intVar]);

            for (int j = 4; j <= intVar; ++j) {
              final double fac1 = 0.5 * j * (j - 1);
              final double fac2 = 2 * fac1 * (j - 2) * (j - 3);
              double[][]Var[j+4][intVar] =
                  16 * (double[][]Var[j][intVar] + fac1 * double[][]Var[j+2][intVar] - fac2 * double[][]Var[j][intVar]);
            }

          }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.GraggBulirschStoerStepInterpolator <275, 286>
if (mu > 2) {
            final double ph3 = 6 * (bspl - aspl);
            polynoms[7][i] = 16 * (yMidDots[3][i] - ph3 + 3 * polynoms[5][i]);

            for (int j = 4; j <= mu; ++j) {
              final double fac1 = 0.5 * j * (j - 1);
              final double fac2 = 2 * fac1 * (j - 2) * (j - 3);
              polynoms[j+4][i] =
                  16 * (yMidDots[j][i] + fac1 * polynoms[j+2][i] - fac2 * polynoms[j][i]);
            }

          }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <73, 77>
if (x[i]  >= x[i + 1]) {
                throw MathRuntimeException.createIllegalArgumentException(
                      "points {0} and {1} are not strictly increasing ({2} >= {3})",
                      i, i+1, x[i], x[i+1]);
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <73, 77>
if (doubleVar[intVar]  >= doubleVar[intVar + 1]) {
                throw MathRuntimeException.createIllegalArgumentException(
                      "points {0} and {1} are not strictly increasing ({2} >= {3})",
                      intVar, intVar+1, doubleVar[intVar], doubleVar[intVar+1]);
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <73, 77>
if (x[i]  >= x[i + 1]) {
                throw MathRuntimeException.createIllegalArgumentException(
                      "points {0} and {1} are not strictly increasing ({2} >= {3})",
                      i, i+1, x[i], x[i+1]);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.Frequency <567, 571>
final int prime = 31;
int result = 1;
result = prime * result +
                 ((freqTable == null) ? 0 : freqTable.hashCode());
return result;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.Frequency <567, 571>
final int intVar = 31;
int intVar = 1;
intVar = intVar * intVar +
                 ((TreeMap == null) ? 0 : TreeMap.hashCode());
return intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.Frequency <567, 571>
final int prime = 31;
int result = 1;
result = prime * result +
                 ((TreeMap == null) ? 0 : TreeMap.hashCode());
return result;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.SecantSolver <128, 133>
if (y0 * y1 >= 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "function values at endpoints do not have different signs, " +
                  "endpoints: [{0}, {1}], values: [{2}, {3}]",
                  min, max, y0, y1);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.solvers.SecantSolver <128, 133>
if (doubleVar * doubleVar >= 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "function values at endpoints do not have different signs, " +
                  "endpoints: [{0}, {1}], values: [{2}, {3}]",
                  doubleVar, doubleVar, doubleVar, doubleVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.solvers.SecantSolver <128, 133>
if (y0 * y1 >= 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "function values at endpoints do not have different signs, " +
                  "endpoints: [{0}, {1}], values: [{2}, {3}]",
                  min, max, y0, y1);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <103, 122>
z[n] = 0d;
c[n] = 0d;
empty line
for (int j = n -1; j >=0; j--) {
            c[j] = z[j] - mu[j] * c[j + 1];
            b[j] = (y[j + 1] - y[j]) / h[j] - h[j] * (c[j + 1] + 2d * c[j]) / 3d;
            d[j] = (c[j + 1] - c[j]) / (3d * h[j]);
        }
empty line
PolynomialFunction polynomials[] = new PolynomialFunction[n];
double coefficients[] = new double[4];
for (int i = 0; i < n; i++) {
            coefficients[0] = y[i];
            coefficients[1] = b[i];
            coefficients[2] = c[i];
            coefficients[3] = d[i];
            polynomials[i] = new PolynomialFunction(coefficients);
        }
empty line
return new PolynomialSplineFunction(x, polynomials);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <103, 122>
doubleVar[intVar] = 0d;
doubleVar[intVar] = 0d;
empty line
for (int intVar = intVar -1; intVar >=0; intVar--) {
            doubleVar[intVar] = doubleVar[intVar] - doubleVar[intVar] * doubleVar[intVar + 1];
            doubleVar[intVar] = (doubleVar[intVar + 1] - doubleVar[intVar]) / doubleVar[intVar] - doubleVar[intVar] * (doubleVar[intVar + 1] + 2d * doubleVar[intVar]) / 3d;
            doubleVar[intVar] = (doubleVar[intVar + 1] - doubleVar[intVar]) / (3d * doubleVar[intVar]);
        }
empty line
PolynomialFunction PolynomialFunction[] = new PolynomialFunction[intVar];
double doubleVar[] = new double[4];
for (int intVar = 0; intVar < intVar; intVar++) {
            doubleVar[0] = doubleVar[intVar];
            doubleVar[1] = doubleVar[intVar];
            doubleVar[2] = doubleVar[intVar];
            doubleVar[3] = doubleVar[intVar];
            PolynomialFunction[intVar] = new PolynomialFunction(doubleVar);
        }
empty line
return new PolynomialSplineFunction(doubleVar, PolynomialFunction);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.SplineInterpolator <103, 122>
z[n] = 0d;
c[n] = 0d;
empty line
for (int j = n -1; j >=0; j--) {
            c[j] = z[j] - mu[j] * c[j + 1];
            b[j] = (y[j + 1] - y[j]) / h[j] - h[j] * (c[j + 1] + 2d * c[j]) / 3d;
            d[j] = (c[j + 1] - c[j]) / (3d * h[j]);
        }
empty line
PolynomialFunction PolynomialFunction[] = new PolynomialFunction[n];
double coefficients[] = new double[4];
for (int i = 0; i < n; i++) {
            coefficients[0] = y[i];
            coefficients[1] = b[i];
            coefficients[2] = c[i];
            coefficients[3] = d[i];
            PolynomialFunction[i] = new PolynomialFunction(coefficients);
        }
empty line
return new PolynomialSplineFunction(x, PolynomialFunction);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.integration.SimpsonIntegrator <74, 97>
if (minimalIterationCount == 1) {
            final double s = (4 * qtrap.stage(f, min, max, 1) - qtrap.stage(f, min, max, 0)) / 3.0;
            setResult(s, 1);
            return result;
        }
// Simpson's rule requires at least two trapezoid stages.
double olds = 0;
double oldt = qtrap.stage(f, min, max, 0);
for (int i = 1; i <= maximalIterationCount; ++i) {
            final double t = qtrap.stage(f, min, max, i);
            final double s = (4 * t - oldt) / 3.0;
            if (i >= minimalIterationCount) {
                final double delta = Math.abs(s - olds);
                final double rLimit =
                    relativeAccuracy * (Math.abs(olds) + Math.abs(s)) * 0.5;
                if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {
                    setResult(s, i);
                    return result;
                }
            }
            olds = s;
            oldt = t;
        }
throw new MaxIterationsExceededException(maximalIterationCount);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.integration.SimpsonIntegrator <74, 97>
if (intVar == 1) {
            final double s = (4 * UnivariateRealIntegratorImpl.stage(UnivariateRealFunction, doubleVar, doubleVar, 1) - UnivariateRealIntegratorImpl.stage(UnivariateRealFunction, doubleVar, doubleVar, 0)) / 3.0;
            setResult(s, 1);
            return doubleVar;
        }
// Simpson's rule requires at least two trapezoid stages.
double doubleVar = 0;
double doubleVar = UnivariateRealIntegratorImpl.stage(UnivariateRealFunction, doubleVar, doubleVar, 0);
for (int intVar = 1; intVar <= intVar; ++intVar) {
            final double t = UnivariateRealIntegratorImpl.stage(UnivariateRealFunction, doubleVar, doubleVar, intVar);
            final double s = (4 * t - doubleVar) / 3.0;
            if (intVar >= intVar) {
                final double delta = Math.abs(s - doubleVar);
                final double rLimit =
                    doubleVar * (Math.abs(doubleVar) + Math.abs(s)) * 0.5;
                if ((delta <= rLimit) || (delta <= doubleVar)) {
                    setResult(s, intVar);
                    return doubleVar;
                }
            }
            doubleVar = s;
            doubleVar = t;
        }
throw new MaxIterationsExceededException(intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.integration.SimpsonIntegrator <74, 97>
if (minimalIterationCount == 1) {
            final double s = (4 * null.stage(UnivariateRealFunction, min, max, 1) - null.stage(UnivariateRealFunction, min, max, 0)) / 3.0;
            setResult(s, 1);
            return result;
        }
// Simpson's rule requires at least two trapezoid stages.
double olds = 0;
double oldt = null.stage(UnivariateRealFunction, min, max, 0);
for (int i = 1; i <= maximalIterationCount; ++i) {
            final double t = null.stage(UnivariateRealFunction, min, max, i);
            final double s = (4 * t - oldt) / 3.0;
            if (i >= minimalIterationCount) {
                final double delta = Math.abs(s - olds);
                final double rLimit =
                    relativeAccuracy * (Math.abs(olds) + Math.abs(s)) * 0.5;
                if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {
                    setResult(s, i);
                    return result;
                }
            }
            olds = s;
            oldt = t;
        }
throw new MaxIterationsExceededException(maximalIterationCount);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockFieldMatrix <1344, 1372>
for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
            final int pStart = iBlock * BLOCK_SIZE;
            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);
            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
                final T[] block  = blocks[iBlock * blockColumns + jBlock];
                final int      qStart = jBlock * BLOCK_SIZE;
                final int      qEnd   = Math.min(qStart + BLOCK_SIZE, columns);
                int k = 0;
                for (int p = pStart; p < pEnd; ++p) {
                    T sum = zero;
                    int q = qStart;
                    while (q < qEnd - 3) {
                        sum = sum.
                              add(block[k].multiply(v[q])).
                              add(block[k + 1].multiply(v[q + 1])).
                              add(block[k + 2].multiply(v[q + 2])).
                              add(block[k + 3].multiply(v[q + 3]));
                        k += 4;
                        q += 4;
                    }
                    while (q < qEnd) {
                        sum = sum.add(block[k++].multiply(v[q++]));
                    }
                    out[p] = out[p].add(sum);
                }
            }
        }
empty line
return out;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockFieldMatrix <1344, 1372>
for (int intVar = 0; intVar < intVar; ++intVar) {
            final int pStart = intVar * intVar;
            final int pEnd   = Math.min(pStart + intVar, intVar);
            for (int jBlock = 0; jBlock < intVar; ++jBlock) {
                final T[] block  = TVar[intVar * intVar + jBlock];
                final int      qStart = jBlock * intVar;
                final int      qEnd   = Math.min(qStart + intVar, intVar);
                int k = 0;
                for (int p = pStart; p < pEnd; ++p) {
                    T sum = TVar;
                    int q = qStart;
                    while (q < qEnd - 3) {
                        sum = sum.
                              add(block[k].multiply(T[]Var[q])).
                              add(block[k + 1].multiply(T[]Var[q + 1])).
                              add(block[k + 2].multiply(T[]Var[q + 2])).
                              add(block[k + 3].multiply(T[]Var[q + 3]));
                        k += 4;
                        q += 4;
                    }
                    while (q < qEnd) {
                        sum = sum.add(block[k++].multiply(T[]Var[q++]));
                    }
                    T[]Var[p] = T[]Var[p].add(sum);
                }
            }
        }
empty line
return T[]Var;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BlockFieldMatrix <1344, 1372>
for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
            final int pStart = iBlock * BLOCK_SIZE;
            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);
            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
                final T[] block  = blocks[iBlock * blockColumns + jBlock];
                final int      qStart = jBlock * BLOCK_SIZE;
                final int      qEnd   = Math.min(qStart + BLOCK_SIZE, columns);
                int k = 0;
                for (int p = pStart; p < pEnd; ++p) {
                    T sum = zero;
                    int q = qStart;
                    while (q < qEnd - 3) {
                        sum = sum.
                              add(block[k].multiply(v[q])).
                              add(block[k + 1].multiply(v[q + 1])).
                              add(block[k + 2].multiply(v[q + 2])).
                              add(block[k + 3].multiply(v[q + 3]));
                        k += 4;
                        q += 4;
                    }
                    while (q < qEnd) {
                        sum = sum.add(block[k++].multiply(v[q++]));
                    }
                    out[p] = out[p].add(sum);
                }
            }
        }
empty line
return out;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <441, 447>
if (i >= 1 && xval[i - 1] >= xval[i]) {
                throw new MathException(
                        "the abscissae array must be sorted in a strictly " +
                        "increasing order, but the {0}-th element is {1} " +
                        "whereas {2}-th is {3}",
                        i - 1, xval[i - 1], i, xval[i]);
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <441, 447>
if (intVar >= 1 && double[]Var[intVar - 1] >= double[]Var[intVar]) {
                throw new MathException(
                        "the abscissae array must be sorted in a strictly " +
                        "increasing order, but the {0}-th element is {1} " +
                        "whereas {2}-th is {3}",
                        intVar - 1, double[]Var[intVar - 1], intVar, double[]Var[intVar]);
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.interpolation.LoessInterpolator <441, 447>
if (i >= 1 && xval[i - 1] >= xval[i]) {
                throw new MathException(
                        "the abscissae array must be sorted in a strictly " +
                        "increasing order, but the {0}-th element is {1} " +
                        "whereas {2}-th is {3}",
                        i - 1, xval[i - 1], i, xval[i]);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.HypergeometricDistributionImpl <206, 218>
if (x < domain[0] || x > domain[1]) {
            ret = 0.0;
        } else {
            double p = (double) sampleSize / (double) m;
            double q = (double) (m - sampleSize) / (double) m;
            double p1 = SaddlePointExpansion.logBinomialProbability(x,
                    numberOfSuccesses, p, q);
            double p2 =
                SaddlePointExpansion.logBinomialProbability(sampleSize - x, f, p, q);
            double p3 =
                SaddlePointExpansion.logBinomialProbability(sampleSize, m, p, q);
            ret = Math.exp(p1 + p2 - p3);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.HypergeometricDistributionImpl <206, 218>
if (intVar < int[]Var[0] || intVar > int[]Var[1]) {
            doubleVar = 0.0;
        } else {
            double p = (double) intVar / (double) intVar;
            double q = (double) (intVar - intVar) / (double) intVar;
            double p1 = SaddlePointExpansion.logBinomialProbability(intVar,
                    intVar, p, q);
            double p2 =
                SaddlePointExpansion.logBinomialProbability(intVar - intVar, intVar, p, q);
            double p3 =
                SaddlePointExpansion.logBinomialProbability(intVar, intVar, p, q);
            doubleVar = Math.exp(p1 + p2 - p3);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.distribution.HypergeometricDistributionImpl <206, 218>
if (x < domain[0] || x > domain[1]) {
            ret = 0.0;
        } else {
            double p = (double) sampleSize / (double) m;
            double q = (double) (m - sampleSize) / (double) m;
            double p1 = SaddlePointExpansion.logBinomialProbability(x,
                    numberOfSuccesses, p, q);
            double p2 =
                SaddlePointExpansion.logBinomialProbability(sampleSize - x, f, p, q);
            double p3 =
                SaddlePointExpansion.logBinomialProbability(sampleSize, m, p, q);
            ret = Math.exp(p1 + p2 - p3);
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SparseFieldVector <596, 606>
final int prime = 31;
int result = 1;
result = prime * result + ((field == null) ? 0 : field.hashCode());
result = prime * result + virtualSize;
OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();
while (iter.hasNext()) {
            iter.advance();
            int temp = iter.value().hashCode();
            result = prime * result + temp;
        }
return result;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.SparseFieldVector <596, 606>
final int intVar = 31;
int intVar = 1;
intVar = intVar * intVar + ((Field == null) ? 0 : Field.hashCode());
intVar = intVar * intVar + intVar;
OpenIntToFieldHashMap<T>.Iterator OpenIntToFieldHashMap = OpenIntToFieldHashMap.iterator();
while (OpenIntToFieldHashMap.hasNext()) {
            OpenIntToFieldHashMap.advance();
            int temp = OpenIntToFieldHashMap.value().hashCode();
            intVar = intVar * intVar + temp;
        }
return intVar;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.SparseFieldVector <596, 606>
final int prime = 31;
int result = 1;
result = prime * result + ((Field == null) ? 0 : Field.hashCode());
result = prime * result + virtualSize;
OpenIntToFieldHashMap<T>.Iterator OpenIntToFieldHashMap = OpenIntToFieldHashMap.iterator();
while (OpenIntToFieldHashMap.hasNext()) {
            OpenIntToFieldHashMap.advance();
            int temp = OpenIntToFieldHashMap.value().hashCode();
            result = prime * result + temp;
        }
return result;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.geometry.Rotation <548, 552>
if ((q0 < -0.1) || (q0 > 0.1)) {
      return 2 * Math.asin(Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3));
    } else if (q0 < 0) {
      return 2 * Math.acos(-q0);
    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.geometry.Rotation <548, 552>
if ((q0 < -0.1) || (q0 > 0.1)) {
      return 2 * Math.asin(Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3));
    } else if (q0 < 0) {
      return 2 * Math.acos(-q0);
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.BetaDistributionImpl <104, 113>
if (x == 1) {
            if (beta < 1) {
                throw new MathException("Cannot compute beta density at 1 when beta = %.3g", beta);
            }
            return 0;
        } else {
            double logX = Math.log(x);
            double log1mX = Math.log1p(-x);
            return Math.exp((alpha - 1) * logX + (beta - 1) * log1mX - z);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.BetaDistributionImpl <104, 113>
if (DoubleVar == 1) {
            if (doubleVar < 1) {
                throw new MathException("Cannot compute beta density at 1 when beta = %.3g", doubleVar);
            }
            return 0;
        } else {
            double logX = Math.log(DoubleVar);
            double log1mX = Math.log1p(-DoubleVar);
            return Math.exp((doubleVar - 1) * logX + (doubleVar - 1) * log1mX - doubleVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.distribution.BetaDistributionImpl <104, 113>
if (x == 1) {
            if (beta < 1) {
                throw new MathException("Cannot compute beta density at 1 when beta = %.3g", beta);
            }
            return 0;
        } else {
            double logX = Math.log(x);
            double log1mX = Math.log1p(-x);
            return Math.exp((alpha - 1) * logX + (beta - 1) * log1mX - z);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.ContinuousOutputModel <151, 154>
if (Math.abs(gap) > 1.0e-3 * Math.abs(step)) {
        throw MathRuntimeException.createIllegalArgumentException(
              "{0} wide hole between models time ranges", Math.abs(gap));
      }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.ContinuousOutputModel <151, 154>
if (Math.abs(doubleVar) > 1.0e-3 * Math.abs(doubleVar)) {
        throw MathRuntimeException.createIllegalArgumentException(
              "{0} wide hole between models time ranges", Math.abs(doubleVar));
      }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.ContinuousOutputModel <151, 154>
if (Math.abs(gap) > 1.0e-3 * Math.abs(step)) {
        throw MathRuntimeException.createIllegalArgumentException(
              "{0} wide hole between models time ranges", Math.abs(gap));
      }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Skewness <107, 113>
if (variance < 10E-20) {
            return 0.0d;
        } else {
            double n0 = moment.getN();
            return  (n0 * moment.m3) /
            ((n0 - 1) * (n0 -2) * Math.sqrt(variance) * variance);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Skewness <107, 113>
if (doubleVar < 10E-20) {
            return 0.0d;
        } else {
            double n0 = SecondMoment.getN();
            return  (n0 * SecondMoment.m3) /
            ((n0 - 1) * (n0 -2) * Math.sqrt(doubleVar) * doubleVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.Skewness <107, 113>
if (variance < 10E-20) {
            return 0.0d;
        } else {
            double n0 = SecondMoment.getN();
            return  (n0 * SecondMoment.m3) /
            ((n0 - 1) * (n0 -2) * Math.sqrt(variance) * variance);
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <1237, 1247>
try {
            final int iBlock = row    / BLOCK_SIZE;
            final int jBlock = column / BLOCK_SIZE;
            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +
                               (column - jBlock * BLOCK_SIZE);
            return blocks[iBlock * blockColumns + jBlock][k];
        } catch (ArrayIndexOutOfBoundsException e) {
            throw new MatrixIndexException(
                    "no entry at indices ({0}, {1}) in a {2}x{3} matrix",
                    row, column, getRowDimension(), getColumnDimension());
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockRealMatrix <1237, 1247>
try {
            final int iBlock = intVar    / intVar;
            final int jBlock = intVar / intVar;
            final int k      = (intVar    - iBlock * intVar) * blockWidth(jBlock) +
                               (intVar - jBlock * intVar);
            return doubleVar[iBlock * intVar + jBlock][k];
        } catch (ArrayIndexOutOfBoundsException e) {
            throw new MatrixIndexException(
                    "no entry at indices ({0}, {1}) in a {2}x{3} matrix",
                    row, column, getRowDimension(), getColumnDimension());
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BlockRealMatrix <1237, 1247>
try {
            final int iBlock = row    / BLOCK_SIZE;
            final int jBlock = column / BLOCK_SIZE;
            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +
                               (column - jBlock * BLOCK_SIZE);
            return blocks[iBlock * blockColumns + jBlock][k];
        } catch (ArrayIndexOutOfBoundsException e) {
            throw new MatrixIndexException(
                    "no entry at indices ({0}, {1}) in a {2}x{3} matrix",
                    row, column, getRowDimension(), getColumnDimension());
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockFieldMatrix <1211, 1221>
try {
            final int iBlock = row    / BLOCK_SIZE;
            final int jBlock = column / BLOCK_SIZE;
            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +
                               (column - jBlock * BLOCK_SIZE);
            return blocks[iBlock * blockColumns + jBlock][k];
        } catch (ArrayIndexOutOfBoundsException e) {
            throw new MatrixIndexException(
                    "no entry at indices ({0}, {1}) in a {2}x{3} matrix",
                    row, column, getRowDimension(), getColumnDimension());
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockFieldMatrix <1211, 1221>
try {
            final int iBlock = intVar    / intVar;
            final int jBlock = intVar / intVar;
            final int k      = (intVar    - iBlock * intVar) * blockWidth(jBlock) +
                               (intVar - jBlock * intVar);
            return TVar[iBlock * intVar + jBlock][k];
        } catch (ArrayIndexOutOfBoundsException e) {
            throw new MatrixIndexException(
                    "no entry at indices ({0}, {1}) in a {2}x{3} matrix",
                    row, column, getRowDimension(), getColumnDimension());
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BlockFieldMatrix <1211, 1221>
try {
            final int iBlock = row    / BLOCK_SIZE;
            final int jBlock = column / BLOCK_SIZE;
            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +
                               (column - jBlock * BLOCK_SIZE);
            return blocks[iBlock * blockColumns + jBlock][k];
        } catch (ArrayIndexOutOfBoundsException e) {
            throw new MatrixIndexException(
                    "no entry at indices ({0}, {1}) in a {2}x{3} matrix",
                    row, column, getRowDimension(), getColumnDimension());
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.BrentSolver <173, 182>
if (Math.abs(yMax) <= functionValueAccuracy) {
                setResult(max, 0);
                ret = max;
            } else {
                // neither value is close to zero and min and max do not bracket root.
                throw MathRuntimeException.createIllegalArgumentException(
                        "function values at endpoints do not have different signs.  " +
                        "Endpoints: [{0}, {1}], Values: [{2}, {3}]",
                        min, max, yMin, yMax);
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.solvers.BrentSolver <173, 182>
if (Math.abs(doubleVar) <= doubleVar) {
                setResult(doubleVar, 0);
                doubleVar = doubleVar;
            } else {
                // neither value is close to zero and min and max do not bracket root.
                throw MathRuntimeException.createIllegalArgumentException(
                        "function values at endpoints do not have different signs.  " +
                        "Endpoints: [{0}, {1}], Values: [{2}, {3}]",
                        doubleVar, doubleVar, doubleVar, doubleVar);
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.solvers.BrentSolver <173, 182>
if (Math.abs(yMax) <= functionValueAccuracy) {
                setResult(max, 0);
                ret = max;
            } else {
                // neither value is close to zero and min and max do not bracket root.
                throw MathRuntimeException.createIllegalArgumentException(
                        "function values at endpoints do not have different signs.  " +
                        "Endpoints: [{0}, {1}], Values: [{2}, {3}]",
                        min, max, yMin, yMax);
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.geometry.Vector3D <527, 530>
final double doubleVar = Vector3DVar.doubleVar - Vector3DVar.doubleVar;
final double doubleVar = Vector3DVar.doubleVar - Vector3DVar.doubleVar;
final double doubleVar = Vector3DVar.doubleVar - Vector3DVar.doubleVar;
return doubleVar * doubleVar + doubleVar * doubleVar + doubleVar * doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.geometry.Vector3D <527, 530>
final double dx = Vector3D.x - Vector3D.x;
final double dy = Vector3D.y - Vector3D.y;
final double dz = Vector3D.z - Vector3D.z;
return dx * dx + dy * dy + dz * dz;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.clustering.EuclideanIntegerPoint <95, 99>
int hashCode = 0;
for (Integer i : point) {
            hashCode += i.hashCode() * 13 + 7;
        }
return hashCode;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.clustering.EuclideanIntegerPoint <95, 99>
int intVar = 0;
for (Integer i : int[]Var) {
            intVar += int.hashCode() * 13 + 7;
        }
return intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.clustering.EuclideanIntegerPoint <95, 99>
int hashCode = 0;
for (Integer i : point) {
            hashCode += i.hashCode() * 13 + 7;
        }
return hashCode;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.geometry.Vector3D <497, 500>
final double doubleVar = Vector3DVar.doubleVar - Vector3DVar.doubleVar;
final double doubleVar = Vector3DVar.doubleVar - Vector3DVar.doubleVar;
final double doubleVar = Vector3DVar.doubleVar - Vector3DVar.doubleVar;
return Math.sqrt(doubleVar * doubleVar + doubleVar * doubleVar + doubleVar * doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.geometry.Vector3D <497, 500>
final double dx = Vector3D.x - Vector3D.x;
final double dy = Vector3D.y - Vector3D.y;
final double dz = Vector3D.z - Vector3D.z;
return Math.sqrt(dx * dx + dy * dy + dz * dz);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.special.Gamma <292, 296>
if (x > 0 && x <= S_LIMIT) {
            // use method 5 from Bernardo AS103
            // accurate to O(x)
            return -GAMMA - 1 / x;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.special.Gamma <292, 296>
if (doubleVar > 0 && doubleVar <= doubleVar) {
            // use method 5 from Bernardo AS103
            // accurate to O(x)
            return -doubleVar - 1 / doubleVar;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.special.Gamma <292, 296>
if (x > 0 && x <= S_LIMIT) {
            // use method 5 from Bernardo AS103
            // accurate to O(x)
            return -GAMMA - 1 / x;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <307, 349>
if ((n == k) || (k == 0)) {
            return 0;
        }
if ((k == 1) || (k == n - 1)) {
            return Math.log(n);
        }
empty line
/*
* For values small enough to do exact integer computation,
* return the log of the exact value
*/
if (n < 67) {
            return Math.log(binomialCoefficient(n,k));
        }
empty line
/*
* Return the log of binomialCoefficientDouble for values that will not
* overflow binomialCoefficientDouble
*/
if (n < 1030) {
            return Math.log(binomialCoefficientDouble(n, k));
        }
empty line
if (k > n / 2) {
            return binomialCoefficientLog(n, n - k);
        }
empty line
/*
* Sum logs for values that could overflow
*/
double logSum = 0;
empty line
// n!/(n-k)!
for (int i = n - k + 1; i <= n; i++) {
            logSum += Math.log(i);
        }
empty line
// divide by k!
for (int i = 2; i <= k; i++) {
            logSum -= Math.log(i);
        }
empty line
return logSum;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <307, 349>
if ((intVar == intVar) || (intVar == 0)) {
            return 0;
        }
if ((intVar == 1) || (intVar == intVar - 1)) {
            return Math.log(intVar);
        }
empty line
/*
* For values small enough to do exact integer computation,
* return the log of the exact value
*/
if (intVar < 67) {
            return Math.log(binomialCoefficient(intVar,intVar));
        }
empty line
/*
* Return the log of binomialCoefficientDouble for values that will not
* overflow binomialCoefficientDouble
*/
if (intVar < 1030) {
            return Math.log(binomialCoefficientDouble(intVar, intVar));
        }
empty line
if (intVar > intVar / 2) {
            return binomialCoefficientLog(intVar, intVar - intVar);
        }
empty line
/*
* Sum logs for values that could overflow
*/
double doubleVar = 0;
empty line
// n!/(n-k)!
for (int intVar = intVar - intVar + 1; intVar <= intVar; intVar++) {
            doubleVar += Math.log(intVar);
        }
empty line
// divide by k!
for (int intVar = 2; intVar <= intVar; intVar++) {
            doubleVar -= Math.log(intVar);
        }
empty line
return doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <307, 349>
if ((n == k) || (k == 0)) {
            return 0;
        }
if ((k == 1) || (k == n - 1)) {
            return Math.log(n);
        }
empty line
/*
* For values small enough to do exact integer computation,
* return the log of the exact value
*/
if (n < 67) {
            return Math.log(binomialCoefficient(n,k));
        }
empty line
/*
* Return the log of binomialCoefficientDouble for values that will not
* overflow binomialCoefficientDouble
*/
if (n < 1030) {
            return Math.log(binomialCoefficientDouble(n, k));
        }
empty line
if (k > n / 2) {
            return binomialCoefficientLog(n, n - k);
        }
empty line
/*
* Sum logs for values that could overflow
*/
double logSum = 0;
empty line
// n!/(n-k)!
for (int i = n - k + 1; i <= n; i++) {
            logSum += Math.log(i);
        }
empty line
// divide by k!
for (int i = 2; i <= k; i++) {
            logSum -= Math.log(i);
        }
empty line
return logSum;

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.OpenMapRealVector <1243, 1255>
final int prime = 31;
int result = 1;
long temp;
temp = Double.doubleToLongBits(epsilon);
result = prime * result + (int) (temp ^ (temp >>> 32));
result = prime * result + virtualSize;
Iterator iter = entries.iterator();
while (iter.hasNext()) {
            iter.advance();
            temp = Double.doubleToLongBits(iter.value());
            result = prime * result + (int) (temp ^ (temp >>32));
        }
return result;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.OpenMapRealVector <1243, 1255>
final int intVar = 31;
int intVar = 1;
long longVar;
longVar = Double.doubleToLongBits(doubleVar);
intVar = intVar * intVar + (int) (longVar ^ (longVar >>> 32));
intVar = intVar * intVar + intVar;
Iterator Iterator = OpenIntToDoubleHashMap.iterator();
while (Iterator.hasNext()) {
            Iterator.advance();
            longVar = Double.doubleToLongBits(Iterator.value());
            intVar = intVar * intVar + (int) (longVar ^ (longVar >>32));
        }
return intVar;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.OpenMapRealVector <1243, 1255>
final int prime = 31;
int result = 1;
long temp;
temp = Double.doubleToLongBits(epsilon);
result = prime * result + (int) (temp ^ (temp >>> 32));
result = prime * result + virtualSize;
Iterator Iterator = OpenIntToDoubleHashMap.iterator();
while (Iterator.hasNext()) {
            Iterator.advance();
            temp = Double.doubleToLongBits(Iterator.value());
            result = prime * result + (int) (temp ^ (temp >>32));
        }
return result;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.Fraction <607, 633>
if (denominator == 0) {
            throw MathRuntimeException.createArithmeticException(
                    "zero denominator in fraction {0}/{1}",
                    numerator, denominator);
        }
if (numerator==0) {
            return ZERO; // normalize zero.
        }
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {
            numerator/=2; denominator/=2;
        }
if (denominator < 0) {
            if (numerator==Integer.MIN_VALUE ||
                    denominator==Integer.MIN_VALUE) {
                throw MathRuntimeException.createArithmeticException(
                        "overflow in fraction {0}/{1}, cannot negate",
                        numerator, denominator);
            }
            numerator = -numerator;
            denominator = -denominator;
        }
// simplify fraction.
int gcd = MathUtils.gcd(numerator, denominator);
numerator /= gcd;
denominator /= gcd;
return new Fraction(numerator, denominator);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.fraction.Fraction <607, 633>
if (intVar == 0) {
            throw MathRuntimeException.createArithmeticException(
                    "zero denominator in fraction {0}/{1}",
                    intVar, intVar);
        }
if (intVar==0) {
            return Number; // normalize zero.
        }
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (intVar==Integer.MIN_VALUE && (intVar&1)==0) {
            intVar/=2; intVar/=2;
        }
if (intVar < 0) {
            if (intVar==Integer.MIN_VALUE ||
                    intVar==Integer.MIN_VALUE) {
                throw MathRuntimeException.createArithmeticException(
                        "overflow in fraction {0}/{1}, cannot negate",
                        intVar, intVar);
            }
            intVar = -intVar;
            intVar = -intVar;
        }
// simplify fraction.
int intVar = MathUtils.gcd(intVar, intVar);
intVar /= intVar;
intVar /= intVar;
return new Fraction(intVar, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.fraction.Fraction <607, 633>
if (denominator == 0) {
            throw MathRuntimeException.createArithmeticException(
                    "zero denominator in fraction {0}/{1}",
                    numerator, denominator);
        }
if (numerator==0) {
            return null; // normalize zero.
        }
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {
            numerator/=2; denominator/=2;
        }
if (denominator < 0) {
            if (numerator==Integer.MIN_VALUE ||
                    denominator==Integer.MIN_VALUE) {
                throw MathRuntimeException.createArithmeticException(
                        "overflow in fraction {0}/{1}, cannot negate",
                        numerator, denominator);
            }
            numerator = -numerator;
            denominator = -denominator;
        }
// simplify fraction.
int gcd = MathUtils.gcd(numerator, denominator);
numerator /= gcd;
denominator /= gcd;
return new Fraction(numerator, denominator);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.Fraction <607, 633>
if (denominator == 0) {
            throw MathRuntimeException.createArithmeticException(
                    "zero denominator in fraction {0}/{1}",
                    numerator, denominator);
        }
if (numerator==0) {
            return ZERO; // normalize zero.
        }
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {
            numerator/=2; denominator/=2;
        }
if (denominator < 0) {
            if (numerator==Integer.MIN_VALUE ||
                    denominator==Integer.MIN_VALUE) {
                throw MathRuntimeException.createArithmeticException(
                        "overflow in fraction {0}/{1}, cannot negate",
                        numerator, denominator);
            }
            numerator = -numerator;
            denominator = -denominator;
        }
// simplify fraction.
int gcd = MathUtils.gcd(numerator, denominator);
numerator /= gcd;
denominator /= gcd;
return new Fraction(numerator, denominator);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.fraction.Fraction <607, 633>
if (intVar == 0) {
            throw MathRuntimeException.createArithmeticException(
                    "zero denominator in fraction {0}/{1}",
                    intVar, intVar);
        }
if (intVar==0) {
            return Number; // normalize zero.
        }
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (intVar==Integer.MIN_VALUE && (intVar&1)==0) {
            intVar/=2; intVar/=2;
        }
if (intVar < 0) {
            if (intVar==Integer.MIN_VALUE ||
                    intVar==Integer.MIN_VALUE) {
                throw MathRuntimeException.createArithmeticException(
                        "overflow in fraction {0}/{1}, cannot negate",
                        intVar, intVar);
            }
            intVar = -intVar;
            intVar = -intVar;
        }
// simplify fraction.
int intVar = MathUtils.gcd(intVar, intVar);
intVar /= intVar;
intVar /= intVar;
return new Fraction(intVar, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.fraction.Fraction <607, 633>
if (denominator == 0) {
            throw MathRuntimeException.createArithmeticException(
                    "zero denominator in fraction {0}/{1}",
                    numerator, denominator);
        }
if (numerator==0) {
            return null; // normalize zero.
        }
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {
            numerator/=2; denominator/=2;
        }
if (denominator < 0) {
            if (numerator==Integer.MIN_VALUE ||
                    denominator==Integer.MIN_VALUE) {
                throw MathRuntimeException.createArithmeticException(
                        "overflow in fraction {0}/{1}, cannot negate",
                        numerator, denominator);
            }
            numerator = -numerator;
            denominator = -denominator;
        }
// simplify fraction.
int gcd = MathUtils.gcd(numerator, denominator);
numerator /= gcd;
denominator /= gcd;
return new Fraction(numerator, denominator);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.fraction.Fraction <607, 633>
if (denominator == 0) {
            throw MathRuntimeException.createArithmeticException(
                    "zero denominator in fraction {0}/{1}",
                    numerator, denominator);
        }
if (numerator==0) {
            return ZERO; // normalize zero.
        }
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {
            numerator/=2; denominator/=2;
        }
if (denominator < 0) {
            if (numerator==Integer.MIN_VALUE ||
                    denominator==Integer.MIN_VALUE) {
                throw MathRuntimeException.createArithmeticException(
                        "overflow in fraction {0}/{1}, cannot negate",
                        numerator, denominator);
            }
            numerator = -numerator;
            denominator = -denominator;
        }
// simplify fraction.
int gcd = MathUtils.gcd(numerator, denominator);
numerator /= gcd;
denominator /= gcd;
return new Fraction(numerator, denominator);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.fraction.Fraction <607, 633>
if (intVar == 0) {
            throw MathRuntimeException.createArithmeticException(
                    "zero denominator in fraction {0}/{1}",
                    intVar, intVar);
        }
if (intVar==0) {
            return Number; // normalize zero.
        }
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (intVar==Integer.MIN_VALUE && (intVar&1)==0) {
            intVar/=2; intVar/=2;
        }
if (intVar < 0) {
            if (intVar==Integer.MIN_VALUE ||
                    intVar==Integer.MIN_VALUE) {
                throw MathRuntimeException.createArithmeticException(
                        "overflow in fraction {0}/{1}, cannot negate",
                        intVar, intVar);
            }
            intVar = -intVar;
            intVar = -intVar;
        }
// simplify fraction.
int intVar = MathUtils.gcd(intVar, intVar);
intVar /= intVar;
intVar /= intVar;
return new Fraction(intVar, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.fraction.Fraction <607, 633>
if (denominator == 0) {
            throw MathRuntimeException.createArithmeticException(
                    "zero denominator in fraction {0}/{1}",
                    numerator, denominator);
        }
if (numerator==0) {
            return null; // normalize zero.
        }
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {
            numerator/=2; denominator/=2;
        }
if (denominator < 0) {
            if (numerator==Integer.MIN_VALUE ||
                    denominator==Integer.MIN_VALUE) {
                throw MathRuntimeException.createArithmeticException(
                        "overflow in fraction {0}/{1}, cannot negate",
                        numerator, denominator);
            }
            numerator = -numerator;
            denominator = -denominator;
        }
// simplify fraction.
int gcd = MathUtils.gcd(numerator, denominator);
numerator /= gcd;
denominator /= gcd;
return new Fraction(numerator, denominator);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.geometry.Vector3D <482, 485>
final double doubleVar = Math.abs(Vector3DVar.doubleVar - Vector3DVar.doubleVar);
final double doubleVar = Math.abs(Vector3DVar.doubleVar - Vector3DVar.doubleVar);
final double doubleVar = Math.abs(Vector3DVar.doubleVar - Vector3DVar.doubleVar);
return doubleVar + doubleVar + doubleVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.geometry.Vector3D <482, 485>
final double dx = Math.abs(Vector3D.x - Vector3D.x);
final double dy = Math.abs(Vector3D.y - Vector3D.y);
final double dz = Math.abs(Vector3D.z - Vector3D.z);
return dx + dy + dz;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <247, 272>
if (interpolator.currentState == null) {

      yDotKLast = null;
      v         = null;
      vectorsInitialized = false;

    } else {

      final int dimension = interpolator.currentState.length;

      yDotKLast    = new double[3][];
      for (int k = 0; k < yDotKLast.length; ++k) {
        yDotKLast[k] = new double[dimension];
        System.arraycopy(interpolator.yDotKLast[k], 0, yDotKLast[k], 0,
                         dimension);
      }

      v = new double[7][];
      for (int k = 0; k < v.length; ++k) {
        v[k] = new double[dimension];
        System.arraycopy(interpolator.v[k], 0, v[k], 0, dimension);
      }

      vectorsInitialized = interpolator.vectorsInitialized;

    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <247, 272>
if (DormandPrince853StepInterpolatorVar.double[]Var == null) {

      double[][]Var = null;
      double[][]Var         = null;
      booleanVar = false;

    } else {

      final int dimension = DormandPrince853StepInterpolatorVar.double[]Var.length;

      double[][]Var    = new double[3][];
      for (int k = 0; k < double[][]Var.length; ++k) {
        double[][]Var[k] = new double[dimension];
        System.arraycopy(DormandPrince853StepInterpolatorVar.double[][]Var[k], 0, double[][]Var[k], 0,
                         dimension);
      }

      double[][]Var = new double[7][];
      for (int k = 0; k < double[][]Var.length; ++k) {
        double[][]Var[k] = new double[dimension];
        System.arraycopy(DormandPrince853StepInterpolatorVar.double[][]Var[k], 0, double[][]Var[k], 0, dimension);
      }

      booleanVar = DormandPrince853StepInterpolatorVar.booleanVar;

    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator <247, 272>
if (interpolator.currentState == null) {

      yDotKLast = null;
      v         = null;
      vectorsInitialized = false;

    } else {

      final int dimension = interpolator.currentState.length;

      yDotKLast    = new double[3][];
      for (int k = 0; k < yDotKLast.length; ++k) {
        yDotKLast[k] = new double[dimension];
        System.arraycopy(interpolator.yDotKLast[k], 0, yDotKLast[k], 0,
                         dimension);
      }

      v = new double[7][];
      for (int k = 0; k < v.length; ++k) {
        v[k] = new double[dimension];
        System.arraycopy(interpolator.v[k], 0, v[k], 0, dimension);
      }

      vectorsInitialized = interpolator.vectorsInitialized;

    }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <339, 344>
if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    destination.length, destination[0].length,
                    rowsCount, columnsCount);
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractFieldMatrix <339, 344>
if ((T[][]Var.length < intVar) || (destination[0].length < intVar)) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    T[][]Var.length, destination[0].length,
                    intVar, intVar);
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractFieldMatrix <339, 344>
if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    destination.length, destination[0].length,
                    rowsCount, columnsCount);
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <312, 317>
if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    destination.length, destination[0].length,
                    rowsCount, columnsCount);
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <312, 317>
if ((double[][]Var.length < intVar) || (destination[0].length < intVar)) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    double[][]Var.length, destination[0].length,
                    intVar, intVar);
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <312, 317>
if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    destination.length, destination[0].length,
                    rowsCount, columnsCount);
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <380, 386>
if ((destination.length < selectedRows.length) ||
            (destination[0].length < selectedColumns.length)) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    destination.length, destination[0].length,
                    selectedRows.length, selectedColumns.length);
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractFieldMatrix <380, 386>
if ((T[][]Var.length < int[]Var.length) ||
            (destination[0].length < int[]Var.length)) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    T[][]Var.length, destination[0].length,
                    int[]Var.length, int[]Var.length);
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractFieldMatrix <380, 386>
if ((destination.length < selectedRows.length) ||
            (destination[0].length < selectedColumns.length)) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    destination.length, destination[0].length,
                    selectedRows.length, selectedColumns.length);
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <353, 359>
if ((destination.length < selectedRows.length) ||
            (destination[0].length < selectedColumns.length)) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    destination.length, destination[0].length,
                    selectedRows.length, selectedColumns.length);
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <353, 359>
if ((double[][]Var.length < int[]Var.length) ||
            (destination[0].length < int[]Var.length)) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    double[][]Var.length, destination[0].length,
                    int[]Var.length, int[]Var.length);
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <353, 359>
if ((destination.length < selectedRows.length) ||
            (destination[0].length < selectedColumns.length)) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    destination.length, destination[0].length,
                    selectedRows.length, selectedColumns.length);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.geometry.Vector3D <345, 352>
if ((dot < -threshold) || (dot > threshold)) {
      // the vectors are almost aligned, compute using the sine
      Vector3D v3 = crossProduct(v1, v2);
      if (dot >= 0) {
        return Math.asin(v3.getNorm() / normProduct);
      }
      return Math.PI - Math.asin(v3.getNorm() / normProduct);
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.geometry.Vector3D <345, 352>
if ((doubleVar < -doubleVar) || (doubleVar > doubleVar)) {
      // the vectors are almost aligned, compute using the sine
      Vector3D v3 = crossProduct(Vector3DVar, Vector3DVar);
      if (doubleVar >= 0) {
        return Math.asin(v3.getNorm() / doubleVar);
      }
      return Math.PI - Math.asin(v3.getNorm() / doubleVar);
    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.geometry.Vector3D <345, 352>
if ((dot < -threshold) || (dot > threshold)) {
      // the vectors are almost aligned, compute using the sine
      Vector3D v3 = crossProduct(Vector3D, Vector3D);
      if (dot >= 0) {
        return Math.asin(v3.getNorm() / normProduct);
      }
      return Math.PI - Math.asin(v3.getNorm() / normProduct);
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.geometry.Vector3D <338, 355>
double normProduct = v1.getNorm() * v2.getNorm();
if (normProduct == 0) {
      throw MathRuntimeException.createArithmeticException("zero norm");
    }
empty line
double dot = dotProduct(v1, v2);
double threshold = normProduct * 0.9999;
if ((dot < -threshold) || (dot > threshold)) {
      // the vectors are almost aligned, compute using the sine
      Vector3D v3 = crossProduct(v1, v2);
      if (dot >= 0) {
        return Math.asin(v3.getNorm() / normProduct);
      }
      return Math.PI - Math.asin(v3.getNorm() / normProduct);
    }
empty line
// the vectors are sufficiently separated to use the cosine
return Math.acos(dot / normProduct);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.geometry.Vector3D <338, 355>
double doubleVar = Vector3DVar.getNorm() * Vector3DVar.getNorm();
if (doubleVar == 0) {
      throw MathRuntimeException.createArithmeticException("zero norm");
    }
empty line
double doubleVar = dotProduct(Vector3DVar, Vector3DVar);
double doubleVar = doubleVar * 0.9999;
if ((doubleVar < -doubleVar) || (doubleVar > doubleVar)) {
      // the vectors are almost aligned, compute using the sine
      Vector3D v3 = crossProduct(Vector3DVar, Vector3DVar);
      if (doubleVar >= 0) {
        return Math.asin(v3.getNorm() / doubleVar);
      }
      return Math.PI - Math.asin(v3.getNorm() / doubleVar);
    }
empty line
// the vectors are sufficiently separated to use the cosine
return Math.acos(doubleVar / doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.geometry.Vector3D <338, 355>
double normProduct = Vector3D.getNorm() * Vector3D.getNorm();
if (normProduct == 0) {
      throw MathRuntimeException.createArithmeticException("zero norm");
    }
empty line
double dot = dotProduct(Vector3D, Vector3D);
double threshold = normProduct * 0.9999;
if ((dot < -threshold) || (dot > threshold)) {
      // the vectors are almost aligned, compute using the sine
      Vector3D v3 = crossProduct(Vector3D, Vector3D);
      if (dot >= 0) {
        return Math.asin(v3.getNorm() / normProduct);
      }
      return Math.PI - Math.asin(v3.getNorm() / normProduct);
    }
empty line
// the vectors are sufficiently separated to use the cosine
return Math.acos(dot / normProduct);

---fix ingredient(SameFile)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <475, 498>
if (b.getRowDimension() != m) {
                throw MathRuntimeException.createIllegalArgumentException(
                        "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                        b.getRowDimension(), b.getColumnDimension(), m, "n");
            }
empty line
final int nColB = b.getColumnDimension();
final double[][] bp = new double[m][nColB];
for (int k = 0; k < nColB; ++k) {
                for (int i = 0; i < m; ++i) {
                    final ArrayRealVector v = eigenvectors[i];
                    final double[] vData = v.getDataRef();
                    double s = 0;
                    for (int j = 0; j < m; ++j) {
                        s += v.getEntry(j) * b.getEntry(j, k);
                    }
                    s /= realEigenvalues[i];
                    for (int j = 0; j < m; ++j) {
                        bp[j][k] += s * vData[j];
                    }
                }
            }
empty line
return MatrixUtils.createRealMatrix(bp);

---fix ingredient(SameFile)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <475, 498>
if (RealMatrix.getRowDimension() != intVar) {
                throw MathRuntimeException.createIllegalArgumentException(
                        "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                        RealMatrix.getRowDimension(), RealMatrix.getColumnDimension(), intVar, "n");
            }
empty line
final int intVar = RealMatrix.getColumnDimension();
final double[][] double[][]Var = new double[intVar][intVar];
for (int intVar = 0; intVar < intVar; ++intVar) {
                for (int i = 0; i < intVar; ++i) {
                    final ArrayRealVector v = ArrayRealVector[]Var[i];
                    final double[] vData = v.getDataRef();
                    double s = 0;
                    for (int j = 0; j < intVar; ++j) {
                        s += v.getEntry(j) * RealMatrix.getEntry(j, intVar);
                    }
                    s /= double[]Var[i];
                    for (int j = 0; j < intVar; ++j) {
                        double[][]Var[j][intVar] += s * vData[j];
                    }
                }
            }
empty line
return MatrixUtils.createRealMatrix(double[][]Var);

---fix ingredient(SameFile)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <475, 498>
if (RealMatrix.getRowDimension() != m) {
                throw MathRuntimeException.createIllegalArgumentException(
                        "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                        RealMatrix.getRowDimension(), RealMatrix.getColumnDimension(), m, "n");
            }
empty line
final int nColB = RealMatrix.getColumnDimension();
final double[][] bp = new double[m][nColB];
for (int k = 0; k < nColB; ++k) {
                for (int i = 0; i < m; ++i) {
                    final ArrayRealVector v = eigenvectors[i];
                    final double[] vData = v.getDataRef();
                    double s = 0;
                    for (int j = 0; j < m; ++j) {
                        s += v.getEntry(j) * RealMatrix.getEntry(j, k);
                    }
                    s /= realEigenvalues[i];
                    for (int j = 0; j < m; ++j) {
                        bp[j][k] += s * vData[j];
                    }
                }
            }
empty line
return MatrixUtils.createRealMatrix(bp);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <638, 671>
while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
if (k == 31) {
            throw MathRuntimeException.createArithmeticException(
                    "overflow: gcd({0}, {1}) is 2^31",
                    p, q);
        }
// B2. Initialize: u and v have been divided by 2^k and at least
// one is odd.
int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
// t negative: u was odd, v may be even (t replaces v)
// t positive: u was even, v is odd (t replaces u)
do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
return -u * (1 << k);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <638, 671>
while ((intVar & 1) == 0 && (intVar & 1) == 0 && intVar < 31) { // while u and v are
                                                            // both even...
            intVar /= 2;
            intVar /= 2;
            intVar++; // cast out twos.
        }
if (intVar == 31) {
            throw MathRuntimeException.createArithmeticException(
                    "overflow: gcd({0}, {1}) is 2^31",
                    intVar, intVar);
        }
// B2. Initialize: u and v have been divided by 2^k and at least
// one is odd.
int intVar = ((intVar & 1) == 1) ? intVar : -(intVar / 2)/* B3 */;
// t negative: u was odd, v may be even (t replaces v)
// t positive: u was even, v is odd (t replaces u)
do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((intVar & 1) == 0) { // while t is even..
                intVar /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (intVar > 0) {
                intVar = -intVar;
            } else {
                intVar = intVar;
            }
            // B6/B3. at this point both u and v should be odd.
            intVar = (intVar - intVar) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (intVar != 0);
return -intVar * (1 << intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <638, 671>
while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
if (k == 31) {
            throw MathRuntimeException.createArithmeticException(
                    "overflow: gcd({0}, {1}) is 2^31",
                    p, q);
        }
// B2. Initialize: u and v have been divided by 2^k and at least
// one is odd.
int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
// t negative: u was odd, v may be even (t replaces v)
// t positive: u was even, v is odd (t replaces u)
do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
return -u * (1 << k);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.distribution.NormalDistributionImpl <129, 135>
if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
                return 0.0d;
            } else if (x > (mean + 20 * standardDeviation)) {
                return 1.0d;
            } else {
                throw ex;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.distribution.NormalDistributionImpl <129, 135>
if (doubleVar < (doubleVar - 20 * doubleVar)) { // JDK 1.5 blows at 38
                return 0.0d;
            } else if (doubleVar > (doubleVar + 20 * doubleVar)) {
                return 1.0d;
            } else {
                throw ex;
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.distribution.NormalDistributionImpl <129, 135>
if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
                return 0.0d;
            } else if (x > (mean + 20 * standardDeviation)) {
                return 1.0d;
            } else {
                throw ex;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.analysis.solvers.RiddersSolver <171, 191>
if (correction > 0.0) {             // x1 < x < x3
                if (MathUtils.sign(y1) + MathUtils.sign(y) == 0.0) {
                    x2 = x;
                    y2 = y;
                } else {
                    x1 = x;
                    x2 = x3;
                    y1 = y;
                    y2 = y3;
                }
            } else {                            // x3 < x < x2
                if (MathUtils.sign(y2) + MathUtils.sign(y) == 0.0) {
                    x1 = x;
                    y1 = y;
                } else {
                    x1 = x3;
                    x2 = x;
                    y1 = y3;
                    y2 = y;
                }
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.analysis.solvers.RiddersSolver <171, 191>
if (doubleVar > 0.0) {             // x1 < x < x3
                if (MathUtils.sign(doubleVar) + MathUtils.sign(doubleVar) == 0.0) {
                    doubleVar = doubleVar;
                    doubleVar = doubleVar;
                } else {
                    doubleVar = doubleVar;
                    doubleVar = doubleVar;
                    doubleVar = doubleVar;
                    doubleVar = doubleVar;
                }
            } else {                            // x3 < x < x2
                if (MathUtils.sign(doubleVar) + MathUtils.sign(doubleVar) == 0.0) {
                    doubleVar = doubleVar;
                    doubleVar = doubleVar;
                } else {
                    doubleVar = doubleVar;
                    doubleVar = doubleVar;
                    doubleVar = doubleVar;
                    doubleVar = doubleVar;
                }
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.analysis.solvers.RiddersSolver <171, 191>
if (correction > 0.0) {             // x1 < x < x3
                if (MathUtils.sign(y1) + MathUtils.sign(y) == 0.0) {
                    x2 = x;
                    y2 = y;
                } else {
                    x1 = x;
                    x2 = x3;
                    y1 = y;
                    y2 = y3;
                }
            } else {                            // x3 < x < x2
                if (MathUtils.sign(y2) + MathUtils.sign(y) == 0.0) {
                    x1 = x;
                    y1 = y;
                } else {
                    x1 = x3;
                    x2 = x;
                    y1 = y3;
                    y2 = y;
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.geometry.Rotation <877, 886>
double x = u.getX();
double y = u.getY();
double z = u.getZ();
empty line
double s = q1 * x + q2 * y + q3 * z;
double m0 = -q0;
empty line
return new Vector3D(2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x,
                        2 * (m0 * (y * m0 - (q3 * x - q1 * z)) + s * q2) - y,
                        2 * (m0 * (z * m0 - (q1 * y - q2 * x)) + s * q3) - z);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.geometry.Rotation <877, 886>
double doubleVar = Vector3DVar.getX();
double doubleVar = Vector3DVar.getY();
double doubleVar = Vector3DVar.getZ();
empty line
double doubleVar = doubleVar * doubleVar + doubleVar * doubleVar + doubleVar * doubleVar;
double doubleVar = -doubleVar;
empty line
return new Vector3D(2 * (doubleVar * (doubleVar * doubleVar - (doubleVar * doubleVar - doubleVar * doubleVar)) + doubleVar * doubleVar) - doubleVar,
                        2 * (doubleVar * (doubleVar * doubleVar - (doubleVar * doubleVar - doubleVar * doubleVar)) + doubleVar * doubleVar) - doubleVar,
                        2 * (doubleVar * (doubleVar * doubleVar - (doubleVar * doubleVar - doubleVar * doubleVar)) + doubleVar * doubleVar) - doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.geometry.Rotation <877, 886>
double x = u.getX();
double y = u.getY();
double z = u.getZ();
empty line
double s = q1 * x + q2 * y + q3 * z;
double m0 = -q0;
empty line
return new Vector3D(2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x,
                        2 * (m0 * (y * m0 - (q3 * x - q1 * z)) + s * q2) - y,
                        2 * (m0 * (z * m0 - (q1 * y - q2 * x)) + s * q3) - z);

---fix ingredient(SameMethod)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.EigenDecompositionImpl <1569, 1582>
} else {
empty line
// case 6, no information to guide us.
if (tType == -6) {
                    g += 0.333 * (1 - g);
                } else if (tType == -18) {
                    g = 0.25 * 0.333;
                } else {
                    g = 0.25;
                }
tau   = g * dMin;
tType = -6;
empty line

---fix ingredient(SameMethod)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.EigenDecompositionImpl <1569, 1582>
} else {
empty line
// case 6, no information to guide us.
if (intVar == -6) {
                    doubleVar += 0.333 * (1 - doubleVar);
                } else if (intVar == -18) {
                    doubleVar = 0.25 * 0.333;
                } else {
                    doubleVar = 0.25;
                }
doubleVar   = doubleVar * doubleVar;
intVar = -6;
empty line

---fix ingredient(SameMethod)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.EigenDecompositionImpl <1569, 1582>
} else {
empty line
// case 6, no information to guide us.
if (tType == -6) {
                    g += 0.333 * (1 - g);
                } else if (tType == -18) {
                    g = 0.25 * 0.333;
                } else {
                    g = 0.25;
                }
tau   = g * dMin;
tType = -6;
empty line

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.geometry.Rotation <859, 867>
double x = u.getX();
double y = u.getY();
double z = u.getZ();
empty line
double s = q1 * x + q2 * y + q3 * z;
empty line
return new Vector3D(2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x,
                        2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y,
                        2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.geometry.Rotation <859, 867>
double doubleVar = Vector3DVar.getX();
double doubleVar = Vector3DVar.getY();
double doubleVar = Vector3DVar.getZ();
empty line
double doubleVar = doubleVar * doubleVar + doubleVar * doubleVar + doubleVar * doubleVar;
empty line
return new Vector3D(2 * (doubleVar * (doubleVar * doubleVar - (doubleVar * doubleVar - doubleVar * doubleVar)) + doubleVar * doubleVar) - doubleVar,
                        2 * (doubleVar * (doubleVar * doubleVar - (doubleVar * doubleVar - doubleVar * doubleVar)) + doubleVar * doubleVar) - doubleVar,
                        2 * (doubleVar * (doubleVar * doubleVar - (doubleVar * doubleVar - doubleVar * doubleVar)) + doubleVar * doubleVar) - doubleVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.geometry.Rotation <859, 867>
double x = u.getX();
double y = u.getY();
double z = u.getZ();
empty line
double s = q1 * x + q2 * y + q3 * z;
empty line
return new Vector3D(2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x,
                        2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y,
                        2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.MathUtils <617, 624>
if ((u == 0) || (v == 0)) {
            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
                throw MathRuntimeException.createArithmeticException(
                        "overflow: gcd({0}, {1}) is 2^31",
                        p, q);
            }
            return Math.abs(u) + Math.abs(v);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.MathUtils <617, 624>
if ((intVar == 0) || (intVar == 0)) {
            if ((intVar == Integer.MIN_VALUE) || (intVar == Integer.MIN_VALUE)) {
                throw MathRuntimeException.createArithmeticException(
                        "overflow: gcd({0}, {1}) is 2^31",
                        intVar, intVar);
            }
            return Math.abs(intVar) + Math.abs(intVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.MathUtils <617, 624>
if ((u == 0) || (v == 0)) {
            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
                throw MathRuntimeException.createArithmeticException(
                        "overflow: gcd({0}, {1}) is 2^31",
                        p, q);
            }
            return Math.abs(u) + Math.abs(v);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <245, 277>
alg.reset();
empty line
// Compute number of iterations required (40 bytes each)
int numIter = (len / 40) + 1;
empty line
StringBuffer outBuffer = new StringBuffer();
for (int iter = 1; iter < numIter + 1; iter++) {
            byte[] randomBytes = new byte[40];
            secRan.nextBytes(randomBytes);
            alg.update(randomBytes);

            // Compute hash -- will create 20-byte binary hash
            byte hash[] = alg.digest();

            // Loop over the hash, converting each byte to 2 hex digits
            for (int i = 0; i < hash.length; i++) {
                Integer c = Integer.valueOf(hash[i]);

                /*
                 * Add 128 to byte value to make interval 0-255 This guarantees
                 * <= 2 hex digits from toHexString() toHexString would
                 * otherwise add 2^32 to negative arguments
                 */
                String hex = Integer.toHexString(c.intValue() + 128);

                // Keep strings uniform length -- guarantees 40 bytes
                if (hex.length() == 1) {
                    hex = "0" + hex;
                }
                outBuffer.append(hex);
            }
        }
return outBuffer.toString().substring(0, len);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.RandomDataImpl <245, 277>
MessageDigest.reset();
empty line
// Compute number of iterations required (40 bytes each)
int intVar = (intVar / 40) + 1;
empty line
StringBuffer StringBuffer = new StringBuffer();
for (int intVar = 1; intVar < intVar + 1; intVar++) {
            byte[] randomBytes = new byte[40];
            SecureRandom.nextBytes(randomBytes);
            MessageDigest.update(randomBytes);

            // Compute hash -- will create 20-byte binary hash
            byte hash[] = MessageDigest.digest();

            // Loop over the hash, converting each byte to 2 hex digits
            for (int i = 0; i < hash.length; i++) {
                Integer c = Integer.valueOf(hash[i]);

                /*
                 * Add 128 to byte value to make interval 0-255 This guarantees
                 * <= 2 hex digits from toHexString() toHexString would
                 * otherwise add 2^32 to negative arguments
                 */
                String hex = Integer.toHexString(c.intValue() + 128);

                // Keep strings uniform length -- guarantees 40 bytes
                if (hex.length() == 1) {
                    hex = "0" + hex;
                }
                StringBuffer.append(hex);
            }
        }
return StringBuffer.toString().substring(0, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.RandomDataImpl <245, 277>
MessageDigest.reset();
empty line
// Compute number of iterations required (40 bytes each)
int numIter = (len / 40) + 1;
empty line
StringBuffer StringBuffer = new StringBuffer();
for (int iter = 1; iter < numIter + 1; iter++) {
            byte[] randomBytes = new byte[40];
            SecureRandom.nextBytes(randomBytes);
            MessageDigest.update(randomBytes);

            // Compute hash -- will create 20-byte binary hash
            byte hash[] = MessageDigest.digest();

            // Loop over the hash, converting each byte to 2 hex digits
            for (int i = 0; i < hash.length; i++) {
                Integer c = Integer.valueOf(hash[i]);

                /*
                 * Add 128 to byte value to make interval 0-255 This guarantees
                 * <= 2 hex digits from toHexString() toHexString would
                 * otherwise add 2^32 to negative arguments
                 */
                String hex = Integer.toHexString(c.intValue() + 128);

                // Keep strings uniform length -- guarantees 40 bytes
                if (hex.length() == 1) {
                    hex = "0" + hex;
                }
                StringBuffer.append(hex);
            }
        }
return StringBuffer.toString().substring(0, len);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.TransformerMap <186, 190>
int hash = defaultTransformer.hashCode();
for (NumberTransformer t : map.values()) {
            hash = hash * 31 + t.hashCode();
        }
return hash;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.TransformerMap <186, 190>
int intVar = NumberTransformer.hashCode();
for (NumberTransformer t : Map.values()) {
            intVar = intVar * 31 + NumberTransformer.hashCode();
        }
return intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.TransformerMap <186, 190>
int hash = NumberTransformer.hashCode();
for (NumberTransformer t : Map.values()) {
            hash = hash * 31 + NumberTransformer.hashCode();
        }
return hash;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.util.ResizableDoubleArray <710, 716>
if (expansionMode != MULTIPLICATIVE_MODE &&
                expansionMode != ADDITIVE_MODE) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "unsupported expansion mode {0}, supported modes are {1} ({2}) and {3} ({4})",
                    expansionMode, MULTIPLICATIVE_MODE, "MULTIPLICATIVE_MODE",
                    ADDITIVE_MODE, "ADDITIVE_MODE");
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.util.ResizableDoubleArray <710, 716>
if (intVar != intVar &&
                intVar != intVar) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "unsupported expansion mode {0}, supported modes are {1} ({2}) and {3} ({4})",
                    intVar, intVar, "MULTIPLICATIVE_MODE",
                    intVar, "ADDITIVE_MODE");
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.util.ResizableDoubleArray <710, 716>
if (expansionMode != MULTIPLICATIVE_MODE &&
                expansionMode != ADDITIVE_MODE) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "unsupported expansion mode {0}, supported modes are {1} ({2}) and {3} ({4})",
                    expansionMode, MULTIPLICATIVE_MODE, "MULTIPLICATIVE_MODE",
                    ADDITIVE_MODE, "ADDITIVE_MODE");
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.geometry.Rotation <439, 455>
if (dot < ((2.0e-15 - 1.0) * normProduct)) {
      // special case u = -v: we select a PI angle rotation around
      // an arbitrary vector orthogonal to u
      Vector3D w = u.orthogonal();
      q0 = 0.0;
      q1 = -w.getX();
      q2 = -w.getY();
      q3 = -w.getZ();
    } else {
      // general case: (u, v) defines a plane, we select
      // the shortest possible rotation: axis orthogonal to this plane
      q0 = Math.sqrt(0.5 * (1.0 + dot / normProduct));
      double coeff = 1.0 / (2.0 * q0 * normProduct);
      q1 = coeff * (v.getY() * u.getZ() - v.getZ() * u.getY());
      q2 = coeff * (v.getZ() * u.getX() - v.getX() * u.getZ());
      q3 = coeff * (v.getX() * u.getY() - v.getY() * u.getX());
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.geometry.Rotation <439, 455>
if (doubleVar < ((2.0e-15 - 1.0) * doubleVar)) {
      // special case u = -v: we select a PI angle rotation around
      // an arbitrary vector orthogonal to u
      Vector3D w = Vector3DVar.orthogonal();
      doubleVar = 0.0;
      doubleVar = -w.getX();
      doubleVar = -w.getY();
      doubleVar = -w.getZ();
    } else {
      // general case: (u, v) defines a plane, we select
      // the shortest possible rotation: axis orthogonal to this plane
      doubleVar = Math.sqrt(0.5 * (1.0 + doubleVar / doubleVar));
      double coeff = 1.0 / (2.0 * doubleVar * doubleVar);
      doubleVar = coeff * (Vector3DVar.getY() * Vector3DVar.getZ() - Vector3DVar.getZ() * Vector3DVar.getY());
      doubleVar = coeff * (Vector3DVar.getZ() * Vector3DVar.getX() - Vector3DVar.getX() * Vector3DVar.getZ());
      doubleVar = coeff * (Vector3DVar.getX() * Vector3DVar.getY() - Vector3DVar.getY() * Vector3DVar.getX());
    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.geometry.Rotation <439, 455>
if (dot < ((2.0e-15 - 1.0) * normProduct)) {
      // special case u = -v: we select a PI angle rotation around
      // an arbitrary vector orthogonal to u
      Vector3D w = u.orthogonal();
      q0 = 0.0;
      q1 = -w.getX();
      q2 = -w.getY();
      q3 = -w.getZ();
    } else {
      // general case: (u, v) defines a plane, we select
      // the shortest possible rotation: axis orthogonal to this plane
      q0 = Math.sqrt(0.5 * (1.0 + dot / normProduct));
      double coeff = 1.0 / (2.0 * q0 * normProduct);
      q1 = coeff * (v.getY() * u.getZ() - v.getZ() * u.getY());
      q2 = coeff * (v.getZ() * u.getX() - v.getX() * u.getZ());
      q3 = coeff * (v.getX() * u.getY() - v.getY() * u.getX());
    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.descriptive.moment.Skewness <103, 105>
if (moment.n < 3) {
            return Double.NaN;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.descriptive.moment.Skewness <103, 105>
if (SecondMoment.n < 3) {
            return Double.NaN;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.descriptive.moment.Skewness <103, 105>
if (SecondMoment.n < 3) {
            return Double.NaN;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.stat.regression.SimpleRegression <411, 414>
if (n < 3) {
            return Double.NaN;
        }
return getSumSquaredErrors() / (n - 2);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.stat.regression.SimpleRegression <411, 414>
if (longVar < 3) {
            return Double.NaN;
        }
return getSumSquaredErrors() / (longVar - 2);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.stat.regression.SimpleRegression <411, 414>
if (n < 3) {
            return Double.NaN;
        }
return getSumSquaredErrors() / (n - 2);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SingularValueDecompositionImpl <419, 437>
if (b.getRowDimension() != singularValues.length) {
                throw MathRuntimeException.createIllegalArgumentException(
                        "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                        b.getRowDimension(), b.getColumnDimension(),
                        singularValues.length, "n");
            }
empty line
final RealMatrix w = uT.multiply(b);
for (int i = 0; i < singularValues.length; ++i) {
                final double si  = singularValues[i];
                if (si == 0) {
                    throw new SingularMatrixException();
                }
                final double inv = 1.0 / si;
                for (int j = 0; j < b.getColumnDimension(); ++j) {
                    w.multiplyEntry(i, j, inv);
                }
            }
return v.multiply(w);

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.SingularValueDecompositionImpl <419, 437>
if (RealMatrix.getRowDimension() != double[]Var.length) {
                throw MathRuntimeException.createIllegalArgumentException(
                        "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                        RealMatrix.getRowDimension(), RealMatrix.getColumnDimension(),
                        double[]Var.length, "n");
            }
empty line
final RealMatrix RealMatrix = RealMatrix.multiply(RealMatrix);
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
                final double si  = double[]Var[intVar];
                if (si == 0) {
                    throw new SingularMatrixException();
                }
                final double inv = 1.0 / si;
                for (int j = 0; j < RealMatrix.getColumnDimension(); ++j) {
                    RealMatrix.multiplyEntry(intVar, j, inv);
                }
            }
return RealMatrix.multiply(RealMatrix);

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.SingularValueDecompositionImpl <419, 437>
if (RealMatrix.getRowDimension() != singularValues.length) {
                throw MathRuntimeException.createIllegalArgumentException(
                        "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                        RealMatrix.getRowDimension(), RealMatrix.getColumnDimension(),
                        singularValues.length, "n");
            }
empty line
final RealMatrix RealMatrix = RealMatrix.multiply(RealMatrix);
for (int i = 0; i < singularValues.length; ++i) {
                final double si  = singularValues[i];
                if (si == 0) {
                    throw new SingularMatrixException();
                }
                final double inv = 1.0 / si;
                for (int j = 0; j < RealMatrix.getColumnDimension(); ++j) {
                    RealMatrix.multiplyEntry(i, j, inv);
                }
            }
return RealMatrix.multiply(RealMatrix);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.SingularValueDecompositionImpl <419, 437>
if (b.getRowDimension() != singularValues.length) {
                throw MathRuntimeException.createIllegalArgumentException(
                        "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                        b.getRowDimension(), b.getColumnDimension(),
                        singularValues.length, "n");
            }
empty line
final RealMatrix w = uT.multiply(b);
for (int i = 0; i < singularValues.length; ++i) {
                final double si  = singularValues[i];
                if (si == 0) {
                    throw new SingularMatrixException();
                }
                final double inv = 1.0 / si;
                for (int j = 0; j < b.getColumnDimension(); ++j) {
                    w.multiplyEntry(i, j, inv);
                }
            }
return v.multiply(w);

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.SingularValueDecompositionImpl <419, 437>
if (RealMatrix.getRowDimension() != double[]Var.length) {
                throw MathRuntimeException.createIllegalArgumentException(
                        "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                        RealMatrix.getRowDimension(), RealMatrix.getColumnDimension(),
                        double[]Var.length, "n");
            }
empty line
final RealMatrix RealMatrix = RealMatrix.multiply(RealMatrix);
for (int intVar = 0; intVar < double[]Var.length; ++intVar) {
                final double si  = double[]Var[intVar];
                if (si == 0) {
                    throw new SingularMatrixException();
                }
                final double inv = 1.0 / si;
                for (int j = 0; j < RealMatrix.getColumnDimension(); ++j) {
                    RealMatrix.multiplyEntry(intVar, j, inv);
                }
            }
return RealMatrix.multiply(RealMatrix);

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.SingularValueDecompositionImpl <419, 437>
if (RealMatrix.getRowDimension() != singularValues.length) {
                throw MathRuntimeException.createIllegalArgumentException(
                        "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                        RealMatrix.getRowDimension(), RealMatrix.getColumnDimension(),
                        singularValues.length, "n");
            }
empty line
final RealMatrix RealMatrix = RealMatrix.multiply(RealMatrix);
for (int i = 0; i < singularValues.length; ++i) {
                final double si  = singularValues[i];
                if (si == 0) {
                    throw new SingularMatrixException();
                }
                final double inv = 1.0 / si;
                for (int j = 0; j < RealMatrix.getColumnDimension(); ++j) {
                    RealMatrix.multiplyEntry(i, j, inv);
                }
            }
return RealMatrix.multiply(RealMatrix);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <135, 167>
if (len <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "length must be positive ({0})", len);
        }
empty line
// Get a random number generator
RandomGenerator ran = getRan();
empty line
// Initialize output buffer
StringBuffer outBuffer = new StringBuffer();
empty line
// Get int(len/2)+1 random bytes
byte[] randomBytes = new byte[(len / 2) + 1];
ran.nextBytes(randomBytes);
empty line
// Convert each byte to 2 hex digits
for (int i = 0; i < randomBytes.length; i++) {
            Integer c = Integer.valueOf(randomBytes[i]);

            /*
             * Add 128 to byte value to make interval 0-255 before doing hex
             * conversion. This guarantees <= 2 hex digits from toHexString()
             * toHexString would otherwise add 2^32 to negative arguments.
             */
            String hex = Integer.toHexString(c.intValue() + 128);

            // Make sure we add 2 hex digits for each byte
            if (hex.length() == 1) {
                hex = "0" + hex;
            }
            outBuffer.append(hex);
        }
return outBuffer.toString().substring(0, len);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.RandomDataImpl <135, 167>
if (intVar <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "length must be positive ({0})", intVar);
        }
empty line
// Get a random number generator
RandomGenerator RandomGenerator = getRan();
empty line
// Initialize output buffer
StringBuffer StringBuffer = new StringBuffer();
empty line
// Get int(len/2)+1 random bytes
byte[] byte[]Var = new byte[(intVar / 2) + 1];
RandomGenerator.nextBytes(byte[]Var);
empty line
// Convert each byte to 2 hex digits
for (int intVar = 0; intVar < byte[]Var.length; intVar++) {
            Integer c = Integer.valueOf(byte[]Var[intVar]);

            /*
             * Add 128 to byte value to make interval 0-255 before doing hex
             * conversion. This guarantees <= 2 hex digits from toHexString()
             * toHexString would otherwise add 2^32 to negative arguments.
             */
            String hex = Integer.toHexString(c.intValue() + 128);

            // Make sure we add 2 hex digits for each byte
            if (hex.length() == 1) {
                hex = "0" + hex;
            }
            StringBuffer.append(hex);
        }
return StringBuffer.toString().substring(0, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.RandomDataImpl <135, 167>
if (len <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "length must be positive ({0})", len);
        }
empty line
// Get a random number generator
RandomGenerator RandomGenerator = getRan();
empty line
// Initialize output buffer
StringBuffer StringBuffer = new StringBuffer();
empty line
// Get int(len/2)+1 random bytes
byte[] randomBytes = new byte[(len / 2) + 1];
RandomGenerator.nextBytes(randomBytes);
empty line
// Convert each byte to 2 hex digits
for (int i = 0; i < randomBytes.length; i++) {
            Integer c = Integer.valueOf(randomBytes[i]);

            /*
             * Add 128 to byte value to make interval 0-255 before doing hex
             * conversion. This guarantees <= 2 hex digits from toHexString()
             * toHexString would otherwise add 2^32 to negative arguments.
             */
            String hex = Integer.toHexString(c.intValue() + 128);

            // Make sure we add 2 hex digits for each byte
            if (hex.length() == 1) {
                hex = "0" + hex;
            }
            StringBuffer.append(hex);
        }
return StringBuffer.toString().substring(0, len);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.random.RandomDataImpl <135, 167>
if (len <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "length must be positive ({0})", len);
        }
empty line
// Get a random number generator
RandomGenerator ran = getRan();
empty line
// Initialize output buffer
StringBuffer outBuffer = new StringBuffer();
empty line
// Get int(len/2)+1 random bytes
byte[] randomBytes = new byte[(len / 2) + 1];
ran.nextBytes(randomBytes);
empty line
// Convert each byte to 2 hex digits
for (int i = 0; i < randomBytes.length; i++) {
            Integer c = Integer.valueOf(randomBytes[i]);

            /*
             * Add 128 to byte value to make interval 0-255 before doing hex
             * conversion. This guarantees <= 2 hex digits from toHexString()
             * toHexString would otherwise add 2^32 to negative arguments.
             */
            String hex = Integer.toHexString(c.intValue() + 128);

            // Make sure we add 2 hex digits for each byte
            if (hex.length() == 1) {
                hex = "0" + hex;
            }
            outBuffer.append(hex);
        }
return outBuffer.toString().substring(0, len);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.random.RandomDataImpl <135, 167>
if (intVar <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "length must be positive ({0})", intVar);
        }
empty line
// Get a random number generator
RandomGenerator RandomGenerator = getRan();
empty line
// Initialize output buffer
StringBuffer StringBuffer = new StringBuffer();
empty line
// Get int(len/2)+1 random bytes
byte[] byte[]Var = new byte[(intVar / 2) + 1];
RandomGenerator.nextBytes(byte[]Var);
empty line
// Convert each byte to 2 hex digits
for (int intVar = 0; intVar < byte[]Var.length; intVar++) {
            Integer c = Integer.valueOf(byte[]Var[intVar]);

            /*
             * Add 128 to byte value to make interval 0-255 before doing hex
             * conversion. This guarantees <= 2 hex digits from toHexString()
             * toHexString would otherwise add 2^32 to negative arguments.
             */
            String hex = Integer.toHexString(c.intValue() + 128);

            // Make sure we add 2 hex digits for each byte
            if (hex.length() == 1) {
                hex = "0" + hex;
            }
            StringBuffer.append(hex);
        }
return StringBuffer.toString().substring(0, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.random.RandomDataImpl <135, 167>
if (len <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  "length must be positive ({0})", len);
        }
empty line
// Get a random number generator
RandomGenerator RandomGenerator = getRan();
empty line
// Initialize output buffer
StringBuffer StringBuffer = new StringBuffer();
empty line
// Get int(len/2)+1 random bytes
byte[] randomBytes = new byte[(len / 2) + 1];
RandomGenerator.nextBytes(randomBytes);
empty line
// Convert each byte to 2 hex digits
for (int i = 0; i < randomBytes.length; i++) {
            Integer c = Integer.valueOf(randomBytes[i]);

            /*
             * Add 128 to byte value to make interval 0-255 before doing hex
             * conversion. This guarantees <= 2 hex digits from toHexString()
             * toHexString would otherwise add 2^32 to negative arguments.
             */
            String hex = Integer.toHexString(c.intValue() + 128);

            // Make sure we add 2 hex digits for each byte
            if (hex.length() == 1) {
                hex = "0" + hex;
            }
            StringBuffer.append(hex);
        }
return StringBuffer.toString().substring(0, len);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <566, 570>
if (array.length != nCols) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    1, array.length, 1, nCols);
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractFieldMatrix <566, 570>
if (T[]Var.length != intVar) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    1, T[]Var.length, 1, intVar);
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractFieldMatrix <566, 570>
if (array.length != nCols) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    1, array.length, 1, nCols);
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractFieldMatrix <598, 602>
if (array.length != nRows) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    array.length, 1, nRows, 1);
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractFieldMatrix <598, 602>
if (T[]Var.length != intVar) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    T[]Var.length, 1, intVar, 1);
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractFieldMatrix <598, 602>
if (array.length != nRows) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    array.length, 1, nRows, 1);
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <1161, 1165>
if (array.length != nCols) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    1, array.length, 1, nCols);
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockRealMatrix <1161, 1165>
if (double[]Var.length != intVar) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    1, double[]Var.length, 1, intVar);
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BlockRealMatrix <1161, 1165>
if (array.length != nCols) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    1, array.length, 1, nCols);
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockRealMatrix <1212, 1216>
if (array.length != nRows) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    array.length, 1, nRows, 1);
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockRealMatrix <1212, 1216>
if (double[]Var.length != intVar) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    double[]Var.length, 1, intVar, 1);
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BlockRealMatrix <1212, 1216>
if (array.length != nRows) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    array.length, 1, nRows, 1);
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockFieldMatrix <1135, 1139>
if (array.length != nCols) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    1, array.length, 1, nCols);
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockFieldMatrix <1135, 1139>
if (T[]Var.length != intVar) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    1, T[]Var.length, 1, intVar);
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BlockFieldMatrix <1135, 1139>
if (array.length != nCols) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    1, array.length, 1, nCols);
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.BlockFieldMatrix <1186, 1190>
if (array.length != nRows) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    array.length, 1, nRows, 1);
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.BlockFieldMatrix <1186, 1190>
if (T[]Var.length != intVar) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    T[]Var.length, 1, intVar, 1);
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.BlockFieldMatrix <1186, 1190>
if (array.length != nRows) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    array.length, 1, nRows, 1);
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <541, 545>
if (array.length != nCols) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    1, array.length, 1, nCols);
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <541, 545>
if (double[]Var.length != intVar) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    1, double[]Var.length, 1, intVar);
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <541, 545>
if (array.length != nCols) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    1, array.length, 1, nCols);
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.AbstractRealMatrix <573, 577>
if (array.length != nRows) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    array.length, 1, nRows, 1);
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.AbstractRealMatrix <573, 577>
if (double[]Var.length != intVar) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    double[]Var.length, 1, intVar, 1);
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.AbstractRealMatrix <573, 577>
if (array.length != nRows) {
            throw new InvalidMatrixException(
                    "dimensions mismatch: got {0}x{1} but expected {2}x{3}",
                    array.length, 1, nRows, 1);
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.linear.ArrayFieldVector <782, 786>
int h = 3542;
for (final T a : data) {
            h = h ^ a.hashCode();
        }
return h;

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.math.linear.ArrayFieldVector <782, 786>
int intVar = 3542;
for (final T a : T[]Var) {
            intVar = intVar ^ TVar.hashCode();
        }
return intVar;

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.math.linear.ArrayFieldVector <782, 786>
int h = 3542;
for (final T a : data) {
            h = h ^ a.hashCode();
        }
return h;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <119, 135>
if (interpolator.v1 == null) {

      v1 = null;
      v2 = null;
      v3 = null;
      v4 = null;
      vectorsInitialized = false;

    } else {

      v1 = interpolator.v1.clone();
      v2 = interpolator.v2.clone();
      v3 = interpolator.v3.clone();
      v4 = interpolator.v4.clone();
      vectorsInitialized = interpolator.vectorsInitialized;

    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolator <119, 135>
if (interpolator.v1 == null) {

      v1 = null;
      v2 = null;
      v3 = null;
      v4 = null;
      vectorsInitialized = false;

    } else {

      v1 = interpolator.v1.clone();
      v2 = interpolator.v2.clone();
      v3 = interpolator.v3.clone();
      v4 = interpolator.v4.clone();
      vectorsInitialized = interpolator.vectorsInitialized;

    }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.math.geometry.Rotation <206, 211>
if ((m.length != 3) || (m[0].length != 3) ||
        (m[1].length != 3) || (m[2].length != 3)) {
      throw new NotARotationMatrixException(
              "a {0}x{1} matrix cannot be a rotation matrix",
              m.length, m[0].length);
    }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.math.geometry.Rotation <206, 211>
if ((double[][]Var.length != 3) || (m[0].length != 3) ||
        (m[1].length != 3) || (m[2].length != 3)) {
      throw new NotARotationMatrixException(
              "a {0}x{1} matrix cannot be a rotation matrix",
              double[][]Var.length, m[0].length);
    }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.math.geometry.Rotation <206, 211>
if ((m.length != 3) || (m[0].length != 3) ||
        (m[1].length != 3) || (m[2].length != 3)) {
      throw new NotARotationMatrixException(
              "a {0}x{1} matrix cannot be a rotation matrix",
              m.length, m[0].length);
    }

