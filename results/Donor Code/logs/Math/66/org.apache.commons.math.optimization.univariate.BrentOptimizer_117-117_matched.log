---patch code ori--- org.apache.commons.math.optimization.univariate.BrentOptimizer <117, 232>
while (true) {
            double m = 0.5 * (a + b);
            final double tol1 = eps * Math.abs(x) + t;
            final double tol2 = 2 * tol1;

            // Check stopping criterion.
            if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (Math.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x)
                        && p < q * (b - x)
                        && Math.abs(p) < Math.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2
                            || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least "tol1".
                if (Math.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw
                        || w == x) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv
                               || v == x
                               || v == w) {
                        v = u;
                        fv = fu;
                    }
                }
            } else { // termination
                setFunctionValue(isMinim ? fx : -fx);
                return x;
            }
            incrementIterationsCounter();
        }

---fix ingredient  varMapType:ori--- org.apache.commons.math.util.OpenIntToDoubleHashMap <282, 290>
while (true) {
                j = probe(perturb, j);
                index = j & mask;
                perturb >>= PERTURB_SHIFT;

                if (states[index] != FULL || keys[index] == key) {
                    break;
                }
            }

---patch code 0--- org.apache.commons.math.optimization.univariate.BrentOptimizer <117, 232>
while (true) {
            double m = 0.5 * (doubleVar + doubleVar);
            final double tol1 = doubleVar * Math.abs(doubleVar) + doubleVar;
            final double tol2 = 2 * tol1;

            // Check stopping criterion.
            if (Math.abs(doubleVar - m) > tol2 - 0.5 * (doubleVar - doubleVar)) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (Math.abs(doubleVar) > tol1) { // Fit parabola.
                    r = (doubleVar - doubleVar) * (doubleVar - doubleVar);
                    q = (doubleVar - doubleVar) * (doubleVar - doubleVar);
                    p = (doubleVar - doubleVar) * q - (doubleVar - doubleVar) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = doubleVar;
                    doubleVar = doubleVar;

                    if (p > q * (doubleVar - doubleVar)
                        && p < q * (doubleVar - doubleVar)
                        && Math.abs(p) < Math.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        doubleVar = p / q;
                        u = doubleVar + doubleVar;

                        // f must not be evaluated too close to a or b.
                        if (u - doubleVar < tol2
                            || doubleVar - u < tol2) {
                            if (doubleVar <= m) {
                                doubleVar = tol1;
                            } else {
                                doubleVar = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (doubleVar < m) {
                            doubleVar = doubleVar - doubleVar;
                        } else {
                            doubleVar = doubleVar - doubleVar;
                        }
                        doubleVar = doubleVar * doubleVar;
                    }
                } else {
                    // Golden section step.
                    if (doubleVar < m) {
                        doubleVar = doubleVar - doubleVar;
                    } else {
                        doubleVar = doubleVar - doubleVar;
                    }
                    doubleVar = doubleVar * doubleVar;
                }

                // Update by at least "tol1".
                if (Math.abs(doubleVar) < tol1) {
                    if (doubleVar >= 0) {
                        u = doubleVar + tol1;
                    } else {
                        u = doubleVar - tol1;
                    }
                } else {
                    u = doubleVar + doubleVar;
                }

                double fu = computeObjectiveValue(u);
                if (!booleanVar) {
                    fu = -fu;
                }

                // Update a, b, v, w and x.
                if (fu <= doubleVar) {
                    if (u < doubleVar) {
                        doubleVar = doubleVar;
                    } else {
                        doubleVar = doubleVar;
                    }
                    doubleVar = doubleVar;
                    doubleVar = doubleVar;
                    doubleVar = doubleVar;
                    doubleVar = doubleVar;
                    doubleVar = u;
                    doubleVar = fu;
                } else {
                    if (u < doubleVar) {
                        doubleVar = u;
                    } else {
                        doubleVar = u;
                    }
                    if (fu <= doubleVar
                        || doubleVar == doubleVar) {
                        doubleVar = doubleVar;
                        doubleVar = doubleVar;
                        doubleVar = u;
                        doubleVar = fu;
                    } else if (fu <= doubleVar
                               || doubleVar == doubleVar
                               || doubleVar == doubleVar) {
                        doubleVar = u;
                        doubleVar = fu;
                    }
                }
            } else { // termination
                setFunctionValue(booleanVar ? doubleVar : -doubleVar);
                return doubleVar;
            }
            incrementIterationsCounter();
        }

---fix ingredient  varMapType:0--- org.apache.commons.math.util.OpenIntToDoubleHashMap <282, 290>
while (true) {
                intVar = probe(intVar, intVar);
                intVar = intVar & intVar;
                intVar >>= intVar;

                if (byte[]Var[intVar] != byteVar || int[]Var[intVar] == intVar) {
                    break;
                }
            }

---patch code 1--- org.apache.commons.math.optimization.univariate.BrentOptimizer <117, 232>
while (true) {
            double m = 0.5 * (a + b);
            final double tol1 = eps * Math.abs(x) + t;
            final double tol2 = 2 * tol1;

            // Check stopping criterion.
            if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (Math.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x)
                        && p < q * (b - x)
                        && Math.abs(p) < Math.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2
                            || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least "tol1".
                if (Math.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw
                        || w == x) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv
                               || v == x
                               || v == w) {
                        v = u;
                        fv = fu;
                    }
                }
            } else { // termination
                setFunctionValue(isMinim ? fx : -fx);
                return x;
            }
            incrementIterationsCounter();
        }

---fix ingredient  varMapType:1--- org.apache.commons.math.util.OpenIntToDoubleHashMap <282, 290>
while (true) {
                j = probe(perturb, j);
                index = j & mask;
                perturb >>= PERTURB_SHIFT;

                if (states[index] != FULL || keys[index] == key) {
                    break;
                }
            }

---fix ingredient  varMapType:ori--- org.apache.commons.math.util.OpenIntToFieldHashMap <294, 302>
while (true) {
                j = probe(perturb, j);
                index = j & mask;
                perturb >>= PERTURB_SHIFT;

                if (states[index] != FULL || keys[index] == key) {
                    break;
                }
            }

---fix ingredient  varMapType:0--- org.apache.commons.math.util.OpenIntToFieldHashMap <294, 302>
while (true) {
                intVar = probe(intVar, intVar);
                intVar = intVar & intVar;
                intVar >>= intVar;

                if (byte[]Var[intVar] != byteVar || int[]Var[intVar] == intVar) {
                    break;
                }
            }

---fix ingredient  varMapType:1--- org.apache.commons.math.util.OpenIntToFieldHashMap <294, 302>
while (true) {
                j = probe(perturb, j);
                index = j & mask;
                perturb >>= PERTURB_SHIFT;

                if (states[index] != FULL || keys[index] == key) {
                    break;
                }
            }

