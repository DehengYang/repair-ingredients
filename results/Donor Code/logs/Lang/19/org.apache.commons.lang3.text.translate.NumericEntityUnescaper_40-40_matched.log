---patch code ori--- org.apache.commons.lang3.text.translate.NumericEntityUnescaper <40, 87>
if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
                if(start == seqEnd) {
                    return 0;
                }
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') ||
                                    (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') ||
                                    (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) )
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println("FAIL: " + input.subSequence(start, end) + "[" + start +"]["+ end +"]");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }

            boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');

            return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);
        }

---fix ingredient(SameMethod)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.text.translate.NumericEntityUnescaper <40, 81>
if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(input.charAt(end) != ';') 
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println("FAIL: " + input.subSequence(start, end) + "[" + start +"]["+ end +"]");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }

---patch code 0--- org.apache.commons.lang3.text.translate.NumericEntityUnescaper <40, 87>
if(CharSequence.charAt(intVar) == '&' && intVar < intVar - 2 && CharSequence.charAt(intVar + 1) == '#') {
            int start = intVar + 2;
            boolean isHex = false;

            char firstChar = CharSequence.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
                if(start == intVar) {
                    return 0;
                }
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(end < intVar && ( (CharSequence.charAt(end) >= '0' && CharSequence.charAt(end) <= '9') ||
                                    (CharSequence.charAt(end) >= 'a' && CharSequence.charAt(end) <= 'f') ||
                                    (CharSequence.charAt(end) >= 'A' && CharSequence.charAt(end) <= 'F') ) )
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(CharSequence.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(CharSequence.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println("FAIL: " + input.subSequence(start, end) + "[" + start +"]["+ end +"]");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                Writer.write(chrs[0]);
                Writer.write(chrs[1]);
            } else {
                Writer.write(entityValue);
            }

            boolean semiNext = (end != intVar) && (CharSequence.charAt(end) == ';');

            return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);
        }

---fix ingredient(SameMethod)  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.text.translate.NumericEntityUnescaper <40, 81>
if(CharSequence.charAt(intVar) == '&' && intVar < intVar - 1 && CharSequence.charAt(intVar + 1) == '#') {
            int start = intVar + 2;
            boolean isHex = false;

            char firstChar = CharSequence.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(CharSequence.charAt(end) != ';') 
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(CharSequence.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(CharSequence.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println("FAIL: " + input.subSequence(start, end) + "[" + start +"]["+ end +"]");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                Writer.write(chrs[0]);
                Writer.write(chrs[1]);
            } else {
                Writer.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }

---patch code 1--- org.apache.commons.lang3.text.translate.NumericEntityUnescaper <40, 87>
if(CharSequence.charAt(index) == '&' && index < seqEnd - 2 && CharSequence.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = CharSequence.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
                if(start == seqEnd) {
                    return 0;
                }
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(end < seqEnd && ( (CharSequence.charAt(end) >= '0' && CharSequence.charAt(end) <= '9') ||
                                    (CharSequence.charAt(end) >= 'a' && CharSequence.charAt(end) <= 'f') ||
                                    (CharSequence.charAt(end) >= 'A' && CharSequence.charAt(end) <= 'F') ) )
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(CharSequence.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(CharSequence.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println("FAIL: " + input.subSequence(start, end) + "[" + start +"]["+ end +"]");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                Writer.write(chrs[0]);
                Writer.write(chrs[1]);
            } else {
                Writer.write(entityValue);
            }

            boolean semiNext = (end != seqEnd) && (CharSequence.charAt(end) == ';');

            return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);
        }

---fix ingredient(SameMethod)  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.text.translate.NumericEntityUnescaper <40, 81>
if(CharSequence.charAt(index) == '&' && index < seqEnd - 1 && CharSequence.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = CharSequence.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(CharSequence.charAt(end) != ';') 
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(CharSequence.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(CharSequence.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println("FAIL: " + input.subSequence(start, end) + "[" + start +"]["+ end +"]");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                Writer.write(chrs[0]);
                Writer.write(chrs[1]);
            } else {
                Writer.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.text.translate.OctalUnescaper <43, 57>
if(input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1)) ) {
            int start = index + 1;

            int end = index + 2;
            while ( end < input.length() && Character.isDigit(input.charAt(end)) ) {
                end++;
                if ( Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) {
                    end--; // rollback
                    break;
                }
            }

            out.write( Integer.parseInt(input.subSequence(start, end).toString(), 8) );
            return 1 + end - start;
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.text.translate.OctalUnescaper <43, 57>
if(CharSequence.charAt(intVar) == '\\' && intVar < (CharSequence.length() - 1) && Character.isDigit(CharSequence.charAt(intVar + 1)) ) {
            int start = intVar + 1;

            int end = intVar + 2;
            while ( end < CharSequence.length() && Character.isDigit(CharSequence.charAt(end)) ) {
                end++;
                if ( Integer.parseInt(CharSequence.subSequence(start, end).toString(), 10) > intVar) {
                    end--; // rollback
                    break;
                }
            }

            Writer.write( Integer.parseInt(CharSequence.subSequence(start, end).toString(), 8) );
            return 1 + end - start;
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.text.translate.OctalUnescaper <43, 57>
if(CharSequence.charAt(index) == '\\' && index < (CharSequence.length() - 1) && Character.isDigit(CharSequence.charAt(index + 1)) ) {
            int start = index + 1;

            int end = index + 2;
            while ( end < CharSequence.length() && Character.isDigit(CharSequence.charAt(end)) ) {
                end++;
                if ( Integer.parseInt(CharSequence.subSequence(start, end).toString(), 10) > OCTAL_MAX) {
                    end--; // rollback
                    break;
                }
            }

            Writer.write( Integer.parseInt(CharSequence.subSequence(start, end).toString(), 8) );
            return 1 + end - start;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.CharSet <186, 198>
if (remainder >= 3 && str.charAt(pos + 1) == '-') {
                // range
                set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2)));
                pos += 3;
            } else if (remainder >= 2 && str.charAt(pos) == '^') {
                // negated char
                set.add(CharRange.isNot(str.charAt(pos + 1)));
                pos += 2;
            } else {
                // char
                set.add(CharRange.is(str.charAt(pos)));
                pos += 1;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.CharSet <186, 198>
if (intVar >= 3 && StringVar.charAt(intVar + 1) == '-') {
                // range
                Set.add(CharRange.isIn(StringVar.charAt(intVar), StringVar.charAt(intVar + 2)));
                intVar += 3;
            } else if (intVar >= 2 && StringVar.charAt(intVar) == '^') {
                // negated char
                Set.add(CharRange.isNot(StringVar.charAt(intVar + 1)));
                intVar += 2;
            } else {
                // char
                Set.add(CharRange.is(StringVar.charAt(intVar)));
                intVar += 1;
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.CharSet <186, 198>
if (remainder >= 3 && str.charAt(pos + 1) == '-') {
                // range
                Set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2)));
                pos += 3;
            } else if (remainder >= 2 && str.charAt(pos) == '^') {
                // negated char
                Set.add(CharRange.isNot(str.charAt(pos + 1)));
                pos += 2;
            } else {
                // char
                Set.add(CharRange.is(str.charAt(pos)));
                pos += 1;
            }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.text.translate.UnicodeUnescaper <72, 104>
if(input.charAt(index) == '\\') {
            if( (index + 1 < input.length()) && input.charAt(index + 1) == 'u') {
                // consume optional additional 'u' chars
                int i=2;
                while( (index + i < input.length()) && input.charAt(index + i) == 'u') {
                    i++;
                }

                // consume + symbol in \\u+0045
                if(isSet(OPTION.escapePlus)) {
                    if( (index + i < input.length()) && (input.charAt(index + i) == '+') ) {
                        i++;
                    }
                }

                if( (index + i + 4 <= input.length()) ) {
                    // Get 4 hex digits
                    CharSequence unicode = input.subSequence(index + i, index + i + 4);

                    try {
                        int value = Integer.parseInt(unicode.toString(), 16);
                        out.write((char) value);
                    } catch (NumberFormatException nfe) {
                        throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe);
                    }
                    return i + 4;
                } else {
                    throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + 
                                                       input.subSequence(index, input.length()) +
                                                       "' due to end of CharSequence");
                }
            }
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.text.translate.UnicodeUnescaper <72, 104>
if(CharSequence.charAt(intVar) == '\\') {
            if( (intVar + 1 < CharSequence.length()) && CharSequence.charAt(intVar + 1) == 'u') {
                // consume optional additional 'u' chars
                int i=2;
                while( (intVar + i < CharSequence.length()) && CharSequence.charAt(intVar + i) == 'u') {
                    i++;
                }

                // consume + symbol in \\u+0045
                if(isSet(OPTION.escapePlus)) {
                    if( (intVar + i < CharSequence.length()) && (CharSequence.charAt(intVar + i) == '+') ) {
                        i++;
                    }
                }

                if( (intVar + i + 4 <= CharSequence.length()) ) {
                    // Get 4 hex digits
                    CharSequence unicode = CharSequence.subSequence(intVar + i, intVar + i + 4);

                    try {
                        int value = Integer.parseInt(unicode.toString(), 16);
                        Writer.write((char) value);
                    } catch (NumberFormatException nfe) {
                        throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe);
                    }
                    return i + 4;
                } else {
                    throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + 
                                                       CharSequence.subSequence(intVar, CharSequence.length()) +
                                                       "' due to end of CharSequence");
                }
            }
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.text.translate.UnicodeUnescaper <72, 104>
if(CharSequence.charAt(index) == '\\') {
            if( (index + 1 < CharSequence.length()) && CharSequence.charAt(index + 1) == 'u') {
                // consume optional additional 'u' chars
                int i=2;
                while( (index + i < CharSequence.length()) && CharSequence.charAt(index + i) == 'u') {
                    i++;
                }

                // consume + symbol in \\u+0045
                if(isSet(OPTION.escapePlus)) {
                    if( (index + i < CharSequence.length()) && (CharSequence.charAt(index + i) == '+') ) {
                        i++;
                    }
                }

                if( (index + i + 4 <= CharSequence.length()) ) {
                    // Get 4 hex digits
                    CharSequence unicode = CharSequence.subSequence(index + i, index + i + 4);

                    try {
                        int value = Integer.parseInt(unicode.toString(), 16);
                        Writer.write((char) value);
                    } catch (NumberFormatException nfe) {
                        throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe);
                    }
                    return i + 4;
                } else {
                    throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + 
                                                       CharSequence.subSequence(index, CharSequence.length()) +
                                                       "' due to end of CharSequence");
                }
            }
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.LocaleUtils <89, 123>
if (str == null) {
            return null;
        }
int len = str.length();
if (len != 2 && len != 5 && len < 7) {
            throw new IllegalArgumentException("Invalid locale format: " + str);
        }
char ch0 = str.charAt(0);
char ch1 = str.charAt(1);
if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
            throw new IllegalArgumentException("Invalid locale format: " + str);
        }
if (len == 2) {
            return new Locale(str, "");
        } else {
            if (str.charAt(2) != '_') {
                throw new IllegalArgumentException("Invalid locale format: " + str);
            }
            char ch3 = str.charAt(3);
            if (ch3 == '_') {
                return new Locale(str.substring(0, 2), "", str.substring(4));
            }
            char ch4 = str.charAt(4);
            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                throw new IllegalArgumentException("Invalid locale format: " + str);
            }
            if (len == 5) {
                return new Locale(str.substring(0, 2), str.substring(3, 5));
            } else {
                if (str.charAt(5) != '_') {
                    throw new IllegalArgumentException("Invalid locale format: " + str);
                }
                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
            }
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.LocaleUtils <89, 123>
if (StringVar == null) {
            return null;
        }
int intVar = StringVar.length();
if (intVar != 2 && intVar != 5 && intVar < 7) {
            throw new IllegalArgumentException("Invalid locale format: " + StringVar);
        }
char charVar = StringVar.charAt(0);
char charVar = StringVar.charAt(1);
if (charVar < 'a' || charVar > 'z' || charVar < 'a' || charVar > 'z') {
            throw new IllegalArgumentException("Invalid locale format: " + StringVar);
        }
if (intVar == 2) {
            return new Locale(StringVar, "");
        } else {
            if (StringVar.charAt(2) != '_') {
                throw new IllegalArgumentException("Invalid locale format: " + StringVar);
            }
            char ch3 = StringVar.charAt(3);
            if (ch3 == '_') {
                return new Locale(StringVar.substring(0, 2), "", StringVar.substring(4));
            }
            char ch4 = StringVar.charAt(4);
            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                throw new IllegalArgumentException("Invalid locale format: " + StringVar);
            }
            if (intVar == 5) {
                return new Locale(StringVar.substring(0, 2), StringVar.substring(3, 5));
            } else {
                if (StringVar.charAt(5) != '_') {
                    throw new IllegalArgumentException("Invalid locale format: " + StringVar);
                }
                return new Locale(StringVar.substring(0, 2), StringVar.substring(3, 5), StringVar.substring(6));
            }
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.LocaleUtils <89, 123>
if (str == null) {
            return null;
        }
int len = str.length();
if (len != 2 && len != 5 && len < 7) {
            throw new IllegalArgumentException("Invalid locale format: " + str);
        }
char ch0 = str.charAt(0);
char ch1 = str.charAt(1);
if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
            throw new IllegalArgumentException("Invalid locale format: " + str);
        }
if (len == 2) {
            return new Locale(str, "");
        } else {
            if (str.charAt(2) != '_') {
                throw new IllegalArgumentException("Invalid locale format: " + str);
            }
            char ch3 = str.charAt(3);
            if (ch3 == '_') {
                return new Locale(str.substring(0, 2), "", str.substring(4));
            }
            char ch4 = str.charAt(4);
            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                throw new IllegalArgumentException("Invalid locale format: " + str);
            }
            if (len == 5) {
                return new Locale(str.substring(0, 2), str.substring(3, 5));
            } else {
                if (str.charAt(5) != '_') {
                    throw new IllegalArgumentException("Invalid locale format: " + str);
                }
                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
            }
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.LocaleUtils <89, 123>
if (str == null) {
            return null;
        }
int len = str.length();
if (len != 2 && len != 5 && len < 7) {
            throw new IllegalArgumentException("Invalid locale format: " + str);
        }
char ch0 = str.charAt(0);
char ch1 = str.charAt(1);
if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
            throw new IllegalArgumentException("Invalid locale format: " + str);
        }
if (len == 2) {
            return new Locale(str, "");
        } else {
            if (str.charAt(2) != '_') {
                throw new IllegalArgumentException("Invalid locale format: " + str);
            }
            char ch3 = str.charAt(3);
            if (ch3 == '_') {
                return new Locale(str.substring(0, 2), "", str.substring(4));
            }
            char ch4 = str.charAt(4);
            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                throw new IllegalArgumentException("Invalid locale format: " + str);
            }
            if (len == 5) {
                return new Locale(str.substring(0, 2), str.substring(3, 5));
            } else {
                if (str.charAt(5) != '_') {
                    throw new IllegalArgumentException("Invalid locale format: " + str);
                }
                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
            }
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.LocaleUtils <89, 123>
if (StringVar == null) {
            return null;
        }
int intVar = StringVar.length();
if (intVar != 2 && intVar != 5 && intVar < 7) {
            throw new IllegalArgumentException("Invalid locale format: " + StringVar);
        }
char charVar = StringVar.charAt(0);
char charVar = StringVar.charAt(1);
if (charVar < 'a' || charVar > 'z' || charVar < 'a' || charVar > 'z') {
            throw new IllegalArgumentException("Invalid locale format: " + StringVar);
        }
if (intVar == 2) {
            return new Locale(StringVar, "");
        } else {
            if (StringVar.charAt(2) != '_') {
                throw new IllegalArgumentException("Invalid locale format: " + StringVar);
            }
            char ch3 = StringVar.charAt(3);
            if (ch3 == '_') {
                return new Locale(StringVar.substring(0, 2), "", StringVar.substring(4));
            }
            char ch4 = StringVar.charAt(4);
            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                throw new IllegalArgumentException("Invalid locale format: " + StringVar);
            }
            if (intVar == 5) {
                return new Locale(StringVar.substring(0, 2), StringVar.substring(3, 5));
            } else {
                if (StringVar.charAt(5) != '_') {
                    throw new IllegalArgumentException("Invalid locale format: " + StringVar);
                }
                return new Locale(StringVar.substring(0, 2), StringVar.substring(3, 5), StringVar.substring(6));
            }
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.LocaleUtils <89, 123>
if (str == null) {
            return null;
        }
int len = str.length();
if (len != 2 && len != 5 && len < 7) {
            throw new IllegalArgumentException("Invalid locale format: " + str);
        }
char ch0 = str.charAt(0);
char ch1 = str.charAt(1);
if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
            throw new IllegalArgumentException("Invalid locale format: " + str);
        }
if (len == 2) {
            return new Locale(str, "");
        } else {
            if (str.charAt(2) != '_') {
                throw new IllegalArgumentException("Invalid locale format: " + str);
            }
            char ch3 = str.charAt(3);
            if (ch3 == '_') {
                return new Locale(str.substring(0, 2), "", str.substring(4));
            }
            char ch4 = str.charAt(4);
            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                throw new IllegalArgumentException("Invalid locale format: " + str);
            }
            if (len == 5) {
                return new Locale(str.substring(0, 2), str.substring(3, 5));
            } else {
                if (str.charAt(5) != '_') {
                    throw new IllegalArgumentException("Invalid locale format: " + str);
                }
                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
            }
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <5868, 5870>
if (cs1.charAt(i) != cs2.charAt(i)) {
                break;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <1716, 1729>
for (int i = 0; i < strLen; i++) {
            char ch = seq.charAt(i);
            boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;
            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {
                char ch2 = seq.charAt(i + 1);
                if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {
                    return i;
                }
            } else {
                if (!chFound) {
                    return i;
                }
            }
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.StringUtils <1716, 1729>
for (int intVar = 0; intVar < intVar; intVar++) {
            char ch = CharSequence.charAt(intVar);
            boolean chFound = CharSequenceUtils.indexOf(CharSequence, ch, 0) >= 0;
            if (intVar + 1 < intVar && Character.isHighSurrogate(ch)) {
                char ch2 = CharSequence.charAt(intVar + 1);
                if (chFound && CharSequenceUtils.indexOf(CharSequence, ch2, 0) < 0) {
                    return intVar;
                }
            } else {
                if (!chFound) {
                    return intVar;
                }
            }
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <1716, 1729>
for (int i = 0; i < strLen; i++) {
            char ch = CharSequence.charAt(i);
            boolean chFound = CharSequenceUtils.indexOf(CharSequence, ch, 0) >= 0;
            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {
                char ch2 = CharSequence.charAt(i + 1);
                if (chFound && CharSequenceUtils.indexOf(CharSequence, ch2, 0) < 0) {
                    return i;
                }
            } else {
                if (!chFound) {
                    return i;
                }
            }
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <4418, 4433>
if (str == null) {
            return null;
        }
int strLen = str.length();
if (strLen < 2) {
            return EMPTY;
        }
int lastIdx = strLen - 1;
String ret = str.substring(0, lastIdx);
char last = str.charAt(lastIdx);
if (last == CharUtils.LF) {
            if (ret.charAt(lastIdx - 1) == CharUtils.CR) {
                return ret.substring(0, lastIdx - 1);
            }
        }
return ret;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.StringUtils <4418, 4433>
if (StringVar == null) {
            return null;
        }
int intVar = StringVar.length();
if (intVar < 2) {
            return StringVar;
        }
int intVar = intVar - 1;
String StringVar = StringVar.substring(0, intVar);
char charVar = StringVar.charAt(intVar);
if (charVar == CharUtils.LF) {
            if (StringVar.charAt(intVar - 1) == CharUtils.CR) {
                return StringVar.substring(0, intVar - 1);
            }
        }
return StringVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <4418, 4433>
if (str == null) {
            return null;
        }
int strLen = str.length();
if (strLen < 2) {
            return EMPTY;
        }
int lastIdx = strLen - 1;
String ret = str.substring(0, lastIdx);
char last = str.charAt(lastIdx);
if (last == CharUtils.LF) {
            if (ret.charAt(lastIdx - 1) == CharUtils.CR) {
                return ret.substring(0, lastIdx - 1);
            }
        }
return ret;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <4418, 4433>
if (str == null) {
            return null;
        }
int strLen = str.length();
if (strLen < 2) {
            return EMPTY;
        }
int lastIdx = strLen - 1;
String ret = str.substring(0, lastIdx);
char last = str.charAt(lastIdx);
if (last == CharUtils.LF) {
            if (ret.charAt(lastIdx - 1) == CharUtils.CR) {
                return ret.substring(0, lastIdx - 1);
            }
        }
return ret;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.StringUtils <4418, 4433>
if (StringVar == null) {
            return null;
        }
int intVar = StringVar.length();
if (intVar < 2) {
            return StringVar;
        }
int intVar = intVar - 1;
String StringVar = StringVar.substring(0, intVar);
char charVar = StringVar.charAt(intVar);
if (charVar == CharUtils.LF) {
            if (StringVar.charAt(intVar - 1) == CharUtils.CR) {
                return StringVar.substring(0, intVar - 1);
            }
        }
return StringVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <4418, 4433>
if (str == null) {
            return null;
        }
int strLen = str.length();
if (strLen < 2) {
            return EMPTY;
        }
int lastIdx = strLen - 1;
String ret = str.substring(0, lastIdx);
char last = str.charAt(lastIdx);
if (last == CharUtils.LF) {
            if (ret.charAt(lastIdx - 1) == CharUtils.CR) {
                return ret.substring(0, lastIdx - 1);
            }
        }
return ret;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <5860, 5875>
if (cs1 == cs2) {
            return INDEX_NOT_FOUND;
        }
if (cs1 == null || cs2 == null) {
            return 0;
        }
int i;
for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {
            if (cs1.charAt(i) != cs2.charAt(i)) {
                break;
            }
        }
if (i < cs2.length() || i < cs1.length()) {
            return i;
        }
return INDEX_NOT_FOUND;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <1712, 1730>
if (isEmpty(seq) || isEmpty(searchChars)) {
            return INDEX_NOT_FOUND;
        }
int strLen = seq.length();
for (int i = 0; i < strLen; i++) {
            char ch = seq.charAt(i);
            boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;
            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {
                char ch2 = seq.charAt(i + 1);
                if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {
                    return i;
                }
            } else {
                if (!chFound) {
                    return i;
                }
            }
        }
return INDEX_NOT_FOUND;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.StringUtils <1712, 1730>
if (isEmpty(CharSequence) || isEmpty(CharSequence)) {
            return intVar;
        }
int intVar = CharSequence.length();
for (int intVar = 0; intVar < intVar; intVar++) {
            char ch = CharSequence.charAt(intVar);
            boolean chFound = CharSequenceUtils.indexOf(CharSequence, ch, 0) >= 0;
            if (intVar + 1 < intVar && Character.isHighSurrogate(ch)) {
                char ch2 = CharSequence.charAt(intVar + 1);
                if (chFound && CharSequenceUtils.indexOf(CharSequence, ch2, 0) < 0) {
                    return intVar;
                }
            } else {
                if (!chFound) {
                    return intVar;
                }
            }
        }
return intVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <1712, 1730>
if (isEmpty(CharSequence) || isEmpty(CharSequence)) {
            return INDEX_NOT_FOUND;
        }
int strLen = CharSequence.length();
for (int i = 0; i < strLen; i++) {
            char ch = CharSequence.charAt(i);
            boolean chFound = CharSequenceUtils.indexOf(CharSequence, ch, 0) >= 0;
            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {
                char ch2 = CharSequence.charAt(i + 1);
                if (chFound && CharSequenceUtils.indexOf(CharSequence, ch2, 0) < 0) {
                    return i;
                }
            } else {
                if (!chFound) {
                    return i;
                }
            }
        }
return INDEX_NOT_FOUND;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <4462, 4495>
if (str == null) {
            return null;
        }
if (repeat <= 0) {
            return EMPTY;
        }
int inputLength = str.length();
if (repeat == 1 || inputLength == 0) {
            return str;
        }
if (inputLength == 1 && repeat <= PAD_LIMIT) {
            return repeat(str.charAt(0), repeat);
        }
empty line
int outputLength = inputLength * repeat;
switch (inputLength) {
            case 1 :
                return repeat(str.charAt(0), repeat);
            case 2 :
                char ch0 = str.charAt(0);
                char ch1 = str.charAt(1);
                char[] output2 = new char[outputLength];
                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                    output2[i] = ch0;
                    output2[i + 1] = ch1;
                }
                return new String(output2);
            default :
                StringBuilder buf = new StringBuilder(outputLength);
                for (int i = 0; i < repeat; i++) {
                    buf.append(str);
                }
                return buf.toString();
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.StringUtils <4462, 4495>
if (StringVar == null) {
            return null;
        }
if (intVar <= 0) {
            return StringVar;
        }
int intVar = StringVar.length();
if (intVar == 1 || intVar == 0) {
            return StringVar;
        }
if (intVar == 1 && intVar <= intVar) {
            return repeat(StringVar.charAt(0), intVar);
        }
empty line
int intVar = intVar * intVar;
switch (intVar) {
            case 1 :
                return repeat(StringVar.charAt(0), intVar);
            case 2 :
                char ch0 = StringVar.charAt(0);
                char ch1 = StringVar.charAt(1);
                char[] output2 = new char[intVar];
                for (int i = intVar * 2 - 2; i >= 0; i--, i--) {
                    output2[i] = ch0;
                    output2[i + 1] = ch1;
                }
                return new String(output2);
            default :
                StringBuilder buf = new StringBuilder(intVar);
                for (int i = 0; i < intVar; i++) {
                    buf.append(StringVar);
                }
                return buf.toString();
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <4462, 4495>
if (str == null) {
            return null;
        }
if (repeat <= 0) {
            return EMPTY;
        }
int inputLength = str.length();
if (repeat == 1 || inputLength == 0) {
            return str;
        }
if (inputLength == 1 && repeat <= PAD_LIMIT) {
            return repeat(str.charAt(0), repeat);
        }
empty line
int outputLength = inputLength * repeat;
switch (inputLength) {
            case 1 :
                return repeat(str.charAt(0), repeat);
            case 2 :
                char ch0 = str.charAt(0);
                char ch1 = str.charAt(1);
                char[] output2 = new char[outputLength];
                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                    output2[i] = ch0;
                    output2[i + 1] = ch1;
                }
                return new String(output2);
            default :
                StringBuilder buf = new StringBuilder(outputLength);
                for (int i = 0; i < repeat; i++) {
                    buf.append(str);
                }
                return buf.toString();
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <4462, 4495>
if (str == null) {
            return null;
        }
if (repeat <= 0) {
            return EMPTY;
        }
int inputLength = str.length();
if (repeat == 1 || inputLength == 0) {
            return str;
        }
if (inputLength == 1 && repeat <= PAD_LIMIT) {
            return repeat(str.charAt(0), repeat);
        }
empty line
int outputLength = inputLength * repeat;
switch (inputLength) {
            case 1 :
                return repeat(str.charAt(0), repeat);
            case 2 :
                char ch0 = str.charAt(0);
                char ch1 = str.charAt(1);
                char[] output2 = new char[outputLength];
                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                    output2[i] = ch0;
                    output2[i + 1] = ch1;
                }
                return new String(output2);
            default :
                StringBuilder buf = new StringBuilder(outputLength);
                for (int i = 0; i < repeat; i++) {
                    buf.append(str);
                }
                return buf.toString();
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.StringUtils <4462, 4495>
if (StringVar == null) {
            return null;
        }
if (intVar <= 0) {
            return StringVar;
        }
int intVar = StringVar.length();
if (intVar == 1 || intVar == 0) {
            return StringVar;
        }
if (intVar == 1 && intVar <= intVar) {
            return repeat(StringVar.charAt(0), intVar);
        }
empty line
int intVar = intVar * intVar;
switch (intVar) {
            case 1 :
                return repeat(StringVar.charAt(0), intVar);
            case 2 :
                char ch0 = StringVar.charAt(0);
                char ch1 = StringVar.charAt(1);
                char[] output2 = new char[intVar];
                for (int i = intVar * 2 - 2; i >= 0; i--, i--) {
                    output2[i] = ch0;
                    output2[i + 1] = ch1;
                }
                return new String(output2);
            default :
                StringBuilder buf = new StringBuilder(intVar);
                for (int i = 0; i < intVar; i++) {
                    buf.append(StringVar);
                }
                return buf.toString();
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <4462, 4495>
if (str == null) {
            return null;
        }
if (repeat <= 0) {
            return EMPTY;
        }
int inputLength = str.length();
if (repeat == 1 || inputLength == 0) {
            return str;
        }
if (inputLength == 1 && repeat <= PAD_LIMIT) {
            return repeat(str.charAt(0), repeat);
        }
empty line
int outputLength = inputLength * repeat;
switch (inputLength) {
            case 1 :
                return repeat(str.charAt(0), repeat);
            case 2 :
                char ch0 = str.charAt(0);
                char ch1 = str.charAt(1);
                char[] output2 = new char[outputLength];
                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                    output2[i] = ch0;
                    output2[i + 1] = ch1;
                }
                return new String(output2);
            default :
                StringBuilder buf = new StringBuilder(outputLength);
                for (int i = 0; i < repeat; i++) {
                    buf.append(str);
                }
                return buf.toString();
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <4462, 4495>
if (str == null) {
            return null;
        }
if (repeat <= 0) {
            return EMPTY;
        }
int inputLength = str.length();
if (repeat == 1 || inputLength == 0) {
            return str;
        }
if (inputLength == 1 && repeat <= PAD_LIMIT) {
            return repeat(str.charAt(0), repeat);
        }
empty line
int outputLength = inputLength * repeat;
switch (inputLength) {
            case 1 :
                return repeat(str.charAt(0), repeat);
            case 2 :
                char ch0 = str.charAt(0);
                char ch1 = str.charAt(1);
                char[] output2 = new char[outputLength];
                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                    output2[i] = ch0;
                    output2[i + 1] = ch1;
                }
                return new String(output2);
            default :
                StringBuilder buf = new StringBuilder(outputLength);
                for (int i = 0; i < repeat; i++) {
                    buf.append(str);
                }
                return buf.toString();
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.StringUtils <4462, 4495>
if (StringVar == null) {
            return null;
        }
if (intVar <= 0) {
            return StringVar;
        }
int intVar = StringVar.length();
if (intVar == 1 || intVar == 0) {
            return StringVar;
        }
if (intVar == 1 && intVar <= intVar) {
            return repeat(StringVar.charAt(0), intVar);
        }
empty line
int intVar = intVar * intVar;
switch (intVar) {
            case 1 :
                return repeat(StringVar.charAt(0), intVar);
            case 2 :
                char ch0 = StringVar.charAt(0);
                char ch1 = StringVar.charAt(1);
                char[] output2 = new char[intVar];
                for (int i = intVar * 2 - 2; i >= 0; i--, i--) {
                    output2[i] = ch0;
                    output2[i + 1] = ch1;
                }
                return new String(output2);
            default :
                StringBuilder buf = new StringBuilder(intVar);
                for (int i = 0; i < intVar; i++) {
                    buf.append(StringVar);
                }
                return buf.toString();
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <4462, 4495>
if (str == null) {
            return null;
        }
if (repeat <= 0) {
            return EMPTY;
        }
int inputLength = str.length();
if (repeat == 1 || inputLength == 0) {
            return str;
        }
if (inputLength == 1 && repeat <= PAD_LIMIT) {
            return repeat(str.charAt(0), repeat);
        }
empty line
int outputLength = inputLength * repeat;
switch (inputLength) {
            case 1 :
                return repeat(str.charAt(0), repeat);
            case 2 :
                char ch0 = str.charAt(0);
                char ch1 = str.charAt(1);
                char[] output2 = new char[outputLength];
                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                    output2[i] = ch0;
                    output2[i + 1] = ch1;
                }
                return new String(output2);
            default :
                StringBuilder buf = new StringBuilder(outputLength);
                for (int i = 0; i < repeat; i++) {
                    buf.append(str);
                }
                return buf.toString();
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <4462, 4495>
if (str == null) {
            return null;
        }
if (repeat <= 0) {
            return EMPTY;
        }
int inputLength = str.length();
if (repeat == 1 || inputLength == 0) {
            return str;
        }
if (inputLength == 1 && repeat <= PAD_LIMIT) {
            return repeat(str.charAt(0), repeat);
        }
empty line
int outputLength = inputLength * repeat;
switch (inputLength) {
            case 1 :
                return repeat(str.charAt(0), repeat);
            case 2 :
                char ch0 = str.charAt(0);
                char ch1 = str.charAt(1);
                char[] output2 = new char[outputLength];
                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                    output2[i] = ch0;
                    output2[i + 1] = ch1;
                }
                return new String(output2);
            default :
                StringBuilder buf = new StringBuilder(outputLength);
                for (int i = 0; i < repeat; i++) {
                    buf.append(str);
                }
                return buf.toString();
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.StringUtils <4462, 4495>
if (StringVar == null) {
            return null;
        }
if (intVar <= 0) {
            return StringVar;
        }
int intVar = StringVar.length();
if (intVar == 1 || intVar == 0) {
            return StringVar;
        }
if (intVar == 1 && intVar <= intVar) {
            return repeat(StringVar.charAt(0), intVar);
        }
empty line
int intVar = intVar * intVar;
switch (intVar) {
            case 1 :
                return repeat(StringVar.charAt(0), intVar);
            case 2 :
                char ch0 = StringVar.charAt(0);
                char ch1 = StringVar.charAt(1);
                char[] output2 = new char[intVar];
                for (int i = intVar * 2 - 2; i >= 0; i--, i--) {
                    output2[i] = ch0;
                    output2[i + 1] = ch1;
                }
                return new String(output2);
            default :
                StringBuilder buf = new StringBuilder(intVar);
                for (int i = 0; i < intVar; i++) {
                    buf.append(StringVar);
                }
                return buf.toString();
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <4462, 4495>
if (str == null) {
            return null;
        }
if (repeat <= 0) {
            return EMPTY;
        }
int inputLength = str.length();
if (repeat == 1 || inputLength == 0) {
            return str;
        }
if (inputLength == 1 && repeat <= PAD_LIMIT) {
            return repeat(str.charAt(0), repeat);
        }
empty line
int outputLength = inputLength * repeat;
switch (inputLength) {
            case 1 :
                return repeat(str.charAt(0), repeat);
            case 2 :
                char ch0 = str.charAt(0);
                char ch1 = str.charAt(1);
                char[] output2 = new char[outputLength];
                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                    output2[i] = ch0;
                    output2[i + 1] = ch1;
                }
                return new String(output2);
            default :
                StringBuilder buf = new StringBuilder(outputLength);
                for (int i = 0; i < repeat; i++) {
                    buf.append(str);
                }
                return buf.toString();
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.text.ExtendedMessageFormat <405, 438>
if (!containsElements(customPatterns)) {
            return pattern;
        }
StringBuilder sb = new StringBuilder(pattern.length() * 2);
ParsePosition pos = new ParsePosition(0);
int fe = -1;
int depth = 0;
while (pos.getIndex() < pattern.length()) {
            char c = pattern.charAt(pos.getIndex());
            switch (c) {
            case QUOTE:
                appendQuotedString(pattern, pos, sb, false);
                break;
            case START_FE:
                depth++;
                if (depth == 1) {
                    fe++;
                    sb.append(START_FE).append(
                            readArgumentIndex(pattern, next(pos)));
                    String customPattern = customPatterns.get(fe);
                    if (customPattern != null) {
                        sb.append(START_FMT).append(customPattern);
                    }
                }
                break;
            case END_FE:
                depth--;
                //$FALL-THROUGH$
            default:
                sb.append(c);
                next(pos);
            }
        }
return sb.toString();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.text.ExtendedMessageFormat <405, 438>
if (!containsElements(ArrayList)) {
            return StringVar;
        }
StringBuilder StringBuilder = new StringBuilder(StringVar.length() * 2);
ParsePosition ParsePosition = new ParsePosition(0);
int intVar = -1;
int intVar = 0;
while (ParsePosition.getIndex() < StringVar.length()) {
            char c = StringVar.charAt(ParsePosition.getIndex());
            switch (c) {
            case charVar:
                appendQuotedString(StringVar, ParsePosition, StringBuilder, false);
                break;
            case charVar:
                intVar++;
                if (intVar == 1) {
                    intVar++;
                    StringBuilder.append(charVar).append(
                            readArgumentIndex(StringVar, next(ParsePosition)));
                    String customPattern = ArrayList.get(intVar);
                    if (customPattern != null) {
                        StringBuilder.append(charVar).append(customPattern);
                    }
                }
                break;
            case charVar:
                intVar--;
                //$FALL-THROUGH$
            default:
                StringBuilder.append(c);
                next(ParsePosition);
            }
        }
return StringBuilder.toString();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.text.ExtendedMessageFormat <405, 438>
if (!containsElements(ArrayList)) {
            return pattern;
        }
StringBuilder StringBuilder = new StringBuilder(pattern.length() * 2);
ParsePosition ParsePosition = new ParsePosition(0);
int fe = -1;
int depth = 0;
while (ParsePosition.getIndex() < pattern.length()) {
            char c = pattern.charAt(ParsePosition.getIndex());
            switch (c) {
            case QUOTE:
                appendQuotedString(pattern, ParsePosition, StringBuilder, false);
                break;
            case START_FE:
                depth++;
                if (depth == 1) {
                    fe++;
                    StringBuilder.append(START_FE).append(
                            readArgumentIndex(pattern, next(ParsePosition)));
                    String customPattern = ArrayList.get(fe);
                    if (customPattern != null) {
                        StringBuilder.append(START_FMT).append(customPattern);
                    }
                }
                break;
            case END_FE:
                depth--;
                //$FALL-THROUGH$
            default:
                StringBuilder.append(c);
                next(ParsePosition);
            }
        }
return StringBuilder.toString();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.text.WordUtils <463, 485>
if (str == null || str.length() == 0) {
            return str;
        }
if (delimiters != null && delimiters.length == 0) {
            return "";
        }
int strLen = str.length();
char[] buf = new char[strLen / 2 + 1];
int count = 0;
boolean lastWasGap = true;
for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);

            if (isDelimiter(ch, delimiters)) {
                lastWasGap = true;
            } else if (lastWasGap) {
                buf[count++] = ch;
                lastWasGap = false;
            } else {
                continue; // ignore ch
            }
        }
return new String(buf, 0, count);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.text.WordUtils <463, 485>
if (StringVar == null || StringVar.length() == 0) {
            return StringVar;
        }
if (charVar != null && charVar.length == 0) {
            return "";
        }
int intVar = StringVar.length();
char[] char[]Var = new char[intVar / 2 + 1];
int intVar = 0;
boolean booleanVar = true;
for (int intVar = 0; intVar < intVar; intVar++) {
            char ch = StringVar.charAt(intVar);

            if (isDelimiter(ch, charVar)) {
                booleanVar = true;
            } else if (booleanVar) {
                char[]Var[intVar++] = ch;
                booleanVar = false;
            } else {
                continue; // ignore ch
            }
        }
return new String(char[]Var, 0, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.text.WordUtils <463, 485>
if (str == null || str.length() == 0) {
            return str;
        }
if (delimiters != null && delimiters.length == 0) {
            return "";
        }
int strLen = str.length();
char[] buf = new char[strLen / 2 + 1];
int count = 0;
boolean lastWasGap = true;
for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);

            if (isDelimiter(ch, delimiters)) {
                lastWasGap = true;
            } else if (lastWasGap) {
                buf[count++] = ch;
                lastWasGap = false;
            } else {
                continue; // ignore ch
            }
        }
return new String(buf, 0, count);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.text.WordUtils <463, 485>
if (str == null || str.length() == 0) {
            return str;
        }
if (delimiters != null && delimiters.length == 0) {
            return "";
        }
int strLen = str.length();
char[] buf = new char[strLen / 2 + 1];
int count = 0;
boolean lastWasGap = true;
for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);

            if (isDelimiter(ch, delimiters)) {
                lastWasGap = true;
            } else if (lastWasGap) {
                buf[count++] = ch;
                lastWasGap = false;
            } else {
                continue; // ignore ch
            }
        }
return new String(buf, 0, count);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.text.WordUtils <463, 485>
if (StringVar == null || StringVar.length() == 0) {
            return StringVar;
        }
if (charVar != null && charVar.length == 0) {
            return "";
        }
int intVar = StringVar.length();
char[] char[]Var = new char[intVar / 2 + 1];
int intVar = 0;
boolean booleanVar = true;
for (int intVar = 0; intVar < intVar; intVar++) {
            char ch = StringVar.charAt(intVar);

            if (isDelimiter(ch, charVar)) {
                booleanVar = true;
            } else if (booleanVar) {
                char[]Var[intVar++] = ch;
                booleanVar = false;
            } else {
                continue; // ignore ch
            }
        }
return new String(char[]Var, 0, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.text.WordUtils <463, 485>
if (str == null || str.length() == 0) {
            return str;
        }
if (delimiters != null && delimiters.length == 0) {
            return "";
        }
int strLen = str.length();
char[] buf = new char[strLen / 2 + 1];
int count = 0;
boolean lastWasGap = true;
for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);

            if (isDelimiter(ch, delimiters)) {
                lastWasGap = true;
            } else if (lastWasGap) {
                buf[count++] = ch;
                lastWasGap = false;
            } else {
                continue; // ignore ch
            }
        }
return new String(buf, 0, count);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.text.WordUtils <463, 485>
if (str == null || str.length() == 0) {
            return str;
        }
if (delimiters != null && delimiters.length == 0) {
            return "";
        }
int strLen = str.length();
char[] buf = new char[strLen / 2 + 1];
int count = 0;
boolean lastWasGap = true;
for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);

            if (isDelimiter(ch, delimiters)) {
                lastWasGap = true;
            } else if (lastWasGap) {
                buf[count++] = ch;
                lastWasGap = false;
            } else {
                continue; // ignore ch
            }
        }
return new String(buf, 0, count);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.text.WordUtils <463, 485>
if (StringVar == null || StringVar.length() == 0) {
            return StringVar;
        }
if (charVar != null && charVar.length == 0) {
            return "";
        }
int intVar = StringVar.length();
char[] char[]Var = new char[intVar / 2 + 1];
int intVar = 0;
boolean booleanVar = true;
for (int intVar = 0; intVar < intVar; intVar++) {
            char ch = StringVar.charAt(intVar);

            if (isDelimiter(ch, charVar)) {
                booleanVar = true;
            } else if (booleanVar) {
                char[]Var[intVar++] = ch;
                booleanVar = false;
            } else {
                continue; // ignore ch
            }
        }
return new String(char[]Var, 0, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.text.WordUtils <463, 485>
if (str == null || str.length() == 0) {
            return str;
        }
if (delimiters != null && delimiters.length == 0) {
            return "";
        }
int strLen = str.length();
char[] buf = new char[strLen / 2 + 1];
int count = 0;
boolean lastWasGap = true;
for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);

            if (isDelimiter(ch, delimiters)) {
                lastWasGap = true;
            } else if (lastWasGap) {
                buf[count++] = ch;
                lastWasGap = false;
            } else {
                continue; // ignore ch
            }
        }
return new String(buf, 0, count);

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.text.translate.CharSequenceTranslator <76, 104>
if (out == null) {
            throw new IllegalArgumentException("The Writer must not be null");
        }
if (input == null) {
            return;
        }
int sz = Character.codePointCount(input, 0, input.length());
for (int i = 0; i < sz; i++) {

            // consumed is the number of codepoints consumed
            int consumed = translate(input, i, out);

            if (consumed == 0) {
                out.write(Character.toChars(Character.codePointAt(input, i)));
            } else {
                // contract with translators is that they have to understand codepoints 
                // and they just took care of a surrogate pair
                for (int j = 0; j < consumed; j++) {
                    if (i < sz - 2) {
                        i += Character.charCount(Character.codePointAt(input, i));
                    } else {
                        // If the String ends with a high surrogate, just add the 1 and don't worry about such things
                        i++;
                    }
                }
                // for loop will increment 1 anyway, so remove 1 to account for that
                i--;
            }
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.text.translate.CharSequenceTranslator <76, 104>
if (Writer == null) {
            throw new IllegalArgumentException("The Writer must not be null");
        }
if (CharSequence == null) {
            return;
        }
int intVar = Character.codePointCount(CharSequence, 0, CharSequence.length());
for (int intVar = 0; intVar < intVar; intVar++) {

            // consumed is the number of codepoints consumed
            int consumed = translate(CharSequence, intVar, Writer);

            if (consumed == 0) {
                Writer.write(Character.toChars(Character.codePointAt(CharSequence, intVar)));
            } else {
                // contract with translators is that they have to understand codepoints 
                // and they just took care of a surrogate pair
                for (int j = 0; j < consumed; j++) {
                    if (intVar < intVar - 2) {
                        intVar += Character.charCount(Character.codePointAt(CharSequence, intVar));
                    } else {
                        // If the String ends with a high surrogate, just add the 1 and don't worry about such things
                        intVar++;
                    }
                }
                // for loop will increment 1 anyway, so remove 1 to account for that
                intVar--;
            }
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.text.translate.CharSequenceTranslator <76, 104>
if (Writer == null) {
            throw new IllegalArgumentException("The Writer must not be null");
        }
if (CharSequence == null) {
            return;
        }
int sz = Character.codePointCount(CharSequence, 0, CharSequence.length());
for (int i = 0; i < sz; i++) {

            // consumed is the number of codepoints consumed
            int consumed = translate(CharSequence, i, Writer);

            if (consumed == 0) {
                Writer.write(Character.toChars(Character.codePointAt(CharSequence, i)));
            } else {
                // contract with translators is that they have to understand codepoints 
                // and they just took care of a surrogate pair
                for (int j = 0; j < consumed; j++) {
                    if (i < sz - 2) {
                        i += Character.charCount(Character.codePointAt(CharSequence, i));
                    } else {
                        // If the String ends with a high surrogate, just add the 1 and don't worry about such things
                        i++;
                    }
                }
                // for loop will increment 1 anyway, so remove 1 to account for that
                i--;
            }
        }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.text.translate.CharSequenceTranslator <76, 104>
if (out == null) {
            throw new IllegalArgumentException("The Writer must not be null");
        }
if (input == null) {
            return;
        }
int sz = Character.codePointCount(input, 0, input.length());
for (int i = 0; i < sz; i++) {

            // consumed is the number of codepoints consumed
            int consumed = translate(input, i, out);

            if (consumed == 0) {
                out.write(Character.toChars(Character.codePointAt(input, i)));
            } else {
                // contract with translators is that they have to understand codepoints 
                // and they just took care of a surrogate pair
                for (int j = 0; j < consumed; j++) {
                    if (i < sz - 2) {
                        i += Character.charCount(Character.codePointAt(input, i));
                    } else {
                        // If the String ends with a high surrogate, just add the 1 and don't worry about such things
                        i++;
                    }
                }
                // for loop will increment 1 anyway, so remove 1 to account for that
                i--;
            }
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.text.translate.CharSequenceTranslator <76, 104>
if (Writer == null) {
            throw new IllegalArgumentException("The Writer must not be null");
        }
if (CharSequence == null) {
            return;
        }
int intVar = Character.codePointCount(CharSequence, 0, CharSequence.length());
for (int intVar = 0; intVar < intVar; intVar++) {

            // consumed is the number of codepoints consumed
            int consumed = translate(CharSequence, intVar, Writer);

            if (consumed == 0) {
                Writer.write(Character.toChars(Character.codePointAt(CharSequence, intVar)));
            } else {
                // contract with translators is that they have to understand codepoints 
                // and they just took care of a surrogate pair
                for (int j = 0; j < consumed; j++) {
                    if (intVar < intVar - 2) {
                        intVar += Character.charCount(Character.codePointAt(CharSequence, intVar));
                    } else {
                        // If the String ends with a high surrogate, just add the 1 and don't worry about such things
                        intVar++;
                    }
                }
                // for loop will increment 1 anyway, so remove 1 to account for that
                intVar--;
            }
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.text.translate.CharSequenceTranslator <76, 104>
if (Writer == null) {
            throw new IllegalArgumentException("The Writer must not be null");
        }
if (CharSequence == null) {
            return;
        }
int sz = Character.codePointCount(CharSequence, 0, CharSequence.length());
for (int i = 0; i < sz; i++) {

            // consumed is the number of codepoints consumed
            int consumed = translate(CharSequence, i, Writer);

            if (consumed == 0) {
                Writer.write(Character.toChars(Character.codePointAt(CharSequence, i)));
            } else {
                // contract with translators is that they have to understand codepoints 
                // and they just took care of a surrogate pair
                for (int j = 0; j < consumed; j++) {
                    if (i < sz - 2) {
                        i += Character.charCount(Character.codePointAt(CharSequence, i));
                    } else {
                        // If the String ends with a high surrogate, just add the 1 and don't worry about such things
                        i++;
                    }
                }
                // for loop will increment 1 anyway, so remove 1 to account for that
                i--;
            }
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.text.WordUtils <94, 139>
if (wrapLength < 1) {
            wrapLength = 1;
        }
int inputLineLength = str.length();
int offset = 0;
StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);
empty line
while ((inputLineLength - offset) > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);

            if (spaceToWrapAt >= offset) {
                // normal case
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
                
            } else {
                // really long word or URL
                if (wrapLongWords) {
                    // wrap really long word one line at a time
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    // do not wrap really long word, just extend beyond limit
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
empty line
// Whatever is left in line is short enough to just pass through
wrappedLine.append(str.substring(offset));
empty line
return wrappedLine.toString();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.text.WordUtils <94, 139>
if (intVar < 1) {
            intVar = 1;
        }
int intVar = StringVar.length();
int intVar = 0;
StringBuilder StringBuilder = new StringBuilder(intVar + 32);
empty line
while ((intVar - intVar) > intVar) {
            if (StringVar.charAt(intVar) == ' ') {
                intVar++;
                continue;
            }
            int spaceToWrapAt = StringVar.lastIndexOf(' ', intVar + intVar);

            if (spaceToWrapAt >= intVar) {
                // normal case
                StringBuilder.append(StringVar.substring(intVar, spaceToWrapAt));
                StringBuilder.append(StringVar);
                intVar = spaceToWrapAt + 1;
                
            } else {
                // really long word or URL
                if (booleanVar) {
                    // wrap really long word one line at a time
                    StringBuilder.append(StringVar.substring(intVar, intVar + intVar));
                    StringBuilder.append(StringVar);
                    intVar += intVar;
                } else {
                    // do not wrap really long word, just extend beyond limit
                    spaceToWrapAt = StringVar.indexOf(' ', intVar + intVar);
                    if (spaceToWrapAt >= 0) {
                        StringBuilder.append(StringVar.substring(intVar, spaceToWrapAt));
                        StringBuilder.append(StringVar);
                        intVar = spaceToWrapAt + 1;
                    } else {
                        StringBuilder.append(StringVar.substring(intVar));
                        intVar = intVar;
                    }
                }
            }
        }
empty line
// Whatever is left in line is short enough to just pass through
StringBuilder.append(StringVar.substring(intVar));
empty line
return StringBuilder.toString();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.text.WordUtils <94, 139>
if (wrapLength < 1) {
            wrapLength = 1;
        }
int inputLineLength = str.length();
int offset = 0;
StringBuilder StringBuilder = new StringBuilder(inputLineLength + 32);
empty line
while ((inputLineLength - offset) > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);

            if (spaceToWrapAt >= offset) {
                // normal case
                StringBuilder.append(str.substring(offset, spaceToWrapAt));
                StringBuilder.append(newLineStr);
                offset = spaceToWrapAt + 1;
                
            } else {
                // really long word or URL
                if (wrapLongWords) {
                    // wrap really long word one line at a time
                    StringBuilder.append(str.substring(offset, wrapLength + offset));
                    StringBuilder.append(newLineStr);
                    offset += wrapLength;
                } else {
                    // do not wrap really long word, just extend beyond limit
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        StringBuilder.append(str.substring(offset, spaceToWrapAt));
                        StringBuilder.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        StringBuilder.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
empty line
// Whatever is left in line is short enough to just pass through
StringBuilder.append(str.substring(offset));
empty line
return StringBuilder.toString();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.text.WordUtils <94, 139>
if (wrapLength < 1) {
            wrapLength = 1;
        }
int inputLineLength = str.length();
int offset = 0;
StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);
empty line
while ((inputLineLength - offset) > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);

            if (spaceToWrapAt >= offset) {
                // normal case
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
                
            } else {
                // really long word or URL
                if (wrapLongWords) {
                    // wrap really long word one line at a time
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    // do not wrap really long word, just extend beyond limit
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
empty line
// Whatever is left in line is short enough to just pass through
wrappedLine.append(str.substring(offset));
empty line
return wrappedLine.toString();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.text.WordUtils <94, 139>
if (intVar < 1) {
            intVar = 1;
        }
int intVar = StringVar.length();
int intVar = 0;
StringBuilder StringBuilder = new StringBuilder(intVar + 32);
empty line
while ((intVar - intVar) > intVar) {
            if (StringVar.charAt(intVar) == ' ') {
                intVar++;
                continue;
            }
            int spaceToWrapAt = StringVar.lastIndexOf(' ', intVar + intVar);

            if (spaceToWrapAt >= intVar) {
                // normal case
                StringBuilder.append(StringVar.substring(intVar, spaceToWrapAt));
                StringBuilder.append(StringVar);
                intVar = spaceToWrapAt + 1;
                
            } else {
                // really long word or URL
                if (booleanVar) {
                    // wrap really long word one line at a time
                    StringBuilder.append(StringVar.substring(intVar, intVar + intVar));
                    StringBuilder.append(StringVar);
                    intVar += intVar;
                } else {
                    // do not wrap really long word, just extend beyond limit
                    spaceToWrapAt = StringVar.indexOf(' ', intVar + intVar);
                    if (spaceToWrapAt >= 0) {
                        StringBuilder.append(StringVar.substring(intVar, spaceToWrapAt));
                        StringBuilder.append(StringVar);
                        intVar = spaceToWrapAt + 1;
                    } else {
                        StringBuilder.append(StringVar.substring(intVar));
                        intVar = intVar;
                    }
                }
            }
        }
empty line
// Whatever is left in line is short enough to just pass through
StringBuilder.append(StringVar.substring(intVar));
empty line
return StringBuilder.toString();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.text.WordUtils <94, 139>
if (wrapLength < 1) {
            wrapLength = 1;
        }
int inputLineLength = str.length();
int offset = 0;
StringBuilder StringBuilder = new StringBuilder(inputLineLength + 32);
empty line
while ((inputLineLength - offset) > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);

            if (spaceToWrapAt >= offset) {
                // normal case
                StringBuilder.append(str.substring(offset, spaceToWrapAt));
                StringBuilder.append(newLineStr);
                offset = spaceToWrapAt + 1;
                
            } else {
                // really long word or URL
                if (wrapLongWords) {
                    // wrap really long word one line at a time
                    StringBuilder.append(str.substring(offset, wrapLength + offset));
                    StringBuilder.append(newLineStr);
                    offset += wrapLength;
                } else {
                    // do not wrap really long word, just extend beyond limit
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        StringBuilder.append(str.substring(offset, spaceToWrapAt));
                        StringBuilder.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        StringBuilder.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
empty line
// Whatever is left in line is short enough to just pass through
StringBuilder.append(str.substring(offset));
empty line
return StringBuilder.toString();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.time.DurationFormatUtils <335, 358>
if( !Token.containsTokenWithValue(tokens, y) ) {
                int target = end.get(Calendar.YEAR);
                if (months < 0) {
                    // target is end-year -1
                    target -= 1;
                }
                
                while ( (start.get(Calendar.YEAR) != target)) {
                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);
                    
                    // Not sure I grok why this is needed, but the brutal tests show it is
                    if (start instanceof GregorianCalendar &&
                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&
                            start.get(Calendar.DAY_OF_MONTH) == 29) {
                        days += 1;
                    }
                    
                    start.add(Calendar.YEAR, 1);
                    
                    days += start.get(Calendar.DAY_OF_YEAR);
                }
                
                years = 0;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.time.DurationFormatUtils <335, 358>
if( !Token.containsTokenWithValue(Token[]Var, Object) ) {
                int target = Calendar.get(Calendar.YEAR);
                if (intVar < 0) {
                    // target is end-year -1
                    target -= 1;
                }
                
                while ( (Calendar.get(Calendar.YEAR) != target)) {
                    intVar += Calendar.getActualMaximum(Calendar.DAY_OF_YEAR) - Calendar.get(Calendar.DAY_OF_YEAR);
                    
                    // Not sure I grok why this is needed, but the brutal tests show it is
                    if (Calendar instanceof GregorianCalendar &&
                            Calendar.get(Calendar.MONTH) == Calendar.FEBRUARY &&
                            Calendar.get(Calendar.DAY_OF_MONTH) == 29) {
                        intVar += 1;
                    }
                    
                    Calendar.add(Calendar.YEAR, 1);
                    
                    intVar += Calendar.get(Calendar.DAY_OF_YEAR);
                }
                
                intVar = 0;
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.time.DurationFormatUtils <335, 358>
if( !Token.containsTokenWithValue(tokens, Object) ) {
                int target = Calendar.get(Calendar.YEAR);
                if (months < 0) {
                    // target is end-year -1
                    target -= 1;
                }
                
                while ( (Calendar.get(Calendar.YEAR) != target)) {
                    days += Calendar.getActualMaximum(Calendar.DAY_OF_YEAR) - Calendar.get(Calendar.DAY_OF_YEAR);
                    
                    // Not sure I grok why this is needed, but the brutal tests show it is
                    if (Calendar instanceof GregorianCalendar &&
                            Calendar.get(Calendar.MONTH) == Calendar.FEBRUARY &&
                            Calendar.get(Calendar.DAY_OF_MONTH) == 29) {
                        days += 1;
                    }
                    
                    Calendar.add(Calendar.YEAR, 1);
                    
                    days += Calendar.get(Calendar.DAY_OF_YEAR);
                }
                
                years = 0;
            }

---fix ingredient(SamePackage)  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.text.translate.CharSequenceTranslator <54, 64>
if (input == null) {
            return null;
        }
try {
            StringWriter writer = new StringWriter(input.length() * 2);
            translate(input, writer);
            return writer.toString();
        } catch (IOException ioe) {
            // this should never ever happen while writing to a StringWriter
            throw new RuntimeException(ioe);
        }

---fix ingredient(SamePackage)  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.text.translate.CharSequenceTranslator <54, 64>
if (CharSequence == null) {
            return null;
        }
try {
            StringWriter writer = new StringWriter(CharSequence.length() * 2);
            translate(CharSequence, writer);
            return writer.toString();
        } catch (IOException ioe) {
            // this should never ever happen while writing to a StringWriter
            throw new RuntimeException(ioe);
        }

---fix ingredient(SamePackage)  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.text.translate.CharSequenceTranslator <54, 64>
if (CharSequence == null) {
            return null;
        }
try {
            StringWriter writer = new StringWriter(CharSequence.length() * 2);
            translate(CharSequence, writer);
            return writer.toString();
        } catch (IOException ioe) {
            // this should never ever happen while writing to a StringWriter
            throw new RuntimeException(ioe);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.RandomStringUtils <239, 280>
char[] buffer = new char[count];
int gap = end - start;
empty line
while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(gap) + start];
            }
            if ((letters && Character.isLetter(ch))
                    || (numbers && Character.isDigit(ch))
                    || (!letters && !numbers)) {
                if(ch >= 56320 && ch <= 57343) {
                    if(count == 0) {
                        count++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (55296 + random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(count == 0) {
                        count++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        buffer[count] = (char) (56320 + random.nextInt(128));
                        count--;
                        buffer[count] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
return new String(buffer);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.RandomStringUtils <239, 280>
char[] char[]Var = new char[intVar];
int intVar = intVar - intVar;
empty line
while (intVar-- != 0) {
            char ch;
            if (char[]Var == null) {
                ch = (char) (Random.nextInt(intVar) + intVar);
            } else {
                ch = char[]Var[Random.nextInt(intVar) + intVar];
            }
            if ((booleanVar && Character.isLetter(ch))
                    || (booleanVar && Character.isDigit(ch))
                    || (!booleanVar && !booleanVar)) {
                if(ch >= 56320 && ch <= 57343) {
                    if(intVar == 0) {
                        intVar++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        char[]Var[intVar] = ch;
                        intVar--;
                        char[]Var[intVar] = (char) (55296 + Random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(intVar == 0) {
                        intVar++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        char[]Var[intVar] = (char) (56320 + Random.nextInt(128));
                        intVar--;
                        char[]Var[intVar] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    intVar++;
                } else {
                    char[]Var[intVar] = ch;
                }
            } else {
                intVar++;
            }
        }
return new String(char[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.RandomStringUtils <239, 280>
char[] buffer = new char[count];
int gap = end - start;
empty line
while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (Random.nextInt(gap) + start);
            } else {
                ch = chars[Random.nextInt(gap) + start];
            }
            if ((letters && Character.isLetter(ch))
                    || (numbers && Character.isDigit(ch))
                    || (!letters && !numbers)) {
                if(ch >= 56320 && ch <= 57343) {
                    if(count == 0) {
                        count++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (55296 + Random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(count == 0) {
                        count++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        buffer[count] = (char) (56320 + Random.nextInt(128));
                        count--;
                        buffer[count] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
return new String(buffer);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.RandomStringUtils <239, 280>
char[] buffer = new char[count];
int gap = end - start;
empty line
while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(gap) + start];
            }
            if ((letters && Character.isLetter(ch))
                    || (numbers && Character.isDigit(ch))
                    || (!letters && !numbers)) {
                if(ch >= 56320 && ch <= 57343) {
                    if(count == 0) {
                        count++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (55296 + random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(count == 0) {
                        count++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        buffer[count] = (char) (56320 + random.nextInt(128));
                        count--;
                        buffer[count] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
return new String(buffer);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.RandomStringUtils <239, 280>
char[] char[]Var = new char[intVar];
int intVar = intVar - intVar;
empty line
while (intVar-- != 0) {
            char ch;
            if (char[]Var == null) {
                ch = (char) (Random.nextInt(intVar) + intVar);
            } else {
                ch = char[]Var[Random.nextInt(intVar) + intVar];
            }
            if ((booleanVar && Character.isLetter(ch))
                    || (booleanVar && Character.isDigit(ch))
                    || (!booleanVar && !booleanVar)) {
                if(ch >= 56320 && ch <= 57343) {
                    if(intVar == 0) {
                        intVar++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        char[]Var[intVar] = ch;
                        intVar--;
                        char[]Var[intVar] = (char) (55296 + Random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(intVar == 0) {
                        intVar++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        char[]Var[intVar] = (char) (56320 + Random.nextInt(128));
                        intVar--;
                        char[]Var[intVar] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    intVar++;
                } else {
                    char[]Var[intVar] = ch;
                }
            } else {
                intVar++;
            }
        }
return new String(char[]Var);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.RandomStringUtils <239, 280>
char[] buffer = new char[count];
int gap = end - start;
empty line
while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (Random.nextInt(gap) + start);
            } else {
                ch = chars[Random.nextInt(gap) + start];
            }
            if ((letters && Character.isLetter(ch))
                    || (numbers && Character.isDigit(ch))
                    || (!letters && !numbers)) {
                if(ch >= 56320 && ch <= 57343) {
                    if(count == 0) {
                        count++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (55296 + Random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(count == 0) {
                        count++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        buffer[count] = (char) (56320 + Random.nextInt(128));
                        count--;
                        buffer[count] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
return new String(buffer);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.time.FastDateFormat <1146, 1164>
if (value < 100) {
                for (int i = mSize; --i >= 2; ) {
                    buffer.append('0');
                }
                buffer.append((char)(value / 10 + '0'));
                buffer.append((char)(value % 10 + '0'));
            } else {
                int digits;
                if (value < 1000) {
                    digits = 3;
                } else {
                    Validate.isTrue(value > -1, "Negative values should not be possible", value);
                    digits = Integer.toString(value).length();
                }
                for (int i = mSize; --i >= digits; ) {
                    buffer.append('0');
                }
                buffer.append(Integer.toString(value));
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.time.FastDateFormat <1146, 1164>
if (intVar < 100) {
                for (int i = intVar; --i >= 2; ) {
                    StringBuffer.append('0');
                }
                StringBuffer.append((char)(intVar / 10 + '0'));
                StringBuffer.append((char)(intVar % 10 + '0'));
            } else {
                int digits;
                if (intVar < 1000) {
                    digits = 3;
                } else {
                    Validate.isTrue(intVar > -1, "Negative values should not be possible", intVar);
                    digits = Integer.toString(intVar).length();
                }
                for (int i = intVar; --i >= digits; ) {
                    StringBuffer.append('0');
                }
                StringBuffer.append(Integer.toString(intVar));
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.time.FastDateFormat <1146, 1164>
if (value < 100) {
                for (int i = mSize; --i >= 2; ) {
                    StringBuffer.append('0');
                }
                StringBuffer.append((char)(value / 10 + '0'));
                StringBuffer.append((char)(value % 10 + '0'));
            } else {
                int digits;
                if (value < 1000) {
                    digits = 3;
                } else {
                    Validate.isTrue(value > -1, "Negative values should not be possible", value);
                    digits = Integer.toString(value).length();
                }
                for (int i = mSize; --i >= digits; ) {
                    StringBuffer.append('0');
                }
                StringBuffer.append(Integer.toString(value));
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.time.DurationFormatUtils <620, 635>
if (obj2 instanceof Token) {
                Token tok2 = (Token) obj2;
                if (this.value.getClass() != tok2.value.getClass()) {
                    return false;
                }
                if (this.count != tok2.count) {
                    return false;
                }
                if (this.value instanceof StringBuffer) {
                    return this.value.toString().equals(tok2.value.toString());
                } else if (this.value instanceof Number) {
                    return this.value.equals(tok2.value);
                } else {
                    return this.value == tok2.value;
                }
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.time.DurationFormatUtils <620, 635>
if (Object instanceof Token) {
                Token tok2 = (Token) Object;
                if (DurationFormatUtils.Object.getClass() != tok2.Object.getClass()) {
                    return false;
                }
                if (DurationFormatUtils.intVar != tok2.intVar) {
                    return false;
                }
                if (DurationFormatUtils.Object instanceof StringBuffer) {
                    return DurationFormatUtils.Object.toString().equals(tok2.Object.toString());
                } else if (DurationFormatUtils.Object instanceof Number) {
                    return DurationFormatUtils.Object.equals(tok2.Object);
                } else {
                    return DurationFormatUtils.Object == tok2.Object;
                }
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.time.DurationFormatUtils <620, 635>
if (Object instanceof Token) {
                Token tok2 = (Token) Object;
                if (DurationFormatUtils.Object.getClass() != tok2.Object.getClass()) {
                    return false;
                }
                if (DurationFormatUtils.count != tok2.count) {
                    return false;
                }
                if (DurationFormatUtils.Object instanceof StringBuffer) {
                    return DurationFormatUtils.Object.toString().equals(tok2.Object.toString());
                } else if (DurationFormatUtils.Object instanceof Number) {
                    return DurationFormatUtils.Object.equals(tok2.Object);
                } else {
                    return DurationFormatUtils.Object == tok2.Object;
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.text.FormattableUtils <136, 148>
Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision,
                "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));
StringBuilder buf = new StringBuilder(seq);
if (precision >= 0 && precision < seq.length()) {
            CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);
            buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());
        }
boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;
for (int i = buf.length(); i < width; i++) {
            buf.insert(leftJustify ? i : 0, padChar);
        }
formatter.format(buf.toString());
return formatter;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.text.FormattableUtils <136, 148>
Validate.isTrue(CharSequence == null || intVar < 0 || CharSequence.length() <= intVar,
                "Specified ellipsis '%1$s' exceeds precision of %2$s", CharSequence, Integer.valueOf(intVar));
StringBuilder StringBuilder = new StringBuilder(CharSequence);
if (intVar >= 0 && intVar < CharSequence.length()) {
            CharSequence _ellipsis = ObjectUtils.defaultIfNull(CharSequence, StringUtils.EMPTY);
            StringBuilder.replace(intVar - _ellipsis.length(), CharSequence.length(), _ellipsis.toString());
        }
boolean booleanVar = (intVar & LEFT_JUSTIFY) == LEFT_JUSTIFY;
for (int intVar = StringBuilder.length(); intVar < intVar; intVar++) {
            StringBuilder.insert(booleanVar ? intVar : 0, charVar);
        }
Formatter.format(StringBuilder.toString());
return Formatter;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.text.FormattableUtils <136, 148>
Validate.isTrue(CharSequence == null || precision < 0 || CharSequence.length() <= precision,
                "Specified ellipsis '%1$s' exceeds precision of %2$s", CharSequence, Integer.valueOf(precision));
StringBuilder StringBuilder = new StringBuilder(CharSequence);
if (precision >= 0 && precision < CharSequence.length()) {
            CharSequence _ellipsis = ObjectUtils.defaultIfNull(CharSequence, StringUtils.EMPTY);
            StringBuilder.replace(precision - _ellipsis.length(), CharSequence.length(), _ellipsis.toString());
        }
boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;
for (int i = StringBuilder.length(); i < width; i++) {
            StringBuilder.insert(leftJustify ? i : 0, padChar);
        }
Formatter.format(StringBuilder.toString());
return Formatter;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <3457, 3483>
if (iterator == null) {
            return null;
        }
if (!iterator.hasNext()) {
            return EMPTY;
        }
Object first = iterator.next();
if (!iterator.hasNext()) {
            return ObjectUtils.toString(first);
        }
empty line
// two or more elements
StringBuilder buf = new StringBuilder(256);
if (first != null) {
            buf.append(first);
        }
empty line
while (iterator.hasNext()) {
            if (separator != null) {
                buf.append(separator);
            }
            Object obj = iterator.next();
            if (obj != null) {
                buf.append(obj);
            }
        }
return buf.toString();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.StringUtils <3457, 3483>
if (Iterator == null) {
            return null;
        }
if (!Iterator.hasNext()) {
            return StringVar;
        }
Object Object = Iterator.next();
if (!Iterator.hasNext()) {
            return ObjectUtils.toString(Object);
        }
empty line
// two or more elements
StringBuilder StringBuilder = new StringBuilder(256);
if (Object != null) {
            StringBuilder.append(Object);
        }
empty line
while (Iterator.hasNext()) {
            if (StringVar != null) {
                StringBuilder.append(StringVar);
            }
            Object obj = Iterator.next();
            if (obj != null) {
                StringBuilder.append(obj);
            }
        }
return StringBuilder.toString();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <3457, 3483>
if (Iterator == null) {
            return null;
        }
if (!Iterator.hasNext()) {
            return EMPTY;
        }
Object Object = Iterator.next();
if (!Iterator.hasNext()) {
            return ObjectUtils.toString(Object);
        }
empty line
// two or more elements
StringBuilder StringBuilder = new StringBuilder(256);
if (Object != null) {
            StringBuilder.append(Object);
        }
empty line
while (Iterator.hasNext()) {
            if (separator != null) {
                StringBuilder.append(separator);
            }
            Object obj = Iterator.next();
            if (obj != null) {
                StringBuilder.append(obj);
            }
        }
return StringBuilder.toString();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <3457, 3483>
if (iterator == null) {
            return null;
        }
if (!iterator.hasNext()) {
            return EMPTY;
        }
Object first = iterator.next();
if (!iterator.hasNext()) {
            return ObjectUtils.toString(first);
        }
empty line
// two or more elements
StringBuilder buf = new StringBuilder(256);
if (first != null) {
            buf.append(first);
        }
empty line
while (iterator.hasNext()) {
            if (separator != null) {
                buf.append(separator);
            }
            Object obj = iterator.next();
            if (obj != null) {
                buf.append(obj);
            }
        }
return buf.toString();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.StringUtils <3457, 3483>
if (Iterator == null) {
            return null;
        }
if (!Iterator.hasNext()) {
            return StringVar;
        }
Object Object = Iterator.next();
if (!Iterator.hasNext()) {
            return ObjectUtils.toString(Object);
        }
empty line
// two or more elements
StringBuilder StringBuilder = new StringBuilder(256);
if (Object != null) {
            StringBuilder.append(Object);
        }
empty line
while (Iterator.hasNext()) {
            if (StringVar != null) {
                StringBuilder.append(StringVar);
            }
            Object obj = Iterator.next();
            if (obj != null) {
                StringBuilder.append(obj);
            }
        }
return StringBuilder.toString();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <3457, 3483>
if (Iterator == null) {
            return null;
        }
if (!Iterator.hasNext()) {
            return EMPTY;
        }
Object Object = Iterator.next();
if (!Iterator.hasNext()) {
            return ObjectUtils.toString(Object);
        }
empty line
// two or more elements
StringBuilder StringBuilder = new StringBuilder(256);
if (Object != null) {
            StringBuilder.append(Object);
        }
empty line
while (Iterator.hasNext()) {
            if (separator != null) {
                StringBuilder.append(separator);
            }
            Object obj = Iterator.next();
            if (obj != null) {
                StringBuilder.append(obj);
            }
        }
return StringBuilder.toString();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <3413, 3438>
if (iterator == null) {
            return null;
        }
if (!iterator.hasNext()) {
            return EMPTY;
        }
Object first = iterator.next();
if (!iterator.hasNext()) {
            return ObjectUtils.toString(first);
        }
empty line
// two or more elements
StringBuilder buf = new StringBuilder(256);
if (first != null) {
            buf.append(first);
        }
empty line
while (iterator.hasNext()) {
            buf.append(separator);
            Object obj = iterator.next();
            if (obj != null) {
                buf.append(obj);
            }
        }
empty line
return buf.toString();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.StringUtils <3413, 3438>
if (Iterator == null) {
            return null;
        }
if (!Iterator.hasNext()) {
            return StringVar;
        }
Object Object = Iterator.next();
if (!Iterator.hasNext()) {
            return ObjectUtils.toString(Object);
        }
empty line
// two or more elements
StringBuilder StringBuilder = new StringBuilder(256);
if (Object != null) {
            StringBuilder.append(Object);
        }
empty line
while (Iterator.hasNext()) {
            StringBuilder.append(charVar);
            Object obj = Iterator.next();
            if (obj != null) {
                StringBuilder.append(obj);
            }
        }
empty line
return StringBuilder.toString();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <3413, 3438>
if (Iterator == null) {
            return null;
        }
if (!Iterator.hasNext()) {
            return EMPTY;
        }
Object Object = Iterator.next();
if (!Iterator.hasNext()) {
            return ObjectUtils.toString(Object);
        }
empty line
// two or more elements
StringBuilder StringBuilder = new StringBuilder(256);
if (Object != null) {
            StringBuilder.append(Object);
        }
empty line
while (Iterator.hasNext()) {
            StringBuilder.append(separator);
            Object obj = Iterator.next();
            if (obj != null) {
                StringBuilder.append(obj);
            }
        }
empty line
return StringBuilder.toString();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <3413, 3438>
if (iterator == null) {
            return null;
        }
if (!iterator.hasNext()) {
            return EMPTY;
        }
Object first = iterator.next();
if (!iterator.hasNext()) {
            return ObjectUtils.toString(first);
        }
empty line
// two or more elements
StringBuilder buf = new StringBuilder(256);
if (first != null) {
            buf.append(first);
        }
empty line
while (iterator.hasNext()) {
            buf.append(separator);
            Object obj = iterator.next();
            if (obj != null) {
                buf.append(obj);
            }
        }
empty line
return buf.toString();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.StringUtils <3413, 3438>
if (Iterator == null) {
            return null;
        }
if (!Iterator.hasNext()) {
            return StringVar;
        }
Object Object = Iterator.next();
if (!Iterator.hasNext()) {
            return ObjectUtils.toString(Object);
        }
empty line
// two or more elements
StringBuilder StringBuilder = new StringBuilder(256);
if (Object != null) {
            StringBuilder.append(Object);
        }
empty line
while (Iterator.hasNext()) {
            StringBuilder.append(charVar);
            Object obj = Iterator.next();
            if (obj != null) {
                StringBuilder.append(obj);
            }
        }
empty line
return StringBuilder.toString();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <3413, 3438>
if (Iterator == null) {
            return null;
        }
if (!Iterator.hasNext()) {
            return EMPTY;
        }
Object Object = Iterator.next();
if (!Iterator.hasNext()) {
            return ObjectUtils.toString(Object);
        }
empty line
// two or more elements
StringBuilder StringBuilder = new StringBuilder(256);
if (Object != null) {
            StringBuilder.append(Object);
        }
empty line
while (Iterator.hasNext()) {
            StringBuilder.append(separator);
            Object obj = Iterator.next();
            if (obj != null) {
                StringBuilder.append(obj);
            }
        }
empty line
return StringBuilder.toString();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.math.Fraction <930, 957>
if (toProperString == null) {
            if (numerator == 0) {
                toProperString = "0";
            } else if (numerator == denominator) {
                toProperString = "1";
            } else if (numerator == -1 * denominator) {
                toProperString = "-1";
            } else if ((numerator>0?-numerator:numerator) < -denominator) {
                // note that we do the magnitude comparison test above with
                // NEGATIVE (not positive) numbers, since negative numbers
                // have a larger range.  otherwise numerator==Integer.MIN_VALUE
                // is handled incorrectly.
                int properNumerator = getProperNumerator();
                if (properNumerator == 0) {
                    toProperString = Integer.toString(getProperWhole());
                } else {
                    toProperString = new StringBuilder(32)
                        .append(getProperWhole()).append(' ')
                        .append(properNumerator).append('/')
                        .append(getDenominator()).toString();
                }
            } else {
                toProperString = new StringBuilder(32)
                    .append(getNumerator()).append('/')
                    .append(getDenominator()).toString();
            }
        }
return toProperString;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.math.Fraction <930, 957>
if (StringVar == null) {
            if (intVar == 0) {
                StringVar = "0";
            } else if (intVar == intVar) {
                StringVar = "1";
            } else if (intVar == -1 * intVar) {
                StringVar = "-1";
            } else if ((intVar>0?-intVar:intVar) < -intVar) {
                // note that we do the magnitude comparison test above with
                // NEGATIVE (not positive) numbers, since negative numbers
                // have a larger range.  otherwise numerator==Integer.MIN_VALUE
                // is handled incorrectly.
                int properNumerator = getProperNumerator();
                if (properNumerator == 0) {
                    StringVar = Integer.toString(getProperWhole());
                } else {
                    StringVar = new StringBuilder(32)
                        .append(getProperWhole()).append(' ')
                        .append(properNumerator).append('/')
                        .append(getDenominator()).toString();
                }
            } else {
                StringVar = new StringBuilder(32)
                    .append(getNumerator()).append('/')
                    .append(getDenominator()).toString();
            }
        }
return StringVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.math.Fraction <930, 957>
if (toProperString == null) {
            if (numerator == 0) {
                toProperString = "0";
            } else if (numerator == denominator) {
                toProperString = "1";
            } else if (numerator == -1 * denominator) {
                toProperString = "-1";
            } else if ((numerator>0?-numerator:numerator) < -denominator) {
                // note that we do the magnitude comparison test above with
                // NEGATIVE (not positive) numbers, since negative numbers
                // have a larger range.  otherwise numerator==Integer.MIN_VALUE
                // is handled incorrectly.
                int properNumerator = getProperNumerator();
                if (properNumerator == 0) {
                    toProperString = Integer.toString(getProperWhole());
                } else {
                    toProperString = new StringBuilder(32)
                        .append(getProperWhole()).append(' ')
                        .append(properNumerator).append('/')
                        .append(getDenominator()).toString();
                }
            } else {
                toProperString = new StringBuilder(32)
                    .append(getNumerator()).append('/')
                    .append(getDenominator()).toString();
            }
        }
return toProperString;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.Range <428, 439>
String result = toString;
if (result == null) {
            StringBuilder buf = new StringBuilder(32);
            buf.append('[');
            buf.append(minimum);
            buf.append("..");
            buf.append(maximum);
            buf.append(']');
            result = buf.toString();
            toString = result;
        }
return result;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.Range <428, 439>
String StringVar = StringVar;
if (StringVar == null) {
            StringBuilder buf = new StringBuilder(32);
            buf.append('[');
            buf.append(TVar);
            buf.append("..");
            buf.append(TVar);
            buf.append(']');
            StringVar = buf.toString();
            StringVar = StringVar;
        }
return StringVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.Range <428, 439>
String result = toString;
if (result == null) {
            StringBuilder buf = new StringBuilder(32);
            buf.append('[');
            buf.append(minimum);
            buf.append("..");
            buf.append(maximum);
            buf.append(']');
            result = buf.toString();
            toString = result;
        }
return result;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <4035, 4098>
int searchLength = searchList.length;
int replacementLength = replacementList.length;
empty line
// make sure lengths are ok, these need to be equal
if (searchLength != replacementLength) {
            throw new IllegalArgumentException("Search and Replace array lengths don't match: "
                + searchLength
                + " vs "
                + replacementLength);
        }
empty line
// keep track of which still have matches
boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];
empty line
// index on index that the match was found
int textIndex = -1;
int replaceIndex = -1;
int tempIndex = -1;
empty line
// index of replace array that will replace the search string found
// NOTE: logic duplicated below START
for (int i = 0; i < searchLength; i++) {
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||
                    searchList[i].length() == 0 || replacementList[i] == null) {
                continue;
            }
            tempIndex = text.indexOf(searchList[i]);

            // see if we need to keep searching for this
            if (tempIndex == -1) {
                noMoreMatchesForReplIndex[i] = true;
            } else {
                if (textIndex == -1 || tempIndex < textIndex) {
                    textIndex = tempIndex;
                    replaceIndex = i;
                }
            }
        }
// NOTE: logic mostly below END
empty line
// no search strings found, we are done
if (textIndex == -1) {
            return text;
        }
empty line
int start = 0;
empty line
// get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit
int increase = 0;
empty line
// count the replacement text elements that are larger than their corresponding text being replaced
for (int i = 0; i < searchList.length; i++) {
            if (searchList[i] == null || replacementList[i] == null) {
                continue;
            }
            int greater = replacementList[i].length() - searchList[i].length();
            if (greater > 0) {
                increase += 3 * greater; // assume 3 matches
            }
        }
// have upper-bound at 20% increase, then let Java take over
increase = Math.min(increase, text.length() / 5);
empty line
StringBuilder buf = new StringBuilder(text.length() + increase);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.StringUtils <4035, 4098>
int intVar = String[]Var.length;
int intVar = String[]Var.length;
empty line
// make sure lengths are ok, these need to be equal
if (intVar != intVar) {
            throw new IllegalArgumentException("Search and Replace array lengths don't match: "
                + intVar
                + " vs "
                + intVar);
        }
empty line
// keep track of which still have matches
boolean[] boolean[]Var = new boolean[intVar];
empty line
// index on index that the match was found
int intVar = -1;
int intVar = -1;
int intVar = -1;
empty line
// index of replace array that will replace the search string found
// NOTE: logic duplicated below START
for (int intVar = 0; intVar < intVar; intVar++) {
            if (boolean[]Var[intVar] || String[]Var[intVar] == null ||
                    String[]Var[intVar].length() == 0 || String[]Var[intVar] == null) {
                continue;
            }
            intVar = StringVar.indexOf(String[]Var[intVar]);

            // see if we need to keep searching for this
            if (intVar == -1) {
                boolean[]Var[intVar] = true;
            } else {
                if (intVar == -1 || intVar < intVar) {
                    intVar = intVar;
                    intVar = intVar;
                }
            }
        }
// NOTE: logic mostly below END
empty line
// no search strings found, we are done
if (intVar == -1) {
            return StringVar;
        }
empty line
int intVar = 0;
empty line
// get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit
int intVar = 0;
empty line
// count the replacement text elements that are larger than their corresponding text being replaced
for (int intVar = 0; intVar < String[]Var.length; intVar++) {
            if (String[]Var[intVar] == null || String[]Var[intVar] == null) {
                continue;
            }
            int greater = String[]Var[intVar].length() - String[]Var[intVar].length();
            if (greater > 0) {
                intVar += 3 * greater; // assume 3 matches
            }
        }
// have upper-bound at 20% increase, then let Java take over
intVar = Math.min(intVar, StringVar.length() / 5);
empty line
StringBuilder StringBuilder = new StringBuilder(StringVar.length() + intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <4035, 4098>
int searchLength = searchList.length;
int replacementLength = replacementList.length;
empty line
// make sure lengths are ok, these need to be equal
if (searchLength != replacementLength) {
            throw new IllegalArgumentException("Search and Replace array lengths don't match: "
                + searchLength
                + " vs "
                + replacementLength);
        }
empty line
// keep track of which still have matches
boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];
empty line
// index on index that the match was found
int textIndex = -1;
int replaceIndex = -1;
int tempIndex = -1;
empty line
// index of replace array that will replace the search string found
// NOTE: logic duplicated below START
for (int i = 0; i < searchLength; i++) {
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||
                    searchList[i].length() == 0 || replacementList[i] == null) {
                continue;
            }
            tempIndex = text.indexOf(searchList[i]);

            // see if we need to keep searching for this
            if (tempIndex == -1) {
                noMoreMatchesForReplIndex[i] = true;
            } else {
                if (textIndex == -1 || tempIndex < textIndex) {
                    textIndex = tempIndex;
                    replaceIndex = i;
                }
            }
        }
// NOTE: logic mostly below END
empty line
// no search strings found, we are done
if (textIndex == -1) {
            return text;
        }
empty line
int start = 0;
empty line
// get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit
int increase = 0;
empty line
// count the replacement text elements that are larger than their corresponding text being replaced
for (int i = 0; i < searchList.length; i++) {
            if (searchList[i] == null || replacementList[i] == null) {
                continue;
            }
            int greater = replacementList[i].length() - searchList[i].length();
            if (greater > 0) {
                increase += 3 * greater; // assume 3 matches
            }
        }
// have upper-bound at 20% increase, then let Java take over
increase = Math.min(increase, text.length() / 5);
empty line
StringBuilder StringBuilder = new StringBuilder(text.length() + increase);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <5773, 5790>
if (isEmpty(str) || isEmpty(middle)) {
            return str;
        }
empty line
if (length >= str.length() || length < (middle.length()+2)) {
            return str;
        }
empty line
int targetSting = length-middle.length();
int startOffset = targetSting/2+targetSting%2;
int endOffset = str.length()-targetSting/2;
empty line
StringBuilder builder = new StringBuilder(length);
builder.append(str.substring(0,startOffset));
builder.append(middle);
builder.append(str.substring(endOffset));
empty line
return builder.toString();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.StringUtils <5773, 5790>
if (isEmpty(StringVar) || isEmpty(StringVar)) {
            return StringVar;
        }
empty line
if (intVar >= StringVar.length() || intVar < (StringVar.length()+2)) {
            return StringVar;
        }
empty line
int intVar = intVar-StringVar.length();
int intVar = intVar/2+intVar%2;
int intVar = StringVar.length()-intVar/2;
empty line
StringBuilder StringBuilder = new StringBuilder(intVar);
StringBuilder.append(StringVar.substring(0,intVar));
StringBuilder.append(StringVar);
StringBuilder.append(StringVar.substring(intVar));
empty line
return StringBuilder.toString();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <5773, 5790>
if (isEmpty(str) || isEmpty(middle)) {
            return str;
        }
empty line
if (length >= str.length() || length < (middle.length()+2)) {
            return str;
        }
empty line
int targetSting = length-middle.length();
int startOffset = targetSting/2+targetSting%2;
int endOffset = str.length()-targetSting/2;
empty line
StringBuilder StringBuilder = new StringBuilder(length);
StringBuilder.append(str.substring(0,startOffset));
StringBuilder.append(middle);
StringBuilder.append(str.substring(endOffset));
empty line
return StringBuilder.toString();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.ClassUtils <922, 939>
className = StringUtils.deleteWhitespace(className);
if (className == null) {
            throw new NullPointerException("className must not be null.");
        } else if (className.endsWith("[]")) {
            StringBuilder classNameBuffer = new StringBuilder();
            while (className.endsWith("[]")) {
                className = className.substring(0, className.length() - 2);
                classNameBuffer.append("[");
            }
            String abbreviation = abbreviationMap.get(className);
            if (abbreviation != null) {
                classNameBuffer.append(abbreviation);
            } else {
                classNameBuffer.append("L").append(className).append(";");
            }
            className = classNameBuffer.toString();
        }
return className;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.ClassUtils <922, 939>
StringVar = StringUtils.deleteWhitespace(StringVar);
if (StringVar == null) {
            throw new NullPointerException("className must not be null.");
        } else if (StringVar.endsWith("[]")) {
            StringBuilder classNameBuffer = new StringBuilder();
            while (StringVar.endsWith("[]")) {
                StringVar = StringVar.substring(0, StringVar.length() - 2);
                classNameBuffer.append("[");
            }
            String abbreviation = Map.get(StringVar);
            if (abbreviation != null) {
                classNameBuffer.append(abbreviation);
            } else {
                classNameBuffer.append("L").append(StringVar).append(";");
            }
            StringVar = classNameBuffer.toString();
        }
return StringVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.ClassUtils <922, 939>
className = StringUtils.deleteWhitespace(className);
if (className == null) {
            throw new NullPointerException("className must not be null.");
        } else if (className.endsWith("[]")) {
            StringBuilder classNameBuffer = new StringBuilder();
            while (className.endsWith("[]")) {
                className = className.substring(0, className.length() - 2);
                classNameBuffer.append("[");
            }
            String abbreviation = Map.get(className);
            if (abbreviation != null) {
                classNameBuffer.append(abbreviation);
            } else {
                classNameBuffer.append("L").append(className).append(";");
            }
            className = classNameBuffer.toString();
        }
return className;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.math.NumberUtils <1323, 1377>
if (sz > start + 1) {
            if (chars[start] == '0' && chars[start + 1] == 'x') {
                int i = start + 2;
                if (i == sz) {
                    return false; // str == "0x"
                }
                // checking hex (it can't be anything else)
                for (; i < chars.length; i++) {
                    if ((chars[i] < '0' || chars[i] > '9')
                        && (chars[i] < 'a' || chars[i] > 'f')
                        && (chars[i] < 'A' || chars[i] > 'F')) {
                        return false;
                    }
                }
                return true;
            }
        }
sz--;
// for type qualifiers
int i = start;
// loop to the next to last char or to the last char if we need another digit to
// make a valid number (e.g. chars[0..5] = "1234E")
while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
            if (chars[i] >= '0' && chars[i] <= '9') {
                foundDigit = true;
                allowSigns = false;

            } else if (chars[i] == '.') {
                if (hasDecPoint || hasExp) {
                    // two decimal points or dec in exponent   
                    return false;
                }
                hasDecPoint = true;
            } else if (chars[i] == 'e' || chars[i] == 'E') {
                // we've already taken care of hex.
                if (hasExp) {
                    // two E's
                    return false;
                }
                if (!foundDigit) {
                    return false;
                }
                hasExp = true;
                allowSigns = true;
            } else if (chars[i] == '+' || chars[i] == '-') {
                if (!allowSigns) {
                    return false;
                }
                allowSigns = false;
                foundDigit = false; // we need a digit after the E
            } else {
                return false;
            }
            i++;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.math.NumberUtils <1323, 1377>
if (intVar > intVar + 1) {
            if (char[]Var[intVar] == '0' && char[]Var[intVar + 1] == 'x') {
                int i = intVar + 2;
                if (i == intVar) {
                    return false; // str == "0x"
                }
                // checking hex (it can't be anything else)
                for (; i < char[]Var.length; i++) {
                    if ((char[]Var[i] < '0' || char[]Var[i] > '9')
                        && (char[]Var[i] < 'a' || char[]Var[i] > 'f')
                        && (char[]Var[i] < 'A' || char[]Var[i] > 'F')) {
                        return false;
                    }
                }
                return true;
            }
        }
intVar--;
// for type qualifiers
int intVar = intVar;
// loop to the next to last char or to the last char if we need another digit to
// make a valid number (e.g. chars[0..5] = "1234E")
while (intVar < intVar || (intVar < intVar + 1 && booleanVar && !booleanVar)) {
            if (char[]Var[intVar] >= '0' && char[]Var[intVar] <= '9') {
                booleanVar = true;
                booleanVar = false;

            } else if (char[]Var[intVar] == '.') {
                if (booleanVar || booleanVar) {
                    // two decimal points or dec in exponent   
                    return false;
                }
                booleanVar = true;
            } else if (char[]Var[intVar] == 'e' || char[]Var[intVar] == 'E') {
                // we've already taken care of hex.
                if (booleanVar) {
                    // two E's
                    return false;
                }
                if (!booleanVar) {
                    return false;
                }
                booleanVar = true;
                booleanVar = true;
            } else if (char[]Var[intVar] == '+' || char[]Var[intVar] == '-') {
                if (!booleanVar) {
                    return false;
                }
                booleanVar = false;
                booleanVar = false; // we need a digit after the E
            } else {
                return false;
            }
            intVar++;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.math.NumberUtils <1323, 1377>
if (sz > start + 1) {
            if (chars[start] == '0' && chars[start + 1] == 'x') {
                int i = start + 2;
                if (i == sz) {
                    return false; // str == "0x"
                }
                // checking hex (it can't be anything else)
                for (; i < chars.length; i++) {
                    if ((chars[i] < '0' || chars[i] > '9')
                        && (chars[i] < 'a' || chars[i] > 'f')
                        && (chars[i] < 'A' || chars[i] > 'F')) {
                        return false;
                    }
                }
                return true;
            }
        }
sz--;
// for type qualifiers
int i = start;
// loop to the next to last char or to the last char if we need another digit to
// make a valid number (e.g. chars[0..5] = "1234E")
while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
            if (chars[i] >= '0' && chars[i] <= '9') {
                foundDigit = true;
                allowSigns = false;

            } else if (chars[i] == '.') {
                if (hasDecPoint || hasExp) {
                    // two decimal points or dec in exponent   
                    return false;
                }
                hasDecPoint = true;
            } else if (chars[i] == 'e' || chars[i] == 'E') {
                // we've already taken care of hex.
                if (hasExp) {
                    // two E's
                    return false;
                }
                if (!foundDigit) {
                    return false;
                }
                hasExp = true;
                allowSigns = true;
            } else if (chars[i] == '+' || chars[i] == '-') {
                if (!allowSigns) {
                    return false;
                }
                allowSigns = false;
                foundDigit = false; // we need a digit after the E
            } else {
                return false;
            }
            i++;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.ArrayUtils <232, 255>
if (array == null) {
            return null;
        }
final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5));
for (int i = 0; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry<?, ?>) {
                Map.Entry<?,?> entry = (Map.Entry<?,?>) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException("Array element " + i + ", '"
                        + object
                        + "', has a length less than 2");
                }
                map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException("Array element " + i + ", '"
                        + object
                        + "', is neither of type Map.Entry nor an Array");
            }
        }
return map;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.ArrayUtils <232, 255>
if (Object[]Var == null) {
            return null;
        }
final Map<Object, Object> Map = new HashMap<Object, Object>((int) (Object[]Var.length * 1.5));
for (int intVar = 0; intVar < Object[]Var.length; intVar++) {
            Object object = Object[]Var[intVar];
            if (object instanceof Map.Entry<?, ?>) {
                Map.Entry<?,?> entry = (Map.Entry<?,?>) object;
                Map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException("Array element " + intVar + ", '"
                        + object
                        + "', has a length less than 2");
                }
                Map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException("Array element " + intVar + ", '"
                        + object
                        + "', is neither of type Map.Entry nor an Array");
            }
        }
return Map;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.ArrayUtils <232, 255>
if (array == null) {
            return null;
        }
final Map<Object, Object> Map = new HashMap<Object, Object>((int) (array.length * 1.5));
for (int i = 0; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry<?, ?>) {
                Map.Entry<?,?> entry = (Map.Entry<?,?>) object;
                Map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException("Array element " + i + ", '"
                        + object
                        + "', has a length less than 2");
                }
                Map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException("Array element " + i + ", '"
                        + object
                        + "', is neither of type Map.Entry nor an Array");
            }
        }
return Map;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.builder.ToStringStyle <350, 357>
if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) {
                String data = toString.substring(pos1, pos2);
                if (fieldSeparatorAtStart) {
                    removeLastFieldSeparator(buffer);
                }
                buffer.append(data);
                appendFieldSeparator(buffer);
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.builder.ToStringStyle <350, 357>
if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) {
                String data = toString.substring(pos1, pos2);
                if (fieldSeparatorAtStart) {
                    removeLastFieldSeparator(StringBuffer);
                }
                StringBuffer.append(data);
                appendFieldSeparator(StringBuffer);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <798, 802>
if (str1 == null || str2 == null) {
            return str1 == str2;
        } else {
            return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, Math.max(str1.length(), str2.length()));
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.ArrayUtils <238, 253>
if (object instanceof Map.Entry<?, ?>) {
                Map.Entry<?,?> entry = (Map.Entry<?,?>) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException("Array element " + i + ", '"
                        + object
                        + "', has a length less than 2");
                }
                map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException("Array element " + i + ", '"
                        + object
                        + "', is neither of type Map.Entry nor an Array");
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.ArrayUtils <238, 253>
if (Object instanceof Map.Entry<?, ?>) {
                Map.Entry<?,?> entry = (Map.Entry<?,?>) Object;
                Map.put(entry.getKey(), entry.getValue());
            } else if (Object instanceof Object[]) {
                Object[] entry = (Object[]) Object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException("Array element " + intVar + ", '"
                        + Object
                        + "', has a length less than 2");
                }
                Map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException("Array element " + intVar + ", '"
                        + Object
                        + "', is neither of type Map.Entry nor an Array");
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.ArrayUtils <238, 253>
if (Object instanceof Map.Entry<?, ?>) {
                Map.Entry<?,?> entry = (Map.Entry<?,?>) Object;
                Map.put(entry.getKey(), entry.getValue());
            } else if (Object instanceof Object[]) {
                Object[] entry = (Object[]) Object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException("Array element " + i + ", '"
                        + Object
                        + "', has a length less than 2");
                }
                Map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException("Array element " + i + ", '"
                        + Object
                        + "', is neither of type Map.Entry nor an Array");
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.text.StrBuilder <230, 234>
if (capacity > buffer.length) {
            char[] old = buffer;
            buffer = new char[capacity * 2];
            System.arraycopy(old, 0, buffer, 0, size);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.text.StrBuilder <230, 234>
if (intVar > char[]Var.length) {
            char[] old = char[]Var;
            char[]Var = new char[intVar * 2];
            System.arraycopy(old, 0, char[]Var, 0, intVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.text.StrBuilder <230, 234>
if (capacity > buffer.length) {
            char[] old = buffer;
            buffer = new char[capacity * 2];
            System.arraycopy(old, 0, buffer, 0, size);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <4891, 4904>
if (str == null || size <= 0) {
            return str;
        }
if (isEmpty(padStr)) {
            padStr = " ";
        }
int strLen = str.length();
int pads = size - strLen;
if (pads <= 0) {
            return str;
        }
str = leftPad(str, strLen + pads / 2, padStr);
str = rightPad(str, size, padStr);
return str;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.StringUtils <4891, 4904>
if (StringVar == null || intVar <= 0) {
            return StringVar;
        }
if (isEmpty(StringVar)) {
            StringVar = " ";
        }
int intVar = StringVar.length();
int intVar = intVar - intVar;
if (intVar <= 0) {
            return StringVar;
        }
StringVar = leftPad(StringVar, intVar + intVar / 2, StringVar);
StringVar = rightPad(StringVar, intVar, StringVar);
return StringVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <4891, 4904>
if (str == null || size <= 0) {
            return str;
        }
if (isEmpty(padStr)) {
            padStr = " ";
        }
int strLen = str.length();
int pads = size - strLen;
if (pads <= 0) {
            return str;
        }
str = leftPad(str, strLen + pads / 2, padStr);
str = rightPad(str, size, padStr);
return str;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.math.Fraction <797, 809>
if (fraction == null) {
            throw new IllegalArgumentException("The fraction must not be null");
        }
if (numerator == 0 || fraction.numerator == 0) {
            return ZERO;
        }
// knuth 4.5.1
// make sure we don't overflow unless the result *must* overflow.
int d1 = greatestCommonDivisor(numerator, fraction.denominator);
int d2 = greatestCommonDivisor(fraction.numerator, denominator);
return getReducedFraction
            (mulAndCheck(numerator/d1, fraction.numerator/d2),
             mulPosAndCheck(denominator/d2, fraction.denominator/d1));

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.math.Fraction <797, 809>
if (null == null) {
            throw new IllegalArgumentException("The fraction must not be null");
        }
if (numerator == 0 || Number.numerator == 0) {
            return null;
        }
// knuth 4.5.1
// make sure we don't overflow unless the result *must* overflow.
int d1 = greatestCommonDivisor(numerator, Number.denominator);
int d2 = greatestCommonDivisor(Number.numerator, denominator);
return getReducedFraction
            (mulAndCheck(numerator/d1, Number.numerator/d2),
             mulPosAndCheck(denominator/d2, Number.denominator/d1));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.math.Fraction <797, 809>
if (fraction == null) {
            throw new IllegalArgumentException("The fraction must not be null");
        }
if (numerator == 0 || fraction.numerator == 0) {
            return ZERO;
        }
// knuth 4.5.1
// make sure we don't overflow unless the result *must* overflow.
int d1 = greatestCommonDivisor(numerator, fraction.denominator);
int d2 = greatestCommonDivisor(fraction.numerator, denominator);
return getReducedFraction
            (mulAndCheck(numerator/d1, fraction.numerator/d2),
             mulPosAndCheck(denominator/d2, fraction.denominator/d1));

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.math.Fraction <797, 809>
if (null == null) {
            throw new IllegalArgumentException("The fraction must not be null");
        }
if (numerator == 0 || Number.numerator == 0) {
            return null;
        }
// knuth 4.5.1
// make sure we don't overflow unless the result *must* overflow.
int d1 = greatestCommonDivisor(numerator, Number.denominator);
int d2 = greatestCommonDivisor(Number.numerator, denominator);
return getReducedFraction
            (mulAndCheck(numerator/d1, Number.numerator/d2),
             mulPosAndCheck(denominator/d2, Number.denominator/d1));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.ArrayUtils <3492, 3500>
if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
boolean[] joinedArray = new boolean[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.ArrayUtils <3492, 3500>
if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
boolean[] joinedArray = new boolean[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.ArrayUtils <3521, 3529>
if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
char[] joinedArray = new char[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.ArrayUtils <3521, 3529>
if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
char[] joinedArray = new char[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.ArrayUtils <3550, 3558>
if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
byte[] joinedArray = new byte[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.ArrayUtils <3550, 3558>
if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
byte[] joinedArray = new byte[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.ArrayUtils <3579, 3587>
if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
short[] joinedArray = new short[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.ArrayUtils <3579, 3587>
if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
short[] joinedArray = new short[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.ArrayUtils <3608, 3616>
if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
int[] joinedArray = new int[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.ArrayUtils <3608, 3616>
if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
int[] joinedArray = new int[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.ArrayUtils <3637, 3645>
if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
long[] joinedArray = new long[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.ArrayUtils <3637, 3645>
if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
long[] joinedArray = new long[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.ArrayUtils <3666, 3674>
if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
float[] joinedArray = new float[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.ArrayUtils <3666, 3674>
if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
float[] joinedArray = new float[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.ArrayUtils <3695, 3703>
if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
double[] joinedArray = new double[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.ArrayUtils <3695, 3703>
if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
double[] joinedArray = new double[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.reflect.MemberUtils <132, 156>
if (destClass.isPrimitive()) {
            return getPrimitivePromotionCost(srcClass, destClass);
        }
float cost = 0.0f;
while (srcClass != null && !destClass.equals(srcClass)) {
            if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) {
                // slight penalty for interface match.
                // we still want an exact match to override an interface match,
                // but
                // an interface match should override anything where we have to
                // get a superclass.
                cost += 0.25f;
                break;
            }
            cost++;
            srcClass = srcClass.getSuperclass();
        }
/*
* If the destination class is null, we've travelled all the way up to
* an Object match. We'll penalize this by adding 1.5 to the cost.
*/
if (srcClass == null) {
            cost += 1.5f;
        }
return cost;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.reflect.MemberUtils <132, 156>
if (Class.isPrimitive()) {
            return getPrimitivePromotionCost(Class, Class);
        }
float floatVar = 0.0f;
while (Class != null && !Class.equals(Class)) {
            if (Class.isInterface() && ClassUtils.isAssignable(Class, Class)) {
                // slight penalty for interface match.
                // we still want an exact match to override an interface match,
                // but
                // an interface match should override anything where we have to
                // get a superclass.
                floatVar += 0.25f;
                break;
            }
            floatVar++;
            Class = Class.getSuperclass();
        }
/*
* If the destination class is null, we've travelled all the way up to
* an Object match. We'll penalize this by adding 1.5 to the cost.
*/
if (Class == null) {
            floatVar += 1.5f;
        }
return floatVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.reflect.MemberUtils <132, 156>
if (Class.isPrimitive()) {
            return getPrimitivePromotionCost(Class, Class);
        }
float cost = 0.0f;
while (Class != null && !Class.equals(Class)) {
            if (Class.isInterface() && ClassUtils.isAssignable(Class, Class)) {
                // slight penalty for interface match.
                // we still want an exact match to override an interface match,
                // but
                // an interface match should override anything where we have to
                // get a superclass.
                cost += 0.25f;
                break;
            }
            cost++;
            Class = Class.getSuperclass();
        }
/*
* If the destination class is null, we've travelled all the way up to
* an Object match. We'll penalize this by adding 1.5 to the cost.
*/
if (Class == null) {
            cost += 1.5f;
        }
return cost;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.text.StrBuilder <2545, 2547>
if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {
                return false;
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.text.StrBuilder <2545, 2547>
if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {
                return false;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.ArrayUtils <3446, 3471>
if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
final Class<?> type1 = array1.getClass().getComponentType();
@SuppressWarnings("unchecked") // OK, because array is of type T
        T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
try {
            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
        } catch (ArrayStoreException ase) {
            // Check if problem was due to incompatible types
            /*
             * We do this here, rather than before the copy because:
             * - it would be a wasted check most of the time
             * - safer, in case check turns out to be too strict
             */
            final Class<?> type2 = array2.getClass().getComponentType();
            if (!type1.isAssignableFrom(type2)){
                throw new IllegalArgumentException("Cannot store "+type2.getName()+" in an array of "
                        +type1.getName(), ase);
            }
            throw ase; // No, so rethrow original
        }
return joinedArray;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.ArrayUtils <3446, 3471>
if (T[]Var == null) {
            return clone(TVar);
        } else if (TVar == null) {
            return clone(T[]Var);
        }
final Class<?> Class = T[]Var.getClass().getComponentType();
@SuppressWarnings("unchecked") // OK, because array is of type T
        T[] T[]Var = (T[]) Array.newInstance(Class, T[]Var.length + TVar.length);
System.arraycopy(T[]Var, 0, T[]Var, 0, T[]Var.length);
try {
            System.arraycopy(TVar, 0, T[]Var, T[]Var.length, TVar.length);
        } catch (ArrayStoreException ase) {
            // Check if problem was due to incompatible types
            /*
             * We do this here, rather than before the copy because:
             * - it would be a wasted check most of the time
             * - safer, in case check turns out to be too strict
             */
            final Class<?> type2 = array2.getClass().getComponentType();
            if (!type1.isAssignableFrom(type2)){
                throw new IllegalArgumentException("Cannot store "+type2.getName()+" in an array of "
                        +type1.getName(), ase);
            }
            throw ase; // No, so rethrow original
        }
return T[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.ArrayUtils <3446, 3471>
if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
final Class<?> Class = array1.getClass().getComponentType();
@SuppressWarnings("unchecked") // OK, because array is of type T
        T[] joinedArray = (T[]) Array.newInstance(Class, array1.length + array2.length);
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
try {
            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
        } catch (ArrayStoreException ase) {
            // Check if problem was due to incompatible types
            /*
             * We do this here, rather than before the copy because:
             * - it would be a wasted check most of the time
             * - safer, in case check turns out to be too strict
             */
            final Class<?> type2 = array2.getClass().getComponentType();
            if (!type1.isAssignableFrom(type2)){
                throw new IllegalArgumentException("Cannot store "+type2.getName()+" in an array of "
                        +type1.getName(), ase);
            }
            throw ase; // No, so rethrow original
        }
return joinedArray;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <4851, 4861>
if (str == null || size <= 0) {
            return str;
        }
int strLen = str.length();
int pads = size - strLen;
if (pads <= 0) {
            return str;
        }
str = leftPad(str, strLen + pads / 2, padChar);
str = rightPad(str, size, padChar);
return str;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.StringUtils <4851, 4861>
if (StringVar == null || intVar <= 0) {
            return StringVar;
        }
int intVar = StringVar.length();
int intVar = intVar - intVar;
if (intVar <= 0) {
            return StringVar;
        }
StringVar = leftPad(StringVar, intVar + intVar / 2, charVar);
StringVar = rightPad(StringVar, intVar, charVar);
return StringVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <4851, 4861>
if (str == null || size <= 0) {
            return str;
        }
int strLen = str.length();
int pads = size - strLen;
if (pads <= 0) {
            return str;
        }
str = leftPad(str, strLen + pads / 2, padChar);
str = rightPad(str, size, padChar);
return str;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.time.DateUtils <154, 161>
if (date1 == null || date2 == null) {
            throw new IllegalArgumentException("The date must not be null");
        }
Calendar cal1 = Calendar.getInstance();
cal1.setTime(date1);
Calendar cal2 = Calendar.getInstance();
cal2.setTime(date2);
return isSameDay(cal1, cal2);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.reflect.TypeUtils <865, 886>
if (bounds.length < 2) {
            return bounds;
        }
empty line
Set<Type> types = new HashSet<Type>(bounds.length);
empty line
for (Type type1 : bounds) {
            boolean subtypeFound = false;

            for (Type type2 : bounds) {
                if (type1 != type2 && isAssignable(type2, type1, null)) {
                    subtypeFound = true;
                    break;
                }
            }

            if (!subtypeFound) {
                types.add(type1);
            }
        }
empty line
return types.toArray(new Type[types.size()]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.reflect.TypeUtils <865, 886>
if (Type[]Var.length < 2) {
            return Type[]Var;
        }
empty line
Set<Type> Set = new HashSet<Type>(Type[]Var.length);
empty line
for (Type type1 : Type[]Var) {
            boolean subtypeFound = false;

            for (Type type2 : Type[]Var) {
                if (Type != type2 && isAssignable(type2, Type, null)) {
                    subtypeFound = true;
                    break;
                }
            }

            if (!subtypeFound) {
                Set.add(Type);
            }
        }
empty line
return Set.toArray(new Type[Set.size()]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.reflect.TypeUtils <865, 886>
if (bounds.length < 2) {
            return bounds;
        }
empty line
Set<Type> Set = new HashSet<Type>(bounds.length);
empty line
for (Type type1 : bounds) {
            boolean subtypeFound = false;

            for (Type type2 : bounds) {
                if (Type != type2 && isAssignable(type2, Type, null)) {
                    subtypeFound = true;
                    break;
                }
            }

            if (!subtypeFound) {
                Set.add(Type);
            }
        }
empty line
return Set.toArray(new Type[Set.size()]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.reflect.TypeUtils <865, 886>
if (bounds.length < 2) {
            return bounds;
        }
empty line
Set<Type> types = new HashSet<Type>(bounds.length);
empty line
for (Type type1 : bounds) {
            boolean subtypeFound = false;

            for (Type type2 : bounds) {
                if (type1 != type2 && isAssignable(type2, type1, null)) {
                    subtypeFound = true;
                    break;
                }
            }

            if (!subtypeFound) {
                types.add(type1);
            }
        }
empty line
return types.toArray(new Type[types.size()]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.reflect.TypeUtils <865, 886>
if (Type[]Var.length < 2) {
            return Type[]Var;
        }
empty line
Set<Type> Set = new HashSet<Type>(Type[]Var.length);
empty line
for (Type type1 : Type[]Var) {
            boolean subtypeFound = false;

            for (Type type2 : Type[]Var) {
                if (Type != type2 && isAssignable(type2, Type, null)) {
                    subtypeFound = true;
                    break;
                }
            }

            if (!subtypeFound) {
                Set.add(Type);
            }
        }
empty line
return Set.toArray(new Type[Set.size()]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.reflect.TypeUtils <865, 886>
if (bounds.length < 2) {
            return bounds;
        }
empty line
Set<Type> Set = new HashSet<Type>(bounds.length);
empty line
for (Type type1 : bounds) {
            boolean subtypeFound = false;

            for (Type type2 : bounds) {
                if (Type != type2 && isAssignable(type2, Type, null)) {
                    subtypeFound = true;
                    break;
                }
            }

            if (!subtypeFound) {
                Set.add(Type);
            }
        }
empty line
return Set.toArray(new Type[Set.size()]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.reflect.TypeUtils <865, 886>
if (bounds.length < 2) {
            return bounds;
        }
empty line
Set<Type> types = new HashSet<Type>(bounds.length);
empty line
for (Type type1 : bounds) {
            boolean subtypeFound = false;

            for (Type type2 : bounds) {
                if (type1 != type2 && isAssignable(type2, type1, null)) {
                    subtypeFound = true;
                    break;
                }
            }

            if (!subtypeFound) {
                types.add(type1);
            }
        }
empty line
return types.toArray(new Type[types.size()]);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.reflect.TypeUtils <865, 886>
if (Type[]Var.length < 2) {
            return Type[]Var;
        }
empty line
Set<Type> Set = new HashSet<Type>(Type[]Var.length);
empty line
for (Type type1 : Type[]Var) {
            boolean subtypeFound = false;

            for (Type type2 : Type[]Var) {
                if (Type != type2 && isAssignable(type2, Type, null)) {
                    subtypeFound = true;
                    break;
                }
            }

            if (!subtypeFound) {
                Set.add(Type);
            }
        }
empty line
return Set.toArray(new Type[Set.size()]);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.reflect.TypeUtils <865, 886>
if (bounds.length < 2) {
            return bounds;
        }
empty line
Set<Type> Set = new HashSet<Type>(bounds.length);
empty line
for (Type type1 : bounds) {
            boolean subtypeFound = false;

            for (Type type2 : bounds) {
                if (Type != type2 && isAssignable(type2, Type, null)) {
                    subtypeFound = true;
                    break;
                }
            }

            if (!subtypeFound) {
                Set.add(Type);
            }
        }
empty line
return Set.toArray(new Type[Set.size()]);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.time.DurationFormatUtils <326, 331>
if (!Token.containsTokenWithValue(tokens, y) && years != 0) {
                while (years != 0) {
                    months += 12 * years;
                    years = 0;
                }
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.time.DurationFormatUtils <326, 331>
if (!Token.containsTokenWithValue(Token[]Var, Object) && intVar != 0) {
                while (intVar != 0) {
                    intVar += 12 * intVar;
                    intVar = 0;
                }
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.time.DurationFormatUtils <326, 331>
if (!Token.containsTokenWithValue(tokens, Object) && years != 0) {
                while (years != 0) {
                    months += 12 * years;
                    years = 0;
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <5777, 5779>
if (length >= str.length() || length < (middle.length()+2)) {
            return str;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.StringUtils <5777, 5779>
if (intVar >= StringVar.length() || intVar < (StringVar.length()+2)) {
            return StringVar;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <5777, 5779>
if (length >= str.length() || length < (middle.length()+2)) {
            return str;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.ClassUtils <799, 806>
if (lastDotIndex != -1) {
                try {
                    return getClass(classLoader, className.substring(0, lastDotIndex) +
                            INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1),
                            initialize);
                } catch (ClassNotFoundException ex2) {
                }
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.ClassUtils <799, 806>
if (intVar != -1) {
                try {
                    return getClass(ClassLoader, StringVar.substring(0, intVar) +
                            charVar + StringVar.substring(intVar + 1),
                            booleanVar);
                } catch (ClassNotFoundException ex2) {
                }
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.ClassUtils <799, 806>
if (lastDotIndex != -1) {
                try {
                    return getClass(ClassLoader, className.substring(0, lastDotIndex) +
                            INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1),
                            initialize);
                } catch (ClassNotFoundException ex2) {
                }
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.Validate <507, 514>
Validate.notNull(array);
for (int i = 0; i < array.length; i++) {
            if (array[i] == null) {
                Object[] values2 = ArrayUtils.add(values, Integer.valueOf(i));
                throw new IllegalArgumentException(String.format(message, values2));
            }
        }
return array;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.Validate <507, 514>
Validate.notNull(T[]Var);
for (int intVar = 0; intVar < T[]Var.length; intVar++) {
            if (T[]Var[intVar] == null) {
                Object[] values2 = ArrayUtils.add(Object, Integer.valueOf(intVar));
                throw new IllegalArgumentException(String.format(StringVar, values2));
            }
        }
return T[]Var;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.Validate <507, 514>
Validate.notNull(array);
for (int i = 0; i < array.length; i++) {
            if (array[i] == null) {
                Object[] values2 = ArrayUtils.add(Object, Integer.valueOf(i));
                throw new IllegalArgumentException(String.format(message, values2));
            }
        }
return array;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.math.Fraction <210, 232>
if (denominator == 0) {
            throw new ArithmeticException("The denominator must not be zero");
        }
if (numerator==0) {
            return ZERO; // normalize zero.
        }
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {
            numerator/=2; denominator/=2;
        }
if (denominator < 0) {
            if (numerator==Integer.MIN_VALUE ||
                    denominator==Integer.MIN_VALUE) {
                throw new ArithmeticException("overflow: can't negate");
            }
            numerator = -numerator;
            denominator = -denominator;
        }
// simplify fraction.
int gcd = greatestCommonDivisor(numerator, denominator);
numerator /= gcd;
denominator /= gcd;
return new Fraction(numerator, denominator);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.math.Fraction <210, 232>
if (intVar == 0) {
            throw new ArithmeticException("The denominator must not be zero");
        }
if (intVar==0) {
            return Number; // normalize zero.
        }
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (intVar==Integer.MIN_VALUE && (intVar&1)==0) {
            intVar/=2; intVar/=2;
        }
if (intVar < 0) {
            if (intVar==Integer.MIN_VALUE ||
                    intVar==Integer.MIN_VALUE) {
                throw new ArithmeticException("overflow: can't negate");
            }
            intVar = -intVar;
            intVar = -intVar;
        }
// simplify fraction.
int intVar = greatestCommonDivisor(intVar, intVar);
intVar /= intVar;
intVar /= intVar;
return new Fraction(intVar, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.math.Fraction <210, 232>
if (denominator == 0) {
            throw new ArithmeticException("The denominator must not be zero");
        }
if (numerator==0) {
            return null; // normalize zero.
        }
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {
            numerator/=2; denominator/=2;
        }
if (denominator < 0) {
            if (numerator==Integer.MIN_VALUE ||
                    denominator==Integer.MIN_VALUE) {
                throw new ArithmeticException("overflow: can't negate");
            }
            numerator = -numerator;
            denominator = -denominator;
        }
// simplify fraction.
int gcd = greatestCommonDivisor(numerator, denominator);
numerator /= gcd;
denominator /= gcd;
return new Fraction(numerator, denominator);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.math.Fraction <210, 232>
if (denominator == 0) {
            throw new ArithmeticException("The denominator must not be zero");
        }
if (numerator==0) {
            return ZERO; // normalize zero.
        }
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {
            numerator/=2; denominator/=2;
        }
if (denominator < 0) {
            if (numerator==Integer.MIN_VALUE ||
                    denominator==Integer.MIN_VALUE) {
                throw new ArithmeticException("overflow: can't negate");
            }
            numerator = -numerator;
            denominator = -denominator;
        }
// simplify fraction.
int gcd = greatestCommonDivisor(numerator, denominator);
numerator /= gcd;
denominator /= gcd;
return new Fraction(numerator, denominator);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.math.Fraction <210, 232>
if (intVar == 0) {
            throw new ArithmeticException("The denominator must not be zero");
        }
if (intVar==0) {
            return Number; // normalize zero.
        }
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (intVar==Integer.MIN_VALUE && (intVar&1)==0) {
            intVar/=2; intVar/=2;
        }
if (intVar < 0) {
            if (intVar==Integer.MIN_VALUE ||
                    intVar==Integer.MIN_VALUE) {
                throw new ArithmeticException("overflow: can't negate");
            }
            intVar = -intVar;
            intVar = -intVar;
        }
// simplify fraction.
int intVar = greatestCommonDivisor(intVar, intVar);
intVar /= intVar;
intVar /= intVar;
return new Fraction(intVar, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.math.Fraction <210, 232>
if (denominator == 0) {
            throw new ArithmeticException("The denominator must not be zero");
        }
if (numerator==0) {
            return null; // normalize zero.
        }
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {
            numerator/=2; denominator/=2;
        }
if (denominator < 0) {
            if (numerator==Integer.MIN_VALUE ||
                    denominator==Integer.MIN_VALUE) {
                throw new ArithmeticException("overflow: can't negate");
            }
            numerator = -numerator;
            denominator = -denominator;
        }
// simplify fraction.
int gcd = greatestCommonDivisor(numerator, denominator);
numerator /= gcd;
denominator /= gcd;
return new Fraction(numerator, denominator);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.math.Fraction <210, 232>
if (denominator == 0) {
            throw new ArithmeticException("The denominator must not be zero");
        }
if (numerator==0) {
            return ZERO; // normalize zero.
        }
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {
            numerator/=2; denominator/=2;
        }
if (denominator < 0) {
            if (numerator==Integer.MIN_VALUE ||
                    denominator==Integer.MIN_VALUE) {
                throw new ArithmeticException("overflow: can't negate");
            }
            numerator = -numerator;
            denominator = -denominator;
        }
// simplify fraction.
int gcd = greatestCommonDivisor(numerator, denominator);
numerator /= gcd;
denominator /= gcd;
return new Fraction(numerator, denominator);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.math.Fraction <210, 232>
if (intVar == 0) {
            throw new ArithmeticException("The denominator must not be zero");
        }
if (intVar==0) {
            return Number; // normalize zero.
        }
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (intVar==Integer.MIN_VALUE && (intVar&1)==0) {
            intVar/=2; intVar/=2;
        }
if (intVar < 0) {
            if (intVar==Integer.MIN_VALUE ||
                    intVar==Integer.MIN_VALUE) {
                throw new ArithmeticException("overflow: can't negate");
            }
            intVar = -intVar;
            intVar = -intVar;
        }
// simplify fraction.
int intVar = greatestCommonDivisor(intVar, intVar);
intVar /= intVar;
intVar /= intVar;
return new Fraction(intVar, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.math.Fraction <210, 232>
if (denominator == 0) {
            throw new ArithmeticException("The denominator must not be zero");
        }
if (numerator==0) {
            return null; // normalize zero.
        }
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {
            numerator/=2; denominator/=2;
        }
if (denominator < 0) {
            if (numerator==Integer.MIN_VALUE ||
                    denominator==Integer.MIN_VALUE) {
                throw new ArithmeticException("overflow: can't negate");
            }
            numerator = -numerator;
            denominator = -denominator;
        }
// simplify fraction.
int gcd = greatestCommonDivisor(numerator, denominator);
numerator /= gcd;
denominator /= gcd;
return new Fraction(numerator, denominator);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.math.Fraction <741, 783>
if (fraction == null) {
            throw new IllegalArgumentException("The fraction must not be null");
        }
// zero is identity for addition.
if (numerator == 0) {
            return isAdd ? fraction : fraction.negate();
        }
if (fraction.numerator == 0) {
            return this;
        }
// if denominators are randomly distributed, d1 will be 1 about 61%
// of the time.
int d1 = greatestCommonDivisor(denominator, fraction.denominator);
if (d1==1) {
            // result is ( (u*v' +/- u'v) / u'v')
            int uvp = mulAndCheck(numerator, fraction.denominator);
            int upv = mulAndCheck(fraction.numerator, denominator);
            return new Fraction
                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),
                 mulPosAndCheck(denominator, fraction.denominator));
        }
// the quantity 't' requires 65 bits of precision; see knuth 4.5.1
// exercise 7.  we're going to use a BigInteger.
// t = u(v'/d1) +/- v(u'/d1)
BigInteger uvp = BigInteger.valueOf(numerator)
            .multiply(BigInteger.valueOf(fraction.denominator/d1));
BigInteger upv = BigInteger.valueOf(fraction.numerator)
            .multiply(BigInteger.valueOf(denominator/d1));
BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);
// but d2 doesn't need extra precision because
// d2 = gcd(t,d1) = gcd(t mod d1, d1)
int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();
int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);
empty line
// result is (t/d2) / (u'/d1)(v'/d2)
BigInteger w = t.divide(BigInteger.valueOf(d2));
if (w.bitLength() > 31) {
            throw new ArithmeticException
                ("overflow: numerator too large after multiply");
        }
return new Fraction
            (w.intValue(),
             mulPosAndCheck(denominator/d1, fraction.denominator/d2));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.math.Fraction <741, 783>
if (Number == null) {
            throw new IllegalArgumentException("The fraction must not be null");
        }
// zero is identity for addition.
if (intVar == 0) {
            return booleanVar ? Number : Number.negate();
        }
if (Number.intVar == 0) {
            return this;
        }
// if denominators are randomly distributed, d1 will be 1 about 61%
// of the time.
int intVar = greatestCommonDivisor(intVar, Number.intVar);
if (intVar==1) {
            // result is ( (u*v' +/- u'v) / u'v')
            int uvp = mulAndCheck(intVar, Number.intVar);
            int upv = mulAndCheck(Number.intVar, intVar);
            return new Fraction
                (booleanVar ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),
                 mulPosAndCheck(intVar, Number.intVar));
        }
// the quantity 't' requires 65 bits of precision; see knuth 4.5.1
// exercise 7.  we're going to use a BigInteger.
// t = u(v'/d1) +/- v(u'/d1)
BigInteger BigInteger = BigInteger.valueOf(intVar)
            .multiply(BigInteger.valueOf(Number.intVar/intVar));
BigInteger BigInteger = BigInteger.valueOf(Number.intVar)
            .multiply(BigInteger.valueOf(intVar/intVar));
BigInteger BigInteger = booleanVar ? BigInteger.add(BigInteger) : BigInteger.subtract(BigInteger);
// but d2 doesn't need extra precision because
// d2 = gcd(t,d1) = gcd(t mod d1, d1)
int intVar = BigInteger.mod(BigInteger.valueOf(intVar)).intValue();
int intVar = (intVar==0)?intVar:greatestCommonDivisor(intVar, intVar);
empty line
// result is (t/d2) / (u'/d1)(v'/d2)
BigInteger BigInteger = BigInteger.divide(BigInteger.valueOf(intVar));
if (BigInteger.bitLength() > 31) {
            throw new ArithmeticException
                ("overflow: numerator too large after multiply");
        }
return new Fraction
            (BigInteger.intValue(),
             mulPosAndCheck(intVar/intVar, Number.intVar/intVar));

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.math.Fraction <741, 783>
if (null == null) {
            throw new IllegalArgumentException("The fraction must not be null");
        }
// zero is identity for addition.
if (numerator == 0) {
            return isAdd ? null : null.negate();
        }
if (Number.numerator == 0) {
            return this;
        }
// if denominators are randomly distributed, d1 will be 1 about 61%
// of the time.
int d1 = greatestCommonDivisor(denominator, Number.denominator);
if (d1==1) {
            // result is ( (u*v' +/- u'v) / u'v')
            int uvp = mulAndCheck(numerator, Number.denominator);
            int upv = mulAndCheck(Number.numerator, denominator);
            return new Fraction
                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),
                 mulPosAndCheck(denominator, Number.denominator));
        }
// the quantity 't' requires 65 bits of precision; see knuth 4.5.1
// exercise 7.  we're going to use a BigInteger.
// t = u(v'/d1) +/- v(u'/d1)
BigInteger BigInteger = BigInteger.valueOf(numerator)
            .multiply(BigInteger.valueOf(Number.denominator/d1));
BigInteger BigInteger = BigInteger.valueOf(Number.numerator)
            .multiply(BigInteger.valueOf(denominator/d1));
BigInteger BigInteger = isAdd ? BigInteger.add(BigInteger) : BigInteger.subtract(BigInteger);
// but d2 doesn't need extra precision because
// d2 = gcd(t,d1) = gcd(t mod d1, d1)
int tmodd1 = BigInteger.mod(BigInteger.valueOf(d1)).intValue();
int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);
empty line
// result is (t/d2) / (u'/d1)(v'/d2)
BigInteger BigInteger = BigInteger.divide(BigInteger.valueOf(d2));
if (BigInteger.bitLength() > 31) {
            throw new ArithmeticException
                ("overflow: numerator too large after multiply");
        }
return new Fraction
            (BigInteger.intValue(),
             mulPosAndCheck(denominator/d1, Number.denominator/d2));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.math.Fraction <741, 783>
if (fraction == null) {
            throw new IllegalArgumentException("The fraction must not be null");
        }
// zero is identity for addition.
if (numerator == 0) {
            return isAdd ? fraction : fraction.negate();
        }
if (fraction.numerator == 0) {
            return this;
        }
// if denominators are randomly distributed, d1 will be 1 about 61%
// of the time.
int d1 = greatestCommonDivisor(denominator, fraction.denominator);
if (d1==1) {
            // result is ( (u*v' +/- u'v) / u'v')
            int uvp = mulAndCheck(numerator, fraction.denominator);
            int upv = mulAndCheck(fraction.numerator, denominator);
            return new Fraction
                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),
                 mulPosAndCheck(denominator, fraction.denominator));
        }
// the quantity 't' requires 65 bits of precision; see knuth 4.5.1
// exercise 7.  we're going to use a BigInteger.
// t = u(v'/d1) +/- v(u'/d1)
BigInteger uvp = BigInteger.valueOf(numerator)
            .multiply(BigInteger.valueOf(fraction.denominator/d1));
BigInteger upv = BigInteger.valueOf(fraction.numerator)
            .multiply(BigInteger.valueOf(denominator/d1));
BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);
// but d2 doesn't need extra precision because
// d2 = gcd(t,d1) = gcd(t mod d1, d1)
int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();
int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);
empty line
// result is (t/d2) / (u'/d1)(v'/d2)
BigInteger w = t.divide(BigInteger.valueOf(d2));
if (w.bitLength() > 31) {
            throw new ArithmeticException
                ("overflow: numerator too large after multiply");
        }
return new Fraction
            (w.intValue(),
             mulPosAndCheck(denominator/d1, fraction.denominator/d2));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.math.Fraction <741, 783>
if (Number == null) {
            throw new IllegalArgumentException("The fraction must not be null");
        }
// zero is identity for addition.
if (intVar == 0) {
            return booleanVar ? Number : Number.negate();
        }
if (Number.intVar == 0) {
            return this;
        }
// if denominators are randomly distributed, d1 will be 1 about 61%
// of the time.
int intVar = greatestCommonDivisor(intVar, Number.intVar);
if (intVar==1) {
            // result is ( (u*v' +/- u'v) / u'v')
            int uvp = mulAndCheck(intVar, Number.intVar);
            int upv = mulAndCheck(Number.intVar, intVar);
            return new Fraction
                (booleanVar ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),
                 mulPosAndCheck(intVar, Number.intVar));
        }
// the quantity 't' requires 65 bits of precision; see knuth 4.5.1
// exercise 7.  we're going to use a BigInteger.
// t = u(v'/d1) +/- v(u'/d1)
BigInteger BigInteger = BigInteger.valueOf(intVar)
            .multiply(BigInteger.valueOf(Number.intVar/intVar));
BigInteger BigInteger = BigInteger.valueOf(Number.intVar)
            .multiply(BigInteger.valueOf(intVar/intVar));
BigInteger BigInteger = booleanVar ? BigInteger.add(BigInteger) : BigInteger.subtract(BigInteger);
// but d2 doesn't need extra precision because
// d2 = gcd(t,d1) = gcd(t mod d1, d1)
int intVar = BigInteger.mod(BigInteger.valueOf(intVar)).intValue();
int intVar = (intVar==0)?intVar:greatestCommonDivisor(intVar, intVar);
empty line
// result is (t/d2) / (u'/d1)(v'/d2)
BigInteger BigInteger = BigInteger.divide(BigInteger.valueOf(intVar));
if (BigInteger.bitLength() > 31) {
            throw new ArithmeticException
                ("overflow: numerator too large after multiply");
        }
return new Fraction
            (BigInteger.intValue(),
             mulPosAndCheck(intVar/intVar, Number.intVar/intVar));

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.math.Fraction <741, 783>
if (null == null) {
            throw new IllegalArgumentException("The fraction must not be null");
        }
// zero is identity for addition.
if (numerator == 0) {
            return isAdd ? null : null.negate();
        }
if (Number.numerator == 0) {
            return this;
        }
// if denominators are randomly distributed, d1 will be 1 about 61%
// of the time.
int d1 = greatestCommonDivisor(denominator, Number.denominator);
if (d1==1) {
            // result is ( (u*v' +/- u'v) / u'v')
            int uvp = mulAndCheck(numerator, Number.denominator);
            int upv = mulAndCheck(Number.numerator, denominator);
            return new Fraction
                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),
                 mulPosAndCheck(denominator, Number.denominator));
        }
// the quantity 't' requires 65 bits of precision; see knuth 4.5.1
// exercise 7.  we're going to use a BigInteger.
// t = u(v'/d1) +/- v(u'/d1)
BigInteger BigInteger = BigInteger.valueOf(numerator)
            .multiply(BigInteger.valueOf(Number.denominator/d1));
BigInteger BigInteger = BigInteger.valueOf(Number.numerator)
            .multiply(BigInteger.valueOf(denominator/d1));
BigInteger BigInteger = isAdd ? BigInteger.add(BigInteger) : BigInteger.subtract(BigInteger);
// but d2 doesn't need extra precision because
// d2 = gcd(t,d1) = gcd(t mod d1, d1)
int tmodd1 = BigInteger.mod(BigInteger.valueOf(d1)).intValue();
int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);
empty line
// result is (t/d2) / (u'/d1)(v'/d2)
BigInteger BigInteger = BigInteger.divide(BigInteger.valueOf(d2));
if (BigInteger.bitLength() > 31) {
            throw new ArithmeticException
                ("overflow: numerator too large after multiply");
        }
return new Fraction
            (BigInteger.intValue(),
             mulPosAndCheck(denominator/d1, Number.denominator/d2));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.math.Fraction <741, 783>
if (fraction == null) {
            throw new IllegalArgumentException("The fraction must not be null");
        }
// zero is identity for addition.
if (numerator == 0) {
            return isAdd ? fraction : fraction.negate();
        }
if (fraction.numerator == 0) {
            return this;
        }
// if denominators are randomly distributed, d1 will be 1 about 61%
// of the time.
int d1 = greatestCommonDivisor(denominator, fraction.denominator);
if (d1==1) {
            // result is ( (u*v' +/- u'v) / u'v')
            int uvp = mulAndCheck(numerator, fraction.denominator);
            int upv = mulAndCheck(fraction.numerator, denominator);
            return new Fraction
                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),
                 mulPosAndCheck(denominator, fraction.denominator));
        }
// the quantity 't' requires 65 bits of precision; see knuth 4.5.1
// exercise 7.  we're going to use a BigInteger.
// t = u(v'/d1) +/- v(u'/d1)
BigInteger uvp = BigInteger.valueOf(numerator)
            .multiply(BigInteger.valueOf(fraction.denominator/d1));
BigInteger upv = BigInteger.valueOf(fraction.numerator)
            .multiply(BigInteger.valueOf(denominator/d1));
BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);
// but d2 doesn't need extra precision because
// d2 = gcd(t,d1) = gcd(t mod d1, d1)
int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();
int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);
empty line
// result is (t/d2) / (u'/d1)(v'/d2)
BigInteger w = t.divide(BigInteger.valueOf(d2));
if (w.bitLength() > 31) {
            throw new ArithmeticException
                ("overflow: numerator too large after multiply");
        }
return new Fraction
            (w.intValue(),
             mulPosAndCheck(denominator/d1, fraction.denominator/d2));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.math.Fraction <741, 783>
if (Number == null) {
            throw new IllegalArgumentException("The fraction must not be null");
        }
// zero is identity for addition.
if (intVar == 0) {
            return booleanVar ? Number : Number.negate();
        }
if (Number.intVar == 0) {
            return this;
        }
// if denominators are randomly distributed, d1 will be 1 about 61%
// of the time.
int intVar = greatestCommonDivisor(intVar, Number.intVar);
if (intVar==1) {
            // result is ( (u*v' +/- u'v) / u'v')
            int uvp = mulAndCheck(intVar, Number.intVar);
            int upv = mulAndCheck(Number.intVar, intVar);
            return new Fraction
                (booleanVar ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),
                 mulPosAndCheck(intVar, Number.intVar));
        }
// the quantity 't' requires 65 bits of precision; see knuth 4.5.1
// exercise 7.  we're going to use a BigInteger.
// t = u(v'/d1) +/- v(u'/d1)
BigInteger BigInteger = BigInteger.valueOf(intVar)
            .multiply(BigInteger.valueOf(Number.intVar/intVar));
BigInteger BigInteger = BigInteger.valueOf(Number.intVar)
            .multiply(BigInteger.valueOf(intVar/intVar));
BigInteger BigInteger = booleanVar ? BigInteger.add(BigInteger) : BigInteger.subtract(BigInteger);
// but d2 doesn't need extra precision because
// d2 = gcd(t,d1) = gcd(t mod d1, d1)
int intVar = BigInteger.mod(BigInteger.valueOf(intVar)).intValue();
int intVar = (intVar==0)?intVar:greatestCommonDivisor(intVar, intVar);
empty line
// result is (t/d2) / (u'/d1)(v'/d2)
BigInteger BigInteger = BigInteger.divide(BigInteger.valueOf(intVar));
if (BigInteger.bitLength() > 31) {
            throw new ArithmeticException
                ("overflow: numerator too large after multiply");
        }
return new Fraction
            (BigInteger.intValue(),
             mulPosAndCheck(intVar/intVar, Number.intVar/intVar));

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.math.Fraction <741, 783>
if (null == null) {
            throw new IllegalArgumentException("The fraction must not be null");
        }
// zero is identity for addition.
if (numerator == 0) {
            return isAdd ? null : null.negate();
        }
if (Number.numerator == 0) {
            return this;
        }
// if denominators are randomly distributed, d1 will be 1 about 61%
// of the time.
int d1 = greatestCommonDivisor(denominator, Number.denominator);
if (d1==1) {
            // result is ( (u*v' +/- u'v) / u'v')
            int uvp = mulAndCheck(numerator, Number.denominator);
            int upv = mulAndCheck(Number.numerator, denominator);
            return new Fraction
                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),
                 mulPosAndCheck(denominator, Number.denominator));
        }
// the quantity 't' requires 65 bits of precision; see knuth 4.5.1
// exercise 7.  we're going to use a BigInteger.
// t = u(v'/d1) +/- v(u'/d1)
BigInteger BigInteger = BigInteger.valueOf(numerator)
            .multiply(BigInteger.valueOf(Number.denominator/d1));
BigInteger BigInteger = BigInteger.valueOf(Number.numerator)
            .multiply(BigInteger.valueOf(denominator/d1));
BigInteger BigInteger = isAdd ? BigInteger.add(BigInteger) : BigInteger.subtract(BigInteger);
// but d2 doesn't need extra precision because
// d2 = gcd(t,d1) = gcd(t mod d1, d1)
int tmodd1 = BigInteger.mod(BigInteger.valueOf(d1)).intValue();
int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);
empty line
// result is (t/d2) / (u'/d1)(v'/d2)
BigInteger BigInteger = BigInteger.divide(BigInteger.valueOf(d2));
if (BigInteger.bitLength() > 31) {
            throw new ArithmeticException
                ("overflow: numerator too large after multiply");
        }
return new Fraction
            (BigInteger.intValue(),
             mulPosAndCheck(denominator/d1, Number.denominator/d2));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.math.Fraction <741, 783>
if (fraction == null) {
            throw new IllegalArgumentException("The fraction must not be null");
        }
// zero is identity for addition.
if (numerator == 0) {
            return isAdd ? fraction : fraction.negate();
        }
if (fraction.numerator == 0) {
            return this;
        }
// if denominators are randomly distributed, d1 will be 1 about 61%
// of the time.
int d1 = greatestCommonDivisor(denominator, fraction.denominator);
if (d1==1) {
            // result is ( (u*v' +/- u'v) / u'v')
            int uvp = mulAndCheck(numerator, fraction.denominator);
            int upv = mulAndCheck(fraction.numerator, denominator);
            return new Fraction
                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),
                 mulPosAndCheck(denominator, fraction.denominator));
        }
// the quantity 't' requires 65 bits of precision; see knuth 4.5.1
// exercise 7.  we're going to use a BigInteger.
// t = u(v'/d1) +/- v(u'/d1)
BigInteger uvp = BigInteger.valueOf(numerator)
            .multiply(BigInteger.valueOf(fraction.denominator/d1));
BigInteger upv = BigInteger.valueOf(fraction.numerator)
            .multiply(BigInteger.valueOf(denominator/d1));
BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);
// but d2 doesn't need extra precision because
// d2 = gcd(t,d1) = gcd(t mod d1, d1)
int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();
int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);
empty line
// result is (t/d2) / (u'/d1)(v'/d2)
BigInteger w = t.divide(BigInteger.valueOf(d2));
if (w.bitLength() > 31) {
            throw new ArithmeticException
                ("overflow: numerator too large after multiply");
        }
return new Fraction
            (w.intValue(),
             mulPosAndCheck(denominator/d1, fraction.denominator/d2));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.math.Fraction <741, 783>
if (Number == null) {
            throw new IllegalArgumentException("The fraction must not be null");
        }
// zero is identity for addition.
if (intVar == 0) {
            return booleanVar ? Number : Number.negate();
        }
if (Number.intVar == 0) {
            return this;
        }
// if denominators are randomly distributed, d1 will be 1 about 61%
// of the time.
int intVar = greatestCommonDivisor(intVar, Number.intVar);
if (intVar==1) {
            // result is ( (u*v' +/- u'v) / u'v')
            int uvp = mulAndCheck(intVar, Number.intVar);
            int upv = mulAndCheck(Number.intVar, intVar);
            return new Fraction
                (booleanVar ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),
                 mulPosAndCheck(intVar, Number.intVar));
        }
// the quantity 't' requires 65 bits of precision; see knuth 4.5.1
// exercise 7.  we're going to use a BigInteger.
// t = u(v'/d1) +/- v(u'/d1)
BigInteger BigInteger = BigInteger.valueOf(intVar)
            .multiply(BigInteger.valueOf(Number.intVar/intVar));
BigInteger BigInteger = BigInteger.valueOf(Number.intVar)
            .multiply(BigInteger.valueOf(intVar/intVar));
BigInteger BigInteger = booleanVar ? BigInteger.add(BigInteger) : BigInteger.subtract(BigInteger);
// but d2 doesn't need extra precision because
// d2 = gcd(t,d1) = gcd(t mod d1, d1)
int intVar = BigInteger.mod(BigInteger.valueOf(intVar)).intValue();
int intVar = (intVar==0)?intVar:greatestCommonDivisor(intVar, intVar);
empty line
// result is (t/d2) / (u'/d1)(v'/d2)
BigInteger BigInteger = BigInteger.divide(BigInteger.valueOf(intVar));
if (BigInteger.bitLength() > 31) {
            throw new ArithmeticException
                ("overflow: numerator too large after multiply");
        }
return new Fraction
            (BigInteger.intValue(),
             mulPosAndCheck(intVar/intVar, Number.intVar/intVar));

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.math.Fraction <741, 783>
if (null == null) {
            throw new IllegalArgumentException("The fraction must not be null");
        }
// zero is identity for addition.
if (numerator == 0) {
            return isAdd ? null : null.negate();
        }
if (Number.numerator == 0) {
            return this;
        }
// if denominators are randomly distributed, d1 will be 1 about 61%
// of the time.
int d1 = greatestCommonDivisor(denominator, Number.denominator);
if (d1==1) {
            // result is ( (u*v' +/- u'v) / u'v')
            int uvp = mulAndCheck(numerator, Number.denominator);
            int upv = mulAndCheck(Number.numerator, denominator);
            return new Fraction
                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),
                 mulPosAndCheck(denominator, Number.denominator));
        }
// the quantity 't' requires 65 bits of precision; see knuth 4.5.1
// exercise 7.  we're going to use a BigInteger.
// t = u(v'/d1) +/- v(u'/d1)
BigInteger BigInteger = BigInteger.valueOf(numerator)
            .multiply(BigInteger.valueOf(Number.denominator/d1));
BigInteger BigInteger = BigInteger.valueOf(Number.numerator)
            .multiply(BigInteger.valueOf(denominator/d1));
BigInteger BigInteger = isAdd ? BigInteger.add(BigInteger) : BigInteger.subtract(BigInteger);
// but d2 doesn't need extra precision because
// d2 = gcd(t,d1) = gcd(t mod d1, d1)
int tmodd1 = BigInteger.mod(BigInteger.valueOf(d1)).intValue();
int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);
empty line
// result is (t/d2) / (u'/d1)(v'/d2)
BigInteger BigInteger = BigInteger.divide(BigInteger.valueOf(d2));
if (BigInteger.bitLength() > 31) {
            throw new ArithmeticException
                ("overflow: numerator too large after multiply");
        }
return new Fraction
            (BigInteger.intValue(),
             mulPosAndCheck(denominator/d1, Number.denominator/d2));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.math.Fraction <741, 783>
if (fraction == null) {
            throw new IllegalArgumentException("The fraction must not be null");
        }
// zero is identity for addition.
if (numerator == 0) {
            return isAdd ? fraction : fraction.negate();
        }
if (fraction.numerator == 0) {
            return this;
        }
// if denominators are randomly distributed, d1 will be 1 about 61%
// of the time.
int d1 = greatestCommonDivisor(denominator, fraction.denominator);
if (d1==1) {
            // result is ( (u*v' +/- u'v) / u'v')
            int uvp = mulAndCheck(numerator, fraction.denominator);
            int upv = mulAndCheck(fraction.numerator, denominator);
            return new Fraction
                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),
                 mulPosAndCheck(denominator, fraction.denominator));
        }
// the quantity 't' requires 65 bits of precision; see knuth 4.5.1
// exercise 7.  we're going to use a BigInteger.
// t = u(v'/d1) +/- v(u'/d1)
BigInteger uvp = BigInteger.valueOf(numerator)
            .multiply(BigInteger.valueOf(fraction.denominator/d1));
BigInteger upv = BigInteger.valueOf(fraction.numerator)
            .multiply(BigInteger.valueOf(denominator/d1));
BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);
// but d2 doesn't need extra precision because
// d2 = gcd(t,d1) = gcd(t mod d1, d1)
int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();
int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);
empty line
// result is (t/d2) / (u'/d1)(v'/d2)
BigInteger w = t.divide(BigInteger.valueOf(d2));
if (w.bitLength() > 31) {
            throw new ArithmeticException
                ("overflow: numerator too large after multiply");
        }
return new Fraction
            (w.intValue(),
             mulPosAndCheck(denominator/d1, fraction.denominator/d2));

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.math.Fraction <741, 783>
if (Number == null) {
            throw new IllegalArgumentException("The fraction must not be null");
        }
// zero is identity for addition.
if (intVar == 0) {
            return booleanVar ? Number : Number.negate();
        }
if (Number.intVar == 0) {
            return this;
        }
// if denominators are randomly distributed, d1 will be 1 about 61%
// of the time.
int intVar = greatestCommonDivisor(intVar, Number.intVar);
if (intVar==1) {
            // result is ( (u*v' +/- u'v) / u'v')
            int uvp = mulAndCheck(intVar, Number.intVar);
            int upv = mulAndCheck(Number.intVar, intVar);
            return new Fraction
                (booleanVar ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),
                 mulPosAndCheck(intVar, Number.intVar));
        }
// the quantity 't' requires 65 bits of precision; see knuth 4.5.1
// exercise 7.  we're going to use a BigInteger.
// t = u(v'/d1) +/- v(u'/d1)
BigInteger BigInteger = BigInteger.valueOf(intVar)
            .multiply(BigInteger.valueOf(Number.intVar/intVar));
BigInteger BigInteger = BigInteger.valueOf(Number.intVar)
            .multiply(BigInteger.valueOf(intVar/intVar));
BigInteger BigInteger = booleanVar ? BigInteger.add(BigInteger) : BigInteger.subtract(BigInteger);
// but d2 doesn't need extra precision because
// d2 = gcd(t,d1) = gcd(t mod d1, d1)
int intVar = BigInteger.mod(BigInteger.valueOf(intVar)).intValue();
int intVar = (intVar==0)?intVar:greatestCommonDivisor(intVar, intVar);
empty line
// result is (t/d2) / (u'/d1)(v'/d2)
BigInteger BigInteger = BigInteger.divide(BigInteger.valueOf(intVar));
if (BigInteger.bitLength() > 31) {
            throw new ArithmeticException
                ("overflow: numerator too large after multiply");
        }
return new Fraction
            (BigInteger.intValue(),
             mulPosAndCheck(intVar/intVar, Number.intVar/intVar));

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.math.Fraction <741, 783>
if (null == null) {
            throw new IllegalArgumentException("The fraction must not be null");
        }
// zero is identity for addition.
if (numerator == 0) {
            return isAdd ? null : null.negate();
        }
if (Number.numerator == 0) {
            return this;
        }
// if denominators are randomly distributed, d1 will be 1 about 61%
// of the time.
int d1 = greatestCommonDivisor(denominator, Number.denominator);
if (d1==1) {
            // result is ( (u*v' +/- u'v) / u'v')
            int uvp = mulAndCheck(numerator, Number.denominator);
            int upv = mulAndCheck(Number.numerator, denominator);
            return new Fraction
                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),
                 mulPosAndCheck(denominator, Number.denominator));
        }
// the quantity 't' requires 65 bits of precision; see knuth 4.5.1
// exercise 7.  we're going to use a BigInteger.
// t = u(v'/d1) +/- v(u'/d1)
BigInteger BigInteger = BigInteger.valueOf(numerator)
            .multiply(BigInteger.valueOf(Number.denominator/d1));
BigInteger BigInteger = BigInteger.valueOf(Number.numerator)
            .multiply(BigInteger.valueOf(denominator/d1));
BigInteger BigInteger = isAdd ? BigInteger.add(BigInteger) : BigInteger.subtract(BigInteger);
// but d2 doesn't need extra precision because
// d2 = gcd(t,d1) = gcd(t mod d1, d1)
int tmodd1 = BigInteger.mod(BigInteger.valueOf(d1)).intValue();
int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);
empty line
// result is (t/d2) / (u'/d1)(v'/d2)
BigInteger BigInteger = BigInteger.divide(BigInteger.valueOf(d2));
if (BigInteger.bitLength() > 31) {
            throw new ArithmeticException
                ("overflow: numerator too large after multiply");
        }
return new Fraction
            (BigInteger.intValue(),
             mulPosAndCheck(denominator/d1, Number.denominator/d2));

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.BooleanUtils <606, 620>
case 5:
char ch0 = str.charAt(0);
char ch1 = str.charAt(1);
char ch2 = str.charAt(2);
char ch3 = str.charAt(3);
char ch4 = str.charAt(4);
if ((ch0 == 'f' || ch0 == 'F') &&
                    (ch1 == 'a' || ch1 == 'A') &&
                    (ch2 == 'l' || ch2 == 'L') &&
                    (ch3 == 's' || ch3 == 'S') &&
                    (ch4 == 'e' || ch4 == 'E') ) {
                    return Boolean.FALSE;
                }
break;
}

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.BooleanUtils <606, 620>
case 5:
char charVar = StringVar.charAt(0);
char charVar = StringVar.charAt(1);
char charVar = StringVar.charAt(2);
char charVar = StringVar.charAt(3);
char charVar = StringVar.charAt(4);
if ((charVar == 'f' || charVar == 'F') &&
                    (charVar == 'a' || charVar == 'A') &&
                    (charVar == 'l' || charVar == 'L') &&
                    (charVar == 's' || charVar == 'S') &&
                    (charVar == 'e' || charVar == 'E') ) {
                    return Boolean.FALSE;
                }
break;
}

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.BooleanUtils <606, 620>
case 5:
char ch0 = str.charAt(0);
char ch1 = str.charAt(1);
char ch2 = str.charAt(2);
char ch3 = str.charAt(3);
char ch4 = str.charAt(4);
if ((ch0 == 'f' || ch0 == 'F') &&
                    (ch1 == 'a' || ch1 == 'A') &&
                    (ch2 == 'l' || ch2 == 'L') &&
                    (ch3 == 's' || ch3 == 'S') &&
                    (ch4 == 'e' || ch4 == 'E') ) {
                    return Boolean.FALSE;
                }
break;
}

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.AnnotationUtils <138, 145>
if (m.getParameterTypes().length == 0
                        && isValidAnnotationMemberType(m.getReturnType())) {
                    Object v1 = m.invoke(a1);
                    Object v2 = m.invoke(a2);
                    if (!memberEquals(m.getReturnType(), v1, v2)) {
                        return false;
                    }
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.AnnotationUtils <138, 145>
if (Method.getParameterTypes().length == 0
                        && isValidAnnotationMemberType(Method.getReturnType())) {
                    Object v1 = Method.invoke(Annotation);
                    Object v2 = Method.invoke(Annotation);
                    if (!memberEquals(Method.getReturnType(), v1, v2)) {
                        return false;
                    }
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.AnnotationUtils <138, 145>
if (Method.getParameterTypes().length == 0
                        && isValidAnnotationMemberType(Method.getReturnType())) {
                    Object v1 = Method.invoke(Annotation);
                    Object v2 = Method.invoke(Annotation);
                    if (!memberEquals(Method.getReturnType(), v1, v2)) {
                        return false;
                    }
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.Validate <569, 577>
Validate.notNull(iterable);
int i = 0;
for (Iterator<?> it = iterable.iterator(); it.hasNext(); i++) {
            if (it.next() == null) {
                Object[] values2 = ArrayUtils.addAll(values, Integer.valueOf(i));
                throw new IllegalArgumentException(String.format(message, values2));
            }
        }
return iterable;

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.Validate <569, 577>
Validate.notNull(TVar);
int intVar = 0;
for (Iterator<?> Iterator = TVar.iterator(); Iterator.hasNext(); intVar++) {
            if (Iterator.next() == null) {
                Object[] values2 = ArrayUtils.addAll(Object, Integer.valueOf(intVar));
                throw new IllegalArgumentException(String.format(StringVar, values2));
            }
        }
return TVar;

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.Validate <569, 577>
Validate.notNull(iterable);
int i = 0;
for (Iterator<?> Iterator = iterable.iterator(); Iterator.hasNext(); i++) {
            if (Iterator.next() == null) {
                Object[] values2 = ArrayUtils.addAll(Object, Integer.valueOf(i));
                throw new IllegalArgumentException(String.format(message, values2));
            }
        }
return iterable;

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.builder.CompareToBuilder <440, 448>
if (comparator == null) {
                @SuppressWarnings("unchecked") // assume this can be done; if not throw CCE as per Javadoc
                final Comparable<Object> comparable = (Comparable<Object>) lhs;
                comparison = comparable.compareTo(rhs);
            } else {
                @SuppressWarnings("unchecked") // assume this can be done; if not throw CCE as per Javadoc
                final Comparator<Object> comparator2 = (Comparator<Object>) comparator;
                comparison = comparator2.compare(lhs, rhs);
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.builder.CompareToBuilder <440, 448>
if (Comparator == null) {
                @SuppressWarnings("unchecked") // assume this can be done; if not throw CCE as per Javadoc
                final Comparable<Object> comparable = (Comparable<Object>) Object;
                intVar = comparable.compareTo(Object);
            } else {
                @SuppressWarnings("unchecked") // assume this can be done; if not throw CCE as per Javadoc
                final Comparator<Object> comparator2 = (Comparator<Object>) Comparator;
                intVar = comparator2.compare(Object, Object);
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.builder.CompareToBuilder <440, 448>
if (Comparator == null) {
                @SuppressWarnings("unchecked") // assume this can be done; if not throw CCE as per Javadoc
                final Comparable<Object> comparable = (Comparable<Object>) Object;
                comparison = comparable.compareTo(Object);
            } else {
                @SuppressWarnings("unchecked") // assume this can be done; if not throw CCE as per Javadoc
                final Comparator<Object> comparator2 = (Comparator<Object>) Comparator;
                comparison = comparator2.compare(Object, Object);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.reflect.MemberUtils <137, 145>
if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) {
                // slight penalty for interface match.
                // we still want an exact match to override an interface match,
                // but
                // an interface match should override anything where we have to
                // get a superclass.
                cost += 0.25f;
                break;
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.reflect.MemberUtils <137, 145>
if (Class.isInterface() && ClassUtils.isAssignable(Class, Class)) {
                // slight penalty for interface match.
                // we still want an exact match to override an interface match,
                // but
                // an interface match should override anything where we have to
                // get a superclass.
                floatVar += 0.25f;
                break;
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.reflect.MemberUtils <137, 145>
if (Class.isInterface() && ClassUtils.isAssignable(Class, Class)) {
                // slight penalty for interface match.
                // we still want an exact match to override an interface match,
                // but
                // an interface match should override anything where we have to
                // get a superclass.
                cost += 0.25f;
                break;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.time.DateUtils <332, 334>
if (date != null && pos.getIndex() == str2.length()) {
                return date;
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.time.DateUtils <332, 334>
if (Date != null && ParsePosition.getIndex() == str2.length()) {
                return Date;
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.AnnotationUtils <264, 276>
if (o1 == o2) {
            return true;
        }
if (o1 == null || o2 == null) {
            return false;
        }
if (type.isArray()) {
            return arrayMemberEquals(type.getComponentType(), o1, o2);
        }
if (type.isAnnotation()) {
            return equals((Annotation) o1, (Annotation) o2);
        }
return o1.equals(o2);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.AnnotationUtils <264, 276>
if (o1 == o2) {
            return true;
        }
if (o1 == null || o2 == null) {
            return false;
        }
if (type.isArray()) {
            return arrayMemberEquals(type.getComponentType(), o1, o2);
        }
if (type.isAnnotation()) {
            return equals((Annotation) o1, (Annotation) o2);
        }
return o1.equals(o2);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.AnnotationUtils <264, 276>
if (o1 == o2) {
            return true;
        }
if (o1 == null || o2 == null) {
            return false;
        }
if (type.isArray()) {
            return arrayMemberEquals(type.getComponentType(), o1, o2);
        }
if (type.isAnnotation()) {
            return equals((Annotation) o1, (Annotation) o2);
        }
return o1.equals(o2);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.math.Fraction <578, 583>
if ((u == 0) || (v == 0)) {
            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
                throw new ArithmeticException("overflow: gcd is 2^31");
            }
            return Math.abs(u) + Math.abs(v);
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.math.Fraction <578, 583>
if ((intVar == 0) || (intVar == 0)) {
            if ((intVar == Integer.MIN_VALUE) || (intVar == Integer.MIN_VALUE)) {
                throw new ArithmeticException("overflow: gcd is 2^31");
            }
            return Math.abs(intVar) + Math.abs(intVar);
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.math.Fraction <578, 583>
if ((u == 0) || (v == 0)) {
            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
                throw new ArithmeticException("overflow: gcd is 2^31");
            }
            return Math.abs(u) + Math.abs(v);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.time.DateUtils <1023, 1030>
if (!offsetSet) {
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                //Calculate the offset from the minimum allowed value
                offset = val.get(fields[i][0]) - min;
                //Set roundUp if this is more than half way between the minimum and maximum
                roundUp = offset > ((max - min) / 2);
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.time.DateUtils <1023, 1030>
if (!booleanVar) {
                int min = Calendar.getActualMinimum(int[][]Var[intVar][0]);
                int max = Calendar.getActualMaximum(int[][]Var[intVar][0]);
                //Calculate the offset from the minimum allowed value
                intVar = Calendar.get(int[][]Var[intVar][0]) - min;
                //Set roundUp if this is more than half way between the minimum and maximum
                booleanVar = intVar > ((max - min) / 2);
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.time.DateUtils <1023, 1030>
if (!offsetSet) {
                int min = Calendar.getActualMinimum(fields[i][0]);
                int max = Calendar.getActualMaximum(fields[i][0]);
                //Calculate the offset from the minimum allowed value
                offset = Calendar.get(fields[i][0]) - min;
                //Set roundUp if this is more than half way between the minimum and maximum
                roundUp = offset > ((max - min) / 2);
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.AnnotationUtils <291, 293>
if (componentType.equals(Byte.TYPE)) {
            return Arrays.equals((byte[]) o1, (byte[]) o2);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.AnnotationUtils <294, 296>
if (componentType.equals(Short.TYPE)) {
            return Arrays.equals((short[]) o1, (short[]) o2);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.AnnotationUtils <297, 299>
if (componentType.equals(Integer.TYPE)) {
            return Arrays.equals((int[]) o1, (int[]) o2);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.AnnotationUtils <300, 302>
if (componentType.equals(Character.TYPE)) {
            return Arrays.equals((char[]) o1, (char[]) o2);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.AnnotationUtils <303, 305>
if (componentType.equals(Long.TYPE)) {
            return Arrays.equals((long[]) o1, (long[]) o2);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.AnnotationUtils <306, 308>
if (componentType.equals(Float.TYPE)) {
            return Arrays.equals((float[]) o1, (float[]) o2);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.AnnotationUtils <309, 311>
if (componentType.equals(Double.TYPE)) {
            return Arrays.equals((double[]) o1, (double[]) o2);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.AnnotationUtils <312, 314>
if (componentType.equals(Boolean.TYPE)) {
            return Arrays.equals((boolean[]) o1, (boolean[]) o2);
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <5821, 5831>
if (str1 == null) {
            return str2;
        }
if (str2 == null) {
            return str1;
        }
int at = indexOfDifference(str1, str2);
if (at == INDEX_NOT_FOUND) {
            return EMPTY;
        }
return str2.substring(at);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <5821, 5831>
if (str1 == null) {
            return str2;
        }
if (str2 == null) {
            return str1;
        }
int at = indexOfDifference(str1, str2);
if (at == INDEX_NOT_FOUND) {
            return EMPTY;
        }
return str2.substring(at);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <5821, 5831>
if (str1 == null) {
            return str2;
        }
if (str2 == null) {
            return str1;
        }
int at = indexOfDifference(str1, str2);
if (at == INDEX_NOT_FOUND) {
            return EMPTY;
        }
return str2.substring(at);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <5821, 5831>
if (str1 == null) {
            return str2;
        }
if (str2 == null) {
            return str1;
        }
int at = indexOfDifference(str1, str2);
if (at == INDEX_NOT_FOUND) {
            return EMPTY;
        }
return str2.substring(at);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <5821, 5831>
if (str1 == null) {
            return str2;
        }
if (str2 == null) {
            return str1;
        }
int at = indexOfDifference(str1, str2);
if (at == INDEX_NOT_FOUND) {
            return EMPTY;
        }
return str2.substring(at);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.StringUtils <5821, 5831>
if (str1 == null) {
            return str2;
        }
if (str2 == null) {
            return str1;
        }
int at = indexOfDifference(str1, str2);
if (at == INDEX_NOT_FOUND) {
            return EMPTY;
        }
return str2.substring(at);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.time.DurationFormatUtils <379, 382>
if (!Token.containsTokenWithValue(tokens, d)) {
            hours += 24 * days;
            days = 0;
        }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.time.DurationFormatUtils <379, 382>
if (!Token.containsTokenWithValue(Token[]Var, Object)) {
            intVar += 24 * intVar;
            intVar = 0;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.time.DurationFormatUtils <379, 382>
if (!Token.containsTokenWithValue(tokens, Object)) {
            hours += 24 * days;
            days = 0;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.StringUtils <5872, 5874>
if (i < cs2.length() || i < cs1.length()) {
            return i;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.AnnotationUtils <326, 328>
if (a1.length != a2.length) {
            return false;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.AnnotationUtils <326, 328>
if (a1.length != a2.length) {
            return false;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.AnnotationUtils <288, 315>
if (componentType.isAnnotation()) {
            return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);
        }
if (componentType.equals(Byte.TYPE)) {
            return Arrays.equals((byte[]) o1, (byte[]) o2);
        }
if (componentType.equals(Short.TYPE)) {
            return Arrays.equals((short[]) o1, (short[]) o2);
        }
if (componentType.equals(Integer.TYPE)) {
            return Arrays.equals((int[]) o1, (int[]) o2);
        }
if (componentType.equals(Character.TYPE)) {
            return Arrays.equals((char[]) o1, (char[]) o2);
        }
if (componentType.equals(Long.TYPE)) {
            return Arrays.equals((long[]) o1, (long[]) o2);
        }
if (componentType.equals(Float.TYPE)) {
            return Arrays.equals((float[]) o1, (float[]) o2);
        }
if (componentType.equals(Double.TYPE)) {
            return Arrays.equals((double[]) o1, (double[]) o2);
        }
if (componentType.equals(Boolean.TYPE)) {
            return Arrays.equals((boolean[]) o1, (boolean[]) o2);
        }
return Arrays.equals((Object[]) o1, (Object[]) o2);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.time.DateUtils <955, 987>
if (fields[i][j] == field) {
                    //This is our field... we stop looping
                    if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) {
                        if (field == DateUtils.SEMI_MONTH) {
                            //This is a special case that's hard to generalize
                            //If the date is 1, we round up to 16, otherwise
                            //  we subtract 15 days and add 1 month
                            if (val.get(Calendar.DATE) == 1) {
                                val.add(Calendar.DATE, 15);
                            } else {
                                val.add(Calendar.DATE, -15);
                                val.add(Calendar.MONTH, 1);
                            }
// ----------------- Fix for LANG-440 ---------------------- START ---------------
                        } else if (field == Calendar.AM_PM) {
                            // This is a special case
                            // If the time is 0, we round up to 12, otherwise
                            //  we subtract 12 hours and add 1 day
                            if (val.get(Calendar.HOUR_OF_DAY) == 0) {
                                val.add(Calendar.HOUR_OF_DAY, 12);
                            } else {
                                val.add(Calendar.HOUR_OF_DAY, -12);
                                val.add(Calendar.DATE, 1);
                            }
// ----------------- Fix for LANG-440 ---------------------- END ---------------
                        } else {
                            //We need at add one to this field since the
                            //  last number causes us to round up
                            val.add(fields[i][0], 1);
                        }
                    }
                    return;
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.time.DateUtils <955, 987>
if (int[][]Var[intVar][intVar] == intVar) {
                    //This is our field... we stop looping
                    if (intVar == intVar || (intVar == intVar && booleanVar)) {
                        if (intVar == DateUtils.intVar) {
                            //This is a special case that's hard to generalize
                            //If the date is 1, we round up to 16, otherwise
                            //  we subtract 15 days and add 1 month
                            if (Calendar.get(Calendar.DATE) == 1) {
                                Calendar.add(Calendar.DATE, 15);
                            } else {
                                Calendar.add(Calendar.DATE, -15);
                                Calendar.add(Calendar.MONTH, 1);
                            }
// ----------------- Fix for LANG-440 ---------------------- START ---------------
                        } else if (intVar == Calendar.AM_PM) {
                            // This is a special case
                            // If the time is 0, we round up to 12, otherwise
                            //  we subtract 12 hours and add 1 day
                            if (Calendar.get(Calendar.HOUR_OF_DAY) == 0) {
                                Calendar.add(Calendar.HOUR_OF_DAY, 12);
                            } else {
                                Calendar.add(Calendar.HOUR_OF_DAY, -12);
                                Calendar.add(Calendar.DATE, 1);
                            }
// ----------------- Fix for LANG-440 ---------------------- END ---------------
                        } else {
                            //We need at add one to this field since the
                            //  last number causes us to round up
                            Calendar.add(int[][]Var[intVar][0], 1);
                        }
                    }
                    return;
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.time.DateUtils <955, 987>
if (fields[i][j] == field) {
                    //This is our field... we stop looping
                    if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) {
                        if (field == DateUtils.SEMI_MONTH) {
                            //This is a special case that's hard to generalize
                            //If the date is 1, we round up to 16, otherwise
                            //  we subtract 15 days and add 1 month
                            if (Calendar.get(Calendar.DATE) == 1) {
                                Calendar.add(Calendar.DATE, 15);
                            } else {
                                Calendar.add(Calendar.DATE, -15);
                                Calendar.add(Calendar.MONTH, 1);
                            }
// ----------------- Fix for LANG-440 ---------------------- START ---------------
                        } else if (field == Calendar.AM_PM) {
                            // This is a special case
                            // If the time is 0, we round up to 12, otherwise
                            //  we subtract 12 hours and add 1 day
                            if (Calendar.get(Calendar.HOUR_OF_DAY) == 0) {
                                Calendar.add(Calendar.HOUR_OF_DAY, 12);
                            } else {
                                Calendar.add(Calendar.HOUR_OF_DAY, -12);
                                Calendar.add(Calendar.DATE, 1);
                            }
// ----------------- Fix for LANG-440 ---------------------- END ---------------
                        } else {
                            //We need at add one to this field since the
                            //  last number causes us to round up
                            Calendar.add(fields[i][0], 1);
                        }
                    }
                    return;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.math.Fraction <265, 298>
int a1 = (int) value;
int a2 = 0;
double x1 = 1;
double x2 = 0;
double y1 = value - a1;
double y2 = 0;
double delta1, delta2 = Double.MAX_VALUE;
double fraction;
int i = 1;
//        System.out.println("---");
do {
            delta1 = delta2;
            a2 = (int) (x1 / y1);
            x2 = y1;
            y2 = x1 - a2 * y1;
            numer2 = a1 * numer1 + numer0;
            denom2 = a1 * denom1 + denom0;
            fraction = (double) numer2 / (double) denom2;
            delta2 = Math.abs(value - fraction);
//            System.out.println(numer2 + " " + denom2 + " " + fraction + " " + delta2 + " " + y1);
            a1 = a2;
            x1 = x2;
            y1 = y2;
            numer0 = numer1;
            denom0 = denom1;
            numer1 = numer2;
            denom1 = denom2;
            i++;
//            System.out.println(">>" + delta1 +" "+ delta2+" "+(delta1 > delta2)+" "+i+" "+denom2);
        } while ((delta1 > delta2) && (denom2 <= 10000) && (denom2 > 0) && (i < 25));
if (i == 25) {
            throw new ArithmeticException("Unable to convert double to fraction");
        }
return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0);

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.math.Fraction <265, 298>
int intVar = (int) doubleVar;
int intVar = 0;
double doubleVar = 1;
double doubleVar = 0;
double doubleVar = doubleVar - intVar;
double doubleVar = 0;
double doubleVar, doubleVar = Double.MAX_VALUE;
double doubleVar;
int intVar = 1;
//        System.out.println("---");
do {
            doubleVar = doubleVar;
            intVar = (int) (doubleVar / doubleVar);
            doubleVar = doubleVar;
            doubleVar = doubleVar - intVar * doubleVar;
            intVar = intVar * intVar + intVar;
            intVar = intVar * intVar + intVar;
            doubleVar = (double) intVar / (double) intVar;
            doubleVar = Math.abs(doubleVar - doubleVar);
//            System.out.println(numer2 + " " + denom2 + " " + fraction + " " + delta2 + " " + y1);
            intVar = intVar;
            doubleVar = doubleVar;
            doubleVar = doubleVar;
            intVar = intVar;
            intVar = intVar;
            intVar = intVar;
            intVar = intVar;
            intVar++;
//            System.out.println(">>" + delta1 +" "+ delta2+" "+(delta1 > delta2)+" "+i+" "+denom2);
        } while ((doubleVar > doubleVar) && (intVar <= 10000) && (intVar > 0) && (intVar < 25));
if (intVar == 25) {
            throw new ArithmeticException("Unable to convert double to fraction");
        }
return getReducedFraction((intVar + intVar * intVar) * intVar, intVar);

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.math.Fraction <265, 298>
int a1 = (int) value;
int a2 = 0;
double x1 = 1;
double x2 = 0;
double y1 = value - a1;
double y2 = 0;
double delta1, delta2 = Double.MAX_VALUE;
double fraction;
int i = 1;
//        System.out.println("---");
do {
            delta1 = delta2;
            a2 = (int) (x1 / y1);
            x2 = y1;
            y2 = x1 - a2 * y1;
            numer2 = a1 * numer1 + numer0;
            denom2 = a1 * denom1 + denom0;
            fraction = (double) numer2 / (double) denom2;
            delta2 = Math.abs(value - fraction);
//            System.out.println(numer2 + " " + denom2 + " " + fraction + " " + delta2 + " " + y1);
            a1 = a2;
            x1 = x2;
            y1 = y2;
            numer0 = numer1;
            denom0 = denom1;
            numer1 = numer2;
            denom1 = denom2;
            i++;
//            System.out.println(">>" + delta1 +" "+ delta2+" "+(delta1 > delta2)+" "+i+" "+denom2);
        } while ((delta1 > delta2) && (denom2 <= 10000) && (denom2 > 0) && (i < 25));
if (i == 25) {
            throw new ArithmeticException("Unable to convert double to fraction");
        }
return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.time.DateUtils <1719, 1721>
Calendar truncatedCal1 = truncate(cal1, field);
Calendar truncatedCal2 = truncate(cal2, field);
return truncatedCal1.compareTo(truncatedCal2);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.time.DateUtils <1739, 1741>
Date truncatedDate1 = truncate(date1, field);
Date truncatedDate2 = truncate(date2, field);
return truncatedDate1.compareTo(truncatedDate2);

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.time.DateUtils <327, 329>
if (parsePatterns[i].endsWith("ZZ")) {
                str2 = str.replaceAll("([-+][0-9][0-9]):([0-9][0-9])$", "$1$2"); 
            }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.time.DateUtils <327, 329>
if (String[]Var[intVar].endsWith("ZZ")) {
                StringVar = StringVar.replaceAll("([-+][0-9][0-9]):([0-9][0-9])$", "$1$2"); 
            }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.time.DateUtils <327, 329>
if (parsePatterns[i].endsWith("ZZ")) {
                str2 = str.replaceAll("([-+][0-9][0-9]):([0-9][0-9])$", "$1$2"); 
            }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.Range <155, 161>
if (comparator.compare(element1, element2) < 1) {
            this.minimum = element1;
            this.maximum = element2;
        } else {
            this.minimum = element2;
            this.maximum = element1;
        }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.Range <155, 161>
if (Comparator.compare(element1, element2) < 1) {
            Range.minimum = element1;
            Range.maximum = element2;
        } else {
            Range.minimum = element2;
            Range.maximum = element1;
        }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.time.FastDateFormat <496, 504>
if (tokenLen >= 4) {
                    rule = new TextField(Calendar.MONTH, months);
                } else if (tokenLen == 3) {
                    rule = new TextField(Calendar.MONTH, shortMonths);
                } else if (tokenLen == 2) {
                    rule = TwoDigitMonthField.INSTANCE;
                } else {
                    rule = UnpaddedMonthField.INSTANCE;
                }

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.time.FastDateFormat <496, 504>
if (intVar >= 4) {
                    Rule = new TextField(Calendar.MONTH, String[]Var);
                } else if (intVar == 3) {
                    Rule = new TextField(Calendar.MONTH, String[]Var);
                } else if (intVar == 2) {
                    Rule = TwoDigitMonthField.INSTANCE;
                } else {
                    Rule = UnpaddedMonthField.INSTANCE;
                }

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.time.FastDateFormat <496, 504>
if (tokenLen >= 4) {
                    Rule = new TextField(Calendar.MONTH, months);
                } else if (tokenLen == 3) {
                    Rule = new TextField(Calendar.MONTH, shortMonths);
                } else if (tokenLen == 2) {
                    Rule = TwoDigitMonthField.INSTANCE;
                } else {
                    Rule = UnpaddedMonthField.INSTANCE;
                }

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.SerializationUtils <135, 137>
ByteArrayOutputStream baos = new ByteArrayOutputStream(512);
serialize(obj, baos);
return baos.toByteArray();

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.SerializationUtils <135, 137>
ByteArrayOutputStream ByteArrayOutputStream = new ByteArrayOutputStream(512);
serialize(Serializable, ByteArrayOutputStream);
return ByteArrayOutputStream.toByteArray();

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.SerializationUtils <135, 137>
ByteArrayOutputStream ByteArrayOutputStream = new ByteArrayOutputStream(512);
serialize(Serializable, ByteArrayOutputStream);
return ByteArrayOutputStream.toByteArray();

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.text.StrSubstitutor <693, 701>
if (priorVariables.contains(varName) == false) {
            return;
        }
StrBuilder buf = new StrBuilder(256);
buf.append("Infinite loop in property interpolation of ");
buf.append(priorVariables.remove(0));
buf.append(": ");
buf.appendWithSeparators(priorVariables, "->");
throw new IllegalStateException(buf.toString());

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.text.StrSubstitutor <693, 701>
if (ListVar.contains(StringVar) == false) {
            return;
        }
StrBuilder StrBuilder = new StrBuilder(256);
StrBuilder.append("Infinite loop in property interpolation of ");
StrBuilder.append(ListVar.remove(0));
StrBuilder.append(": ");
StrBuilder.appendWithSeparators(ListVar, "->");
throw new IllegalStateException(StrBuilder.toString());

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.text.StrSubstitutor <693, 701>
if (priorVariables.contains(varName) == false) {
            return;
        }
StrBuilder StrBuilder = new StrBuilder(256);
StrBuilder.append("Infinite loop in property interpolation of ");
StrBuilder.append(priorVariables.remove(0));
StrBuilder.append(": ");
StrBuilder.appendWithSeparators(priorVariables, "->");
throw new IllegalStateException(StrBuilder.toString());

---fix ingredient  <ori-fine-grained>  varMapType:ori--- org.apache.commons.lang3.CharUtils <329, 332>
if (ch < 128) {
            return CHAR_STRING_ARRAY[ch];
        }
return new String(new char[] {ch});

---fix ingredient  <0-fine-grained>  varMapType:0--- org.apache.commons.lang3.CharUtils <329, 332>
if (charVar < 128) {
            return String[]Var[charVar];
        }
return new String(new char[] {charVar});

---fix ingredient  <1-fine-grained>  varMapType:1--- org.apache.commons.lang3.CharUtils <329, 332>
if (ch < 128) {
            return CHAR_STRING_ARRAY[ch];
        }
return new String(new char[] {ch});

